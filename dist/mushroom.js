var version$1 = "2.4.1";

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$3=window.ShadowRoot&&(void 0===window.ShadyCSS||window.ShadyCSS.nativeShadow)&&"adoptedStyleSheets"in Document.prototype&&"replace"in CSSStyleSheet.prototype,e$6=Symbol(),n$5=new Map;class s$4{constructor(t,n){if(this._$cssResult$=!0,n!==e$6)throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");this.cssText=t;}get styleSheet(){let e=n$5.get(this.cssText);return t$3&&void 0===e&&(n$5.set(this.cssText,e=new CSSStyleSheet),e.replaceSync(this.cssText)),e}toString(){return this.cssText}}const o$5=t=>new s$4("string"==typeof t?t:t+"",e$6),r$3=(t,...n)=>{const o=1===t.length?t[0]:n.reduce(((e,n,s)=>e+(t=>{if(!0===t._$cssResult$)return t.cssText;if("number"==typeof t)return t;throw Error("Value passed to 'css' function must be a 'css' function result: "+t+". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.")})(n)+t[s+1]),t[0]);return new s$4(o,e$6)},i$7=(e,n)=>{t$3?e.adoptedStyleSheets=n.map((t=>t instanceof CSSStyleSheet?t:t.styleSheet)):n.forEach((t=>{const n=document.createElement("style"),s=window.litNonce;void 0!==s&&n.setAttribute("nonce",s),n.textContent=t.cssText,e.appendChild(n);}));},S$1=t$3?t=>t:t=>t instanceof CSSStyleSheet?(t=>{let e="";for(const n of t.cssRules)e+=n.cssText;return o$5(e)})(t):t;

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */var s$3;const e$5=window.trustedTypes,r$2=e$5?e$5.emptyScript:"",h$1=window.reactiveElementPolyfillSupport,o$4={toAttribute(t,i){switch(i){case Boolean:t=t?r$2:null;break;case Object:case Array:t=null==t?t:JSON.stringify(t);}return t},fromAttribute(t,i){let s=t;switch(i){case Boolean:s=null!==t;break;case Number:s=null===t?null:Number(t);break;case Object:case Array:try{s=JSON.parse(t);}catch(t){s=null;}}return s}},n$4=(t,i)=>i!==t&&(i==i||t==t),l$4={attribute:!0,type:String,converter:o$4,reflect:!1,hasChanged:n$4};class a$1 extends HTMLElement{constructor(){super(),this._$Et=new Map,this.isUpdatePending=!1,this.hasUpdated=!1,this._$Ei=null,this.o();}static addInitializer(t){var i;null!==(i=this.l)&&void 0!==i||(this.l=[]),this.l.push(t);}static get observedAttributes(){this.finalize();const t=[];return this.elementProperties.forEach(((i,s)=>{const e=this._$Eh(s,i);void 0!==e&&(this._$Eu.set(e,s),t.push(e));})),t}static createProperty(t,i=l$4){if(i.state&&(i.attribute=!1),this.finalize(),this.elementProperties.set(t,i),!i.noAccessor&&!this.prototype.hasOwnProperty(t)){const s="symbol"==typeof t?Symbol():"__"+t,e=this.getPropertyDescriptor(t,s,i);void 0!==e&&Object.defineProperty(this.prototype,t,e);}}static getPropertyDescriptor(t,i,s){return {get(){return this[i]},set(e){const r=this[t];this[i]=e,this.requestUpdate(t,r,s);},configurable:!0,enumerable:!0}}static getPropertyOptions(t){return this.elementProperties.get(t)||l$4}static finalize(){if(this.hasOwnProperty("finalized"))return !1;this.finalized=!0;const t=Object.getPrototypeOf(this);if(t.finalize(),this.elementProperties=new Map(t.elementProperties),this._$Eu=new Map,this.hasOwnProperty("properties")){const t=this.properties,i=[...Object.getOwnPropertyNames(t),...Object.getOwnPropertySymbols(t)];for(const s of i)this.createProperty(s,t[s]);}return this.elementStyles=this.finalizeStyles(this.styles),!0}static finalizeStyles(i){const s=[];if(Array.isArray(i)){const e=new Set(i.flat(1/0).reverse());for(const i of e)s.unshift(S$1(i));}else void 0!==i&&s.push(S$1(i));return s}static _$Eh(t,i){const s=i.attribute;return !1===s?void 0:"string"==typeof s?s:"string"==typeof t?t.toLowerCase():void 0}o(){var t;this._$Ep=new Promise((t=>this.enableUpdating=t)),this._$AL=new Map,this._$Em(),this.requestUpdate(),null===(t=this.constructor.l)||void 0===t||t.forEach((t=>t(this)));}addController(t){var i,s;(null!==(i=this._$Eg)&&void 0!==i?i:this._$Eg=[]).push(t),void 0!==this.renderRoot&&this.isConnected&&(null===(s=t.hostConnected)||void 0===s||s.call(t));}removeController(t){var i;null===(i=this._$Eg)||void 0===i||i.splice(this._$Eg.indexOf(t)>>>0,1);}_$Em(){this.constructor.elementProperties.forEach(((t,i)=>{this.hasOwnProperty(i)&&(this._$Et.set(i,this[i]),delete this[i]);}));}createRenderRoot(){var t;const s=null!==(t=this.shadowRoot)&&void 0!==t?t:this.attachShadow(this.constructor.shadowRootOptions);return i$7(s,this.constructor.elementStyles),s}connectedCallback(){var t;void 0===this.renderRoot&&(this.renderRoot=this.createRenderRoot()),this.enableUpdating(!0),null===(t=this._$Eg)||void 0===t||t.forEach((t=>{var i;return null===(i=t.hostConnected)||void 0===i?void 0:i.call(t)}));}enableUpdating(t){}disconnectedCallback(){var t;null===(t=this._$Eg)||void 0===t||t.forEach((t=>{var i;return null===(i=t.hostDisconnected)||void 0===i?void 0:i.call(t)}));}attributeChangedCallback(t,i,s){this._$AK(t,s);}_$ES(t,i,s=l$4){var e,r;const h=this.constructor._$Eh(t,s);if(void 0!==h&&!0===s.reflect){const n=(null!==(r=null===(e=s.converter)||void 0===e?void 0:e.toAttribute)&&void 0!==r?r:o$4.toAttribute)(i,s.type);this._$Ei=t,null==n?this.removeAttribute(h):this.setAttribute(h,n),this._$Ei=null;}}_$AK(t,i){var s,e,r;const h=this.constructor,n=h._$Eu.get(t);if(void 0!==n&&this._$Ei!==n){const t=h.getPropertyOptions(n),l=t.converter,a=null!==(r=null!==(e=null===(s=l)||void 0===s?void 0:s.fromAttribute)&&void 0!==e?e:"function"==typeof l?l:null)&&void 0!==r?r:o$4.fromAttribute;this._$Ei=n,this[n]=a(i,t.type),this._$Ei=null;}}requestUpdate(t,i,s){let e=!0;void 0!==t&&(((s=s||this.constructor.getPropertyOptions(t)).hasChanged||n$4)(this[t],i)?(this._$AL.has(t)||this._$AL.set(t,i),!0===s.reflect&&this._$Ei!==t&&(void 0===this._$EC&&(this._$EC=new Map),this._$EC.set(t,s))):e=!1),!this.isUpdatePending&&e&&(this._$Ep=this._$E_());}async _$E_(){this.isUpdatePending=!0;try{await this._$Ep;}catch(t){Promise.reject(t);}const t=this.scheduleUpdate();return null!=t&&await t,!this.isUpdatePending}scheduleUpdate(){return this.performUpdate()}performUpdate(){var t;if(!this.isUpdatePending)return;this.hasUpdated,this._$Et&&(this._$Et.forEach(((t,i)=>this[i]=t)),this._$Et=void 0);let i=!1;const s=this._$AL;try{i=this.shouldUpdate(s),i?(this.willUpdate(s),null===(t=this._$Eg)||void 0===t||t.forEach((t=>{var i;return null===(i=t.hostUpdate)||void 0===i?void 0:i.call(t)})),this.update(s)):this._$EU();}catch(t){throw i=!1,this._$EU(),t}i&&this._$AE(s);}willUpdate(t){}_$AE(t){var i;null===(i=this._$Eg)||void 0===i||i.forEach((t=>{var i;return null===(i=t.hostUpdated)||void 0===i?void 0:i.call(t)})),this.hasUpdated||(this.hasUpdated=!0,this.firstUpdated(t)),this.updated(t);}_$EU(){this._$AL=new Map,this.isUpdatePending=!1;}get updateComplete(){return this.getUpdateComplete()}getUpdateComplete(){return this._$Ep}shouldUpdate(t){return !0}update(t){void 0!==this._$EC&&(this._$EC.forEach(((t,i)=>this._$ES(i,this[i],t))),this._$EC=void 0),this._$EU();}updated(t){}firstUpdated(t){}}a$1.finalized=!0,a$1.elementProperties=new Map,a$1.elementStyles=[],a$1.shadowRootOptions={mode:"open"},null==h$1||h$1({ReactiveElement:a$1}),(null!==(s$3=globalThis.reactiveElementVersions)&&void 0!==s$3?s$3:globalThis.reactiveElementVersions=[]).push("1.3.0");

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var t$2;const i$6=globalThis.trustedTypes,s$2=i$6?i$6.createPolicy("lit-html",{createHTML:t=>t}):void 0,e$4=`lit$${(Math.random()+"").slice(9)}$`,o$3="?"+e$4,n$3=`<${o$3}>`,l$3=document,h=(t="")=>l$3.createComment(t),r$1=t=>null===t||"object"!=typeof t&&"function"!=typeof t,d=Array.isArray,u=t=>{var i;return d(t)||"function"==typeof(null===(i=t)||void 0===i?void 0:i[Symbol.iterator])},c=/<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,v=/-->/g,a=/>/g,f$1=/>|[ 	\n\r](?:([^\s"'>=/]+)([ 	\n\r]*=[ 	\n\r]*(?:[^ 	\n\r"'`<>=]|("|')|))|$)/g,_=/'/g,m=/"/g,g=/^(?:script|style|textarea|title)$/i,p=t=>(i,...s)=>({_$litType$:t,strings:i,values:s}),$=p(1),y=p(2),b=Symbol.for("lit-noChange"),w=Symbol.for("lit-nothing"),T=new WeakMap,x=(t,i,s)=>{var e,o;const n=null!==(e=null==s?void 0:s.renderBefore)&&void 0!==e?e:i;let l=n._$litPart$;if(void 0===l){const t=null!==(o=null==s?void 0:s.renderBefore)&&void 0!==o?o:null;n._$litPart$=l=new N(i.insertBefore(h(),t),t,void 0,null!=s?s:{});}return l._$AI(t),l},A=l$3.createTreeWalker(l$3,129,null,!1),C=(t,i)=>{const o=t.length-1,l=[];let h,r=2===i?"<svg>":"",d=c;for(let i=0;i<o;i++){const s=t[i];let o,u,p=-1,$=0;for(;$<s.length&&(d.lastIndex=$,u=d.exec(s),null!==u);)$=d.lastIndex,d===c?"!--"===u[1]?d=v:void 0!==u[1]?d=a:void 0!==u[2]?(g.test(u[2])&&(h=RegExp("</"+u[2],"g")),d=f$1):void 0!==u[3]&&(d=f$1):d===f$1?">"===u[0]?(d=null!=h?h:c,p=-1):void 0===u[1]?p=-2:(p=d.lastIndex-u[2].length,o=u[1],d=void 0===u[3]?f$1:'"'===u[3]?m:_):d===m||d===_?d=f$1:d===v||d===a?d=c:(d=f$1,h=void 0);const y=d===f$1&&t[i+1].startsWith("/>")?" ":"";r+=d===c?s+n$3:p>=0?(l.push(o),s.slice(0,p)+"$lit$"+s.slice(p)+e$4+y):s+e$4+(-2===p?(l.push(void 0),i):y);}const u=r+(t[o]||"<?>")+(2===i?"</svg>":"");if(!Array.isArray(t)||!t.hasOwnProperty("raw"))throw Error("invalid template strings array");return [void 0!==s$2?s$2.createHTML(u):u,l]};class E{constructor({strings:t,_$litType$:s},n){let l;this.parts=[];let r=0,d=0;const u=t.length-1,c=this.parts,[v,a]=C(t,s);if(this.el=E.createElement(v,n),A.currentNode=this.el.content,2===s){const t=this.el.content,i=t.firstChild;i.remove(),t.append(...i.childNodes);}for(;null!==(l=A.nextNode())&&c.length<u;){if(1===l.nodeType){if(l.hasAttributes()){const t=[];for(const i of l.getAttributeNames())if(i.endsWith("$lit$")||i.startsWith(e$4)){const s=a[d++];if(t.push(i),void 0!==s){const t=l.getAttribute(s.toLowerCase()+"$lit$").split(e$4),i=/([.?@])?(.*)/.exec(s);c.push({type:1,index:r,name:i[2],strings:t,ctor:"."===i[1]?M:"?"===i[1]?H:"@"===i[1]?I:S});}else c.push({type:6,index:r});}for(const i of t)l.removeAttribute(i);}if(g.test(l.tagName)){const t=l.textContent.split(e$4),s=t.length-1;if(s>0){l.textContent=i$6?i$6.emptyScript:"";for(let i=0;i<s;i++)l.append(t[i],h()),A.nextNode(),c.push({type:2,index:++r});l.append(t[s],h());}}}else if(8===l.nodeType)if(l.data===o$3)c.push({type:2,index:r});else {let t=-1;for(;-1!==(t=l.data.indexOf(e$4,t+1));)c.push({type:7,index:r}),t+=e$4.length-1;}r++;}}static createElement(t,i){const s=l$3.createElement("template");return s.innerHTML=t,s}}function P(t,i,s=t,e){var o,n,l,h;if(i===b)return i;let d=void 0!==e?null===(o=s._$Cl)||void 0===o?void 0:o[e]:s._$Cu;const u=r$1(i)?void 0:i._$litDirective$;return (null==d?void 0:d.constructor)!==u&&(null===(n=null==d?void 0:d._$AO)||void 0===n||n.call(d,!1),void 0===u?d=void 0:(d=new u(t),d._$AT(t,s,e)),void 0!==e?(null!==(l=(h=s)._$Cl)&&void 0!==l?l:h._$Cl=[])[e]=d:s._$Cu=d),void 0!==d&&(i=P(t,d._$AS(t,i.values),d,e)),i}class V{constructor(t,i){this.v=[],this._$AN=void 0,this._$AD=t,this._$AM=i;}get parentNode(){return this._$AM.parentNode}get _$AU(){return this._$AM._$AU}p(t){var i;const{el:{content:s},parts:e}=this._$AD,o=(null!==(i=null==t?void 0:t.creationScope)&&void 0!==i?i:l$3).importNode(s,!0);A.currentNode=o;let n=A.nextNode(),h=0,r=0,d=e[0];for(;void 0!==d;){if(h===d.index){let i;2===d.type?i=new N(n,n.nextSibling,this,t):1===d.type?i=new d.ctor(n,d.name,d.strings,this,t):6===d.type&&(i=new L(n,this,t)),this.v.push(i),d=e[++r];}h!==(null==d?void 0:d.index)&&(n=A.nextNode(),h++);}return o}m(t){let i=0;for(const s of this.v)void 0!==s&&(void 0!==s.strings?(s._$AI(t,s,i),i+=s.strings.length-2):s._$AI(t[i])),i++;}}class N{constructor(t,i,s,e){var o;this.type=2,this._$AH=w,this._$AN=void 0,this._$AA=t,this._$AB=i,this._$AM=s,this.options=e,this._$Cg=null===(o=null==e?void 0:e.isConnected)||void 0===o||o;}get _$AU(){var t,i;return null!==(i=null===(t=this._$AM)||void 0===t?void 0:t._$AU)&&void 0!==i?i:this._$Cg}get parentNode(){let t=this._$AA.parentNode;const i=this._$AM;return void 0!==i&&11===t.nodeType&&(t=i.parentNode),t}get startNode(){return this._$AA}get endNode(){return this._$AB}_$AI(t,i=this){t=P(this,t,i),r$1(t)?t===w||null==t||""===t?(this._$AH!==w&&this._$AR(),this._$AH=w):t!==this._$AH&&t!==b&&this.$(t):void 0!==t._$litType$?this.T(t):void 0!==t.nodeType?this.k(t):u(t)?this.S(t):this.$(t);}A(t,i=this._$AB){return this._$AA.parentNode.insertBefore(t,i)}k(t){this._$AH!==t&&(this._$AR(),this._$AH=this.A(t));}$(t){this._$AH!==w&&r$1(this._$AH)?this._$AA.nextSibling.data=t:this.k(l$3.createTextNode(t)),this._$AH=t;}T(t){var i;const{values:s,_$litType$:e}=t,o="number"==typeof e?this._$AC(t):(void 0===e.el&&(e.el=E.createElement(e.h,this.options)),e);if((null===(i=this._$AH)||void 0===i?void 0:i._$AD)===o)this._$AH.m(s);else {const t=new V(o,this),i=t.p(this.options);t.m(s),this.k(i),this._$AH=t;}}_$AC(t){let i=T.get(t.strings);return void 0===i&&T.set(t.strings,i=new E(t)),i}S(t){d(this._$AH)||(this._$AH=[],this._$AR());const i=this._$AH;let s,e=0;for(const o of t)e===i.length?i.push(s=new N(this.A(h()),this.A(h()),this,this.options)):s=i[e],s._$AI(o),e++;e<i.length&&(this._$AR(s&&s._$AB.nextSibling,e),i.length=e);}_$AR(t=this._$AA.nextSibling,i){var s;for(null===(s=this._$AP)||void 0===s||s.call(this,!1,!0,i);t&&t!==this._$AB;){const i=t.nextSibling;t.remove(),t=i;}}setConnected(t){var i;void 0===this._$AM&&(this._$Cg=t,null===(i=this._$AP)||void 0===i||i.call(this,t));}}class S{constructor(t,i,s,e,o){this.type=1,this._$AH=w,this._$AN=void 0,this.element=t,this.name=i,this._$AM=e,this.options=o,s.length>2||""!==s[0]||""!==s[1]?(this._$AH=Array(s.length-1).fill(new String),this.strings=s):this._$AH=w;}get tagName(){return this.element.tagName}get _$AU(){return this._$AM._$AU}_$AI(t,i=this,s,e){const o=this.strings;let n=!1;if(void 0===o)t=P(this,t,i,0),n=!r$1(t)||t!==this._$AH&&t!==b,n&&(this._$AH=t);else {const e=t;let l,h;for(t=o[0],l=0;l<o.length-1;l++)h=P(this,e[s+l],i,l),h===b&&(h=this._$AH[l]),n||(n=!r$1(h)||h!==this._$AH[l]),h===w?t=w:t!==w&&(t+=(null!=h?h:"")+o[l+1]),this._$AH[l]=h;}n&&!e&&this.C(t);}C(t){t===w?this.element.removeAttribute(this.name):this.element.setAttribute(this.name,null!=t?t:"");}}class M extends S{constructor(){super(...arguments),this.type=3;}C(t){this.element[this.name]=t===w?void 0:t;}}const k=i$6?i$6.emptyScript:"";class H extends S{constructor(){super(...arguments),this.type=4;}C(t){t&&t!==w?this.element.setAttribute(this.name,k):this.element.removeAttribute(this.name);}}class I extends S{constructor(t,i,s,e,o){super(t,i,s,e,o),this.type=5;}_$AI(t,i=this){var s;if((t=null!==(s=P(this,t,i,0))&&void 0!==s?s:w)===b)return;const e=this._$AH,o=t===w&&e!==w||t.capture!==e.capture||t.once!==e.once||t.passive!==e.passive,n=t!==w&&(e===w||o);o&&this.element.removeEventListener(this.name,this,e),n&&this.element.addEventListener(this.name,this,t),this._$AH=t;}handleEvent(t){var i,s;"function"==typeof this._$AH?this._$AH.call(null!==(s=null===(i=this.options)||void 0===i?void 0:i.host)&&void 0!==s?s:this.element,t):this._$AH.handleEvent(t);}}class L{constructor(t,i,s){this.element=t,this.type=6,this._$AN=void 0,this._$AM=i,this.options=s;}get _$AU(){return this._$AM._$AU}_$AI(t){P(this,t);}}const z=window.litHtmlPolyfillSupport;null==z||z(E,N),(null!==(t$2=globalThis.litHtmlVersions)&&void 0!==t$2?t$2:globalThis.litHtmlVersions=[]).push("2.2.0");

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */var l$2,o$2;class s$1 extends a$1{constructor(){super(...arguments),this.renderOptions={host:this},this._$Dt=void 0;}createRenderRoot(){var t,e;const i=super.createRenderRoot();return null!==(t=(e=this.renderOptions).renderBefore)&&void 0!==t||(e.renderBefore=i.firstChild),i}update(t){const i=this.render();this.hasUpdated||(this.renderOptions.isConnected=this.isConnected),super.update(t),this._$Dt=x(i,this.renderRoot,this.renderOptions);}connectedCallback(){var t;super.connectedCallback(),null===(t=this._$Dt)||void 0===t||t.setConnected(!0);}disconnectedCallback(){var t;super.disconnectedCallback(),null===(t=this._$Dt)||void 0===t||t.setConnected(!1);}render(){return b}}s$1.finalized=!0,s$1._$litElement$=!0,null===(l$2=globalThis.litElementHydrateSupport)||void 0===l$2||l$2.call(globalThis,{LitElement:s$1});const n$2=globalThis.litElementPolyfillSupport;null==n$2||n$2({LitElement:s$1});(null!==(o$2=globalThis.litElementVersions)&&void 0!==o$2?o$2:globalThis.litElementVersions=[]).push("3.2.0");

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const n$1=n=>e=>"function"==typeof e?((n,e)=>(window.customElements.define(n,e),e))(n,e):((n,e)=>{const{kind:t,elements:i}=e;return {kind:t,elements:i,finisher(e){window.customElements.define(n,e);}}})(n,e);

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const i$5=(i,e)=>"method"===e.kind&&e.descriptor&&!("value"in e.descriptor)?{...e,finisher(n){n.createProperty(e.key,i);}}:{kind:"field",key:Symbol(),placement:"own",descriptor:{},originalKey:e.key,initializer(){"function"==typeof e.initializer&&(this[e.key]=e.initializer.call(this));},finisher(n){n.createProperty(e.key,i);}};function e$3(e){return (n,t)=>void 0!==t?((i,e,n)=>{e.constructor.createProperty(n,i);})(e,n,t):i$5(e,n)}

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */function t$1(t){return e$3({...t,state:!0})}

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const o$1=({finisher:e,descriptor:t})=>(o,n)=>{var r;if(void 0===n){const n=null!==(r=o.originalKey)&&void 0!==r?r:o.key,i=null!=t?{kind:"method",placement:"prototype",key:n,descriptor:t(o.key)}:{...o,key:n};return null!=e&&(i.finisher=function(t){e(t,n);}),i}{const r=o.constructor;void 0!==t&&Object.defineProperty(o,n,t(n)),null==e||e(r,n);}};

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */function e$2(e){return o$1({finisher:(r,t)=>{Object.assign(r.prototype[t],e);}})}

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */function i$4(i,n){return o$1({descriptor:o=>{const t={get(){var o,n;return null!==(n=null===(o=this.renderRoot)||void 0===o?void 0:o.querySelector(i))&&void 0!==n?n:null},enumerable:!0,configurable:!0};if(n){const n="symbol"==typeof o?Symbol():"__"+o;t.get=function(){var o,t;return void 0===this[n]&&(this[n]=null!==(t=null===(o=this.renderRoot)||void 0===o?void 0:o.querySelector(i))&&void 0!==t?t:null),this[n]};}return t}})}

/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */var n;null!=(null===(n=window.HTMLSlotElement)||void 0===n?void 0:n.prototype.assignedElements)?(o,n)=>o.assignedElements(n):(o,n)=>o.assignedNodes(n).filter((o=>o.nodeType===Node.ELEMENT_NODE));

/** States that we consider "off". */
const STATES_OFF = ["closed", "locked", "off"];
/** Temperature units. */
const UNIT_C = "°C";
const UNIT_F = "°F";

var safeIsNaN = Number.isNaN ||
    function ponyfill(value) {
        return typeof value === 'number' && value !== value;
    };
function isEqual(first, second) {
    if (first === second) {
        return true;
    }
    if (safeIsNaN(first) && safeIsNaN(second)) {
        return true;
    }
    return false;
}
function areInputsEqual(newInputs, lastInputs) {
    if (newInputs.length !== lastInputs.length) {
        return false;
    }
    for (var i = 0; i < newInputs.length; i++) {
        if (!isEqual(newInputs[i], lastInputs[i])) {
            return false;
        }
    }
    return true;
}

function memoizeOne(resultFn, isEqual) {
    if (isEqual === void 0) { isEqual = areInputsEqual; }
    var cache = null;
    function memoized() {
        var newArgs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            newArgs[_i] = arguments[_i];
        }
        if (cache && cache.lastThis === this && isEqual(newArgs, cache.lastArgs)) {
            return cache.lastResult;
        }
        var lastResult = resultFn.apply(this, newArgs);
        cache = {
            lastResult: lastResult,
            lastArgs: newArgs,
            lastThis: this,
        };
        return lastResult;
    }
    memoized.clear = function clear() {
        cache = null;
    };
    return memoized;
}

memoizeOne((locale) => new Intl.DateTimeFormat(locale.language, {
    weekday: "long",
    month: "long",
    day: "numeric",
}));
// August 10, 2021
const formatDate = (dateObj, locale) => formatDateMem(locale).format(dateObj);
const formatDateMem = memoizeOne((locale) => new Intl.DateTimeFormat(locale.language, {
    year: "numeric",
    month: "long",
    day: "numeric",
}));
memoizeOne((locale) => new Intl.DateTimeFormat(locale.language, {
    year: "numeric",
    month: "numeric",
    day: "numeric",
}));
memoizeOne((locale) => new Intl.DateTimeFormat(locale.language, {
    day: "numeric",
    month: "short",
}));
memoizeOne((locale) => new Intl.DateTimeFormat(locale.language, {
    month: "long",
    year: "numeric",
}));
memoizeOne((locale) => new Intl.DateTimeFormat(locale.language, {
    month: "long",
}));
memoizeOne((locale) => new Intl.DateTimeFormat(locale.language, {
    year: "numeric",
}));

var NumberFormat;
(function (NumberFormat) {
    NumberFormat["language"] = "language";
    NumberFormat["system"] = "system";
    NumberFormat["comma_decimal"] = "comma_decimal";
    NumberFormat["decimal_comma"] = "decimal_comma";
    NumberFormat["space_comma"] = "space_comma";
    NumberFormat["none"] = "none";
})(NumberFormat || (NumberFormat = {}));
var TimeFormat;
(function (TimeFormat) {
    TimeFormat["language"] = "language";
    TimeFormat["system"] = "system";
    TimeFormat["am_pm"] = "12";
    TimeFormat["twenty_four"] = "24";
})(TimeFormat || (TimeFormat = {}));

const useAmPm = memoizeOne((locale) => {
    if (locale.time_format === TimeFormat.language || locale.time_format === TimeFormat.system) {
        const testLanguage = locale.time_format === TimeFormat.language ? locale.language : undefined;
        const test = new Date().toLocaleString(testLanguage);
        return test.includes("AM") || test.includes("PM");
    }
    return locale.time_format === TimeFormat.am_pm;
});

// August 9, 2021, 8:23 AM
const formatDateTime = (dateObj, locale) => formatDateTimeMem(locale).format(dateObj);
const formatDateTimeMem = memoizeOne((locale) => new Intl.DateTimeFormat(locale.language === "en" && !useAmPm(locale) ? "en-u-hc-h23" : locale.language, {
    year: "numeric",
    month: "long",
    day: "numeric",
    hour: useAmPm(locale) ? "numeric" : "2-digit",
    minute: "2-digit",
    hour12: useAmPm(locale),
}));
memoizeOne((locale) => new Intl.DateTimeFormat(locale.language === "en" && !useAmPm(locale) ? "en-u-hc-h23" : locale.language, {
    year: "numeric",
    month: "long",
    day: "numeric",
    hour: useAmPm(locale) ? "numeric" : "2-digit",
    minute: "2-digit",
    second: "2-digit",
    hour12: useAmPm(locale),
}));
memoizeOne((locale) => new Intl.DateTimeFormat(locale.language === "en" && !useAmPm(locale) ? "en-u-hc-h23" : locale.language, {
    year: "numeric",
    month: "numeric",
    day: "numeric",
    hour: "numeric",
    minute: "2-digit",
    hour12: useAmPm(locale),
}));

// 9:15 PM || 21:15
const formatTime = (dateObj, locale) => formatTimeMem(locale).format(dateObj);
const formatTimeMem = memoizeOne((locale) => new Intl.DateTimeFormat(locale.language === "en" && !useAmPm(locale) ? "en-u-hc-h23" : locale.language, {
    hour: "numeric",
    minute: "2-digit",
    hour12: useAmPm(locale),
}));
memoizeOne((locale) => new Intl.DateTimeFormat(locale.language === "en" && !useAmPm(locale) ? "en-u-hc-h23" : locale.language, {
    hour: useAmPm(locale) ? "numeric" : "2-digit",
    minute: "2-digit",
    second: "2-digit",
    hour12: useAmPm(locale),
}));
memoizeOne((locale) => new Intl.DateTimeFormat(locale.language === "en" && !useAmPm(locale) ? "en-u-hc-h23" : locale.language, {
    weekday: "long",
    hour: useAmPm(locale) ? "numeric" : "2-digit",
    minute: "2-digit",
    hour12: useAmPm(locale),
}));

// Polymer legacy event helpers used courtesy of the Polymer project.
//
// Copyright (c) 2017 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//    * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//    * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//    * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
/**
 * Dispatches a custom event with an optional detail value.
 *
 * @param {string} type Name of event type.
 * @param {*=} detail Detail value containing event-specific
 *   payload.
 * @param {{ bubbles: (boolean|undefined),
 *           cancelable: (boolean|undefined),
 *           composed: (boolean|undefined) }=}
 *  options Object specifying options.  These may include:
 *  `bubbles` (boolean, defaults to `true`),
 *  `cancelable` (boolean, defaults to false), and
 *  `node` on which to fire the event (HTMLElement, defaults to `this`).
 * @return {Event} The new event that was fired.
 */
const fireEvent = (node, type, detail, options) => {
    options = options || {};
    // @ts-ignore
    detail = detail === null || detail === undefined ? {} : detail;
    const event = new Event(type, {
        bubbles: options.bubbles === undefined ? true : options.bubbles,
        cancelable: Boolean(options.cancelable),
        composed: options.composed === undefined ? true : options.composed,
    });
    event.detail = detail;
    node.dispatchEvent(event);
    return event;
};

const MAIN_WINDOW_NAME = "ha-main-window";

const mainWindow = window.name === MAIN_WINDOW_NAME ? window : parent.name === MAIN_WINDOW_NAME ? parent : top;

const computeDomain = (entityId) => entityId.substr(0, entityId.indexOf("."));

const UNAVAILABLE = "unavailable";
const UNKNOWN = "unknown";
const OFF = "off";
const OFF_STATES = [UNAVAILABLE, UNKNOWN, OFF];
function isActive(entity) {
    const domain = computeDomain(entity.entity_id);
    const state = entity.state;
    if (["button", "input_button", "scene"].includes(domain)) {
        return state !== UNAVAILABLE;
    }
    if (OFF_STATES.includes(state)) {
        return false;
    }
    // Custom cases
    switch (domain) {
        case "cover":
            return !["closed", "closing"].includes(state);
        case "device_tracker":
        case "person":
            return state !== "not_home";
        case "media_player":
            return state !== "standby";
        case "vacuum":
            return !["idle", "docked", "paused"].includes(state);
        case "plant":
            return state === "problem";
        default:
            return true;
    }
}
function isAvailable(entity) {
    return entity.state !== UNAVAILABLE;
}
function isOff(entity) {
    return entity.state === OFF;
}
function isUnknown(entity) {
    return entity.state === UNKNOWN;
}
function getEntityPicture(entity) {
    return (entity.attributes.entity_picture_local ||
        entity.attributes.entity_picture);
}

const supportsFeature = (stateObj, feature) => (stateObj.attributes.supported_features & feature) !== 0;

const UPDATE_SUPPORT_INSTALL = 1;
const UPDATE_SUPPORT_PROGRESS = 4;
const updateUsesProgress = (entity) => supportsFeature(entity, UPDATE_SUPPORT_PROGRESS) &&
    typeof entity.attributes.in_progress === "number";
const updateIsInstalling = (entity) => updateUsesProgress(entity) || !!entity.attributes.in_progress;

const round = (value, precision = 2) => Math.round(value * 10 ** precision) / 10 ** precision;

/**
 * Returns true if the entity is considered numeric based on the attributes it has
 * @param stateObj The entity state object
 */
const isNumericState = (stateObj) => isNumericFromAttributes(stateObj.attributes);
const isNumericFromAttributes = (attributes) => !!attributes.unit_of_measurement || !!attributes.state_class;
const numberFormatToLocale = (localeOptions) => {
    switch (localeOptions.number_format) {
        case NumberFormat.comma_decimal:
            return ["en-US", "en"]; // Use United States with fallback to English formatting 1,234,567.89
        case NumberFormat.decimal_comma:
            return ["de", "es", "it"]; // Use German with fallback to Spanish then Italian formatting 1.234.567,89
        case NumberFormat.space_comma:
            return ["fr", "sv", "cs"]; // Use French with fallback to Swedish and Czech formatting 1 234 567,89
        case NumberFormat.system:
            return undefined;
        default:
            return localeOptions.language;
    }
};
/**
 * Formats a number based on the user's preference with thousands separator(s) and decimal character for better legibility.
 *
 * @param num The number to format
 * @param locale The user-selected language and number format, from `hass.locale`
 * @param options Intl.NumberFormatOptions to use
 */
const formatNumber = (num, localeOptions, options) => {
    const locale = localeOptions ? numberFormatToLocale(localeOptions) : undefined;
    // Polyfill for Number.isNaN, which is more reliable than the global isNaN()
    Number.isNaN =
        Number.isNaN ||
            function isNaN(input) {
                return typeof input === "number" && isNaN(input);
            };
    if ((localeOptions === null || localeOptions === void 0 ? void 0 : localeOptions.number_format) !== NumberFormat.none && !Number.isNaN(Number(num)) && Intl) {
        try {
            return new Intl.NumberFormat(locale, getDefaultFormatOptions(num, options)).format(Number(num));
        }
        catch (err) {
            // Don't fail when using "TEST" language
            // eslint-disable-next-line no-console
            console.error(err);
            return new Intl.NumberFormat(undefined, getDefaultFormatOptions(num, options)).format(Number(num));
        }
    }
    if (typeof num === "string") {
        return num;
    }
    return `${round(num, options === null || options === void 0 ? void 0 : options.maximumFractionDigits).toString()}${(options === null || options === void 0 ? void 0 : options.style) === "currency" ? ` ${options.currency}` : ""}`;
};
/**
 * Generates default options for Intl.NumberFormat
 * @param num The number to be formatted
 * @param options The Intl.NumberFormatOptions that should be included in the returned options
 */
const getDefaultFormatOptions = (num, options) => {
    const defaultOptions = Object.assign({ maximumFractionDigits: 2 }, options);
    if (typeof num !== "string") {
        return defaultOptions;
    }
    // Keep decimal trailing zeros if they are present in a string numeric value
    if (!options || (!options.minimumFractionDigits && !options.maximumFractionDigits)) {
        const digits = num.indexOf(".") > -1 ? num.split(".")[1].length : 0;
        defaultOptions.minimumFractionDigits = digits;
        defaultOptions.maximumFractionDigits = digits;
    }
    return defaultOptions;
};

const computeStateDomain = (stateObj) => computeDomain(stateObj.entity_id);

const computeStateDisplay = (localize, stateObj, locale, entities, state) => {
    var _a;
    const compareState = state !== undefined ? state : stateObj.state;
    if (compareState === UNKNOWN || compareState === UNAVAILABLE) {
        return localize(`state.default.${compareState}`);
    }
    // Entities with a `unit_of_measurement` or `state_class` are numeric values and should use `formatNumber`
    if (isNumericState(stateObj)) {
        if (stateObj.attributes.device_class === "monetary") {
            try {
                return formatNumber(compareState, locale, {
                    style: "currency",
                    currency: stateObj.attributes.unit_of_measurement,
                });
            }
            catch (_err) {
                // fallback to default
            }
        }
        return `${formatNumber(compareState, locale)}${stateObj.attributes.unit_of_measurement
            ? " " + stateObj.attributes.unit_of_measurement
            : ""}`;
    }
    const domain = computeStateDomain(stateObj);
    if (domain === "input_datetime") {
        if (state !== undefined) {
            // If trying to display an explicit state, need to parse the explicit state to `Date` then format.
            // Attributes aren't available, we have to use `state`.
            try {
                const components = state.split(" ");
                if (components.length === 2) {
                    // Date and time.
                    return formatDateTime(new Date(components.join("T")), locale);
                }
                if (components.length === 1) {
                    if (state.includes("-")) {
                        // Date only.
                        return formatDate(new Date(`${state}T00:00`), locale);
                    }
                    if (state.includes(":")) {
                        // Time only.
                        const now = new Date();
                        return formatTime(new Date(`${now.toISOString().split("T")[0]}T${state}`), locale);
                    }
                }
                return state;
            }
            catch (_e) {
                // Formatting methods may throw error if date parsing doesn't go well,
                // just return the state string in that case.
                return state;
            }
        }
        else {
            // If not trying to display an explicit state, create `Date` object from `stateObj`'s attributes then format.
            let date;
            if (stateObj.attributes.has_date && stateObj.attributes.has_time) {
                date = new Date(stateObj.attributes.year, stateObj.attributes.month - 1, stateObj.attributes.day, stateObj.attributes.hour, stateObj.attributes.minute);
                return formatDateTime(date, locale);
            }
            if (stateObj.attributes.has_date) {
                date = new Date(stateObj.attributes.year, stateObj.attributes.month - 1, stateObj.attributes.day);
                return formatDate(date, locale);
            }
            if (stateObj.attributes.has_time) {
                date = new Date();
                date.setHours(stateObj.attributes.hour, stateObj.attributes.minute);
                return formatTime(date, locale);
            }
            return stateObj.state;
        }
    }
    if (domain === "humidifier") {
        if (compareState === "on" && stateObj.attributes.humidity) {
            return `${stateObj.attributes.humidity} %`;
        }
    }
    // `counter` `number` and `input_number` domains do not have a unit of measurement but should still use `formatNumber`
    if (domain === "counter" || domain === "number" || domain === "input_number") {
        return formatNumber(compareState, locale);
    }
    // state of button is a timestamp
    if (domain === "button" ||
        domain === "input_button" ||
        domain === "scene" ||
        (domain === "sensor" && stateObj.attributes.device_class === "timestamp")) {
        try {
            return formatDateTime(new Date(compareState), locale);
        }
        catch (_err) {
            return compareState;
        }
    }
    if (domain === "update") {
        // When updating, and entity does not support % show "Installing"
        // When updating, and entity does support % show "Installing (xx%)"
        // When update available, show the version
        // When the latest version is skipped, show the latest version
        // When update is not available, show "Up-to-date"
        // When update is not available and there is no latest_version show "Unavailable"
        return compareState === "on"
            ? updateIsInstalling(stateObj)
                ? supportsFeature(stateObj, UPDATE_SUPPORT_PROGRESS)
                    ? localize("ui.card.update.installing_with_progress", {
                        progress: stateObj.attributes.in_progress,
                    })
                    : localize("ui.card.update.installing")
                : stateObj.attributes.latest_version
            : stateObj.attributes.skipped_version === stateObj.attributes.latest_version
                ? (_a = stateObj.attributes.latest_version) !== null && _a !== void 0 ? _a : localize("state.default.unavailable")
                : localize("ui.card.update.up_to_date");
    }
    const entity = entities[stateObj.entity_id];
    return (((entity === null || entity === void 0 ? void 0 : entity.translation_key) &&
        localize(`component.${entity.platform}.entity.${domain}.${entity.translation_key}.state.${compareState}`)) ||
        // Return device class translation
        (stateObj.attributes.device_class &&
            localize(`component.${domain}.state.${stateObj.attributes.device_class}.${compareState}`)) ||
        // Return default translation
        localize(`component.${domain}.state._.${compareState}`) ||
        // We don't know! Return the raw state.
        compareState);
};

const navigate = (path, options) => {
    var _a;
    const replace = (options === null || options === void 0 ? void 0 : options.replace) || false;
    if (replace) {
        mainWindow.history.replaceState(((_a = mainWindow.history.state) === null || _a === void 0 ? void 0 : _a.root) ? { root: true } : null, "", path);
    }
    else {
        mainWindow.history.pushState(null, "", path);
    }
    fireEvent(mainWindow, "location-changed", {
        replace,
    });
};

// Variant that only applies the clamping to a border if the border is defined
const conditionalClamp = (value, min, max) => {
    let result;
    result = min ? Math.max(value, min) : value;
    result = max ? Math.min(result, max) : result;
    return result;
};

/**
 * A `StructFailure` represents a single specific failure in validation.
 */

/**
 * `StructError` objects are thrown (or returned) when validation fails.
 *
 * Validation logic is design to exit early for maximum performance. The error
 * represents the first error encountered during validation. For more detail,
 * the `error.failures` property is a generator function that can be run to
 * continue validation and receive all the failures in the data.
 */
class StructError extends TypeError {
  constructor(failure, failures) {
    let cached;
    const {
      message,
      ...rest
    } = failure;
    const {
      path
    } = failure;
    const msg = path.length === 0 ? message : "At path: " + path.join('.') + " -- " + message;
    super(msg);
    this.value = void 0;
    this.key = void 0;
    this.type = void 0;
    this.refinement = void 0;
    this.path = void 0;
    this.branch = void 0;
    this.failures = void 0;
    Object.assign(this, rest);
    this.name = this.constructor.name;

    this.failures = () => {
      var _cached;

      return (_cached = cached) != null ? _cached : cached = [failure, ...failures()];
    };
  }

}

/**
 * Check if a value is an iterator.
 */
function isIterable(x) {
  return isObject$1(x) && typeof x[Symbol.iterator] === 'function';
}
/**
 * Check if a value is a plain object.
 */


function isObject$1(x) {
  return typeof x === 'object' && x != null;
}
/**
 * Return a value as a printable string.
 */

function print(value) {
  return typeof value === 'string' ? JSON.stringify(value) : "" + value;
}
/**
 * Shifts (removes and returns) the first value from the `input` iterator.
 * Like `Array.prototype.shift()` but for an `Iterator`.
 */

function shiftIterator(input) {
  const {
    done,
    value
  } = input.next();
  return done ? undefined : value;
}
/**
 * Convert a single validation result to a failure.
 */

function toFailure(result, context, struct, value) {
  if (result === true) {
    return;
  } else if (result === false) {
    result = {};
  } else if (typeof result === 'string') {
    result = {
      message: result
    };
  }

  const {
    path,
    branch
  } = context;
  const {
    type
  } = struct;
  const {
    refinement,
    message = "Expected a value of type `" + type + "`" + (refinement ? " with refinement `" + refinement + "`" : '') + ", but received: `" + print(value) + "`"
  } = result;
  return {
    value,
    type,
    refinement,
    key: path[path.length - 1],
    path,
    branch,
    ...result,
    message
  };
}
/**
 * Convert a validation result to an iterable of failures.
 */

function* toFailures(result, context, struct, value) {
  if (!isIterable(result)) {
    result = [result];
  }

  for (const r of result) {
    const failure = toFailure(r, context, struct, value);

    if (failure) {
      yield failure;
    }
  }
}
/**
 * Check a value against a struct, traversing deeply into nested values, and
 * returning an iterator of failures or success.
 */

function* run(value, struct, options = {}) {
  const {
    path = [],
    branch = [value],
    coerce = false,
    mask = false
  } = options;
  const ctx = {
    path,
    branch
  };

  if (coerce) {
    value = struct.coercer(value, ctx);

    if (mask && struct.type !== 'type' && isObject$1(struct.schema) && isObject$1(value) && !Array.isArray(value)) {
      for (const key in value) {
        if (struct.schema[key] === undefined) {
          delete value[key];
        }
      }
    }
  }

  let valid = true;

  for (const failure of struct.validator(value, ctx)) {
    valid = false;
    yield [failure, undefined];
  }

  for (let [k, v, s] of struct.entries(value, ctx)) {
    const ts = run(v, s, {
      path: k === undefined ? path : [...path, k],
      branch: k === undefined ? branch : [...branch, v],
      coerce,
      mask
    });

    for (const t of ts) {
      if (t[0]) {
        valid = false;
        yield [t[0], undefined];
      } else if (coerce) {
        v = t[1];

        if (k === undefined) {
          value = v;
        } else if (value instanceof Map) {
          value.set(k, v);
        } else if (value instanceof Set) {
          value.add(v);
        } else if (isObject$1(value)) {
          value[k] = v;
        }
      }
    }
  }

  if (valid) {
    for (const failure of struct.refiner(value, ctx)) {
      valid = false;
      yield [failure, undefined];
    }
  }

  if (valid) {
    yield [undefined, value];
  }
}

/**
 * `Struct` objects encapsulate the validation logic for a specific type of
 * values. Once constructed, you use the `assert`, `is` or `validate` helpers to
 * validate unknown input data against the struct.
 */

class Struct {
  constructor(props) {
    this.TYPE = void 0;
    this.type = void 0;
    this.schema = void 0;
    this.coercer = void 0;
    this.validator = void 0;
    this.refiner = void 0;
    this.entries = void 0;
    const {
      type,
      schema,
      validator,
      refiner,
      coercer = value => value,
      entries = function* () {}
    } = props;
    this.type = type;
    this.schema = schema;
    this.entries = entries;
    this.coercer = coercer;

    if (validator) {
      this.validator = (value, context) => {
        const result = validator(value, context);
        return toFailures(result, context, this, value);
      };
    } else {
      this.validator = () => [];
    }

    if (refiner) {
      this.refiner = (value, context) => {
        const result = refiner(value, context);
        return toFailures(result, context, this, value);
      };
    } else {
      this.refiner = () => [];
    }
  }
  /**
   * Assert that a value passes the struct's validation, throwing if it doesn't.
   */


  assert(value) {
    return assert(value, this);
  }
  /**
   * Create a value with the struct's coercion logic, then validate it.
   */


  create(value) {
    return create(value, this);
  }
  /**
   * Check if a value passes the struct's validation.
   */


  is(value) {
    return is(value, this);
  }
  /**
   * Mask a value, coercing and validating it, but returning only the subset of
   * properties defined by the struct's schema.
   */


  mask(value) {
    return mask(value, this);
  }
  /**
   * Validate a value with the struct's validation logic, returning a tuple
   * representing the result.
   *
   * You may optionally pass `true` for the `withCoercion` argument to coerce
   * the value before attempting to validate it. If you do, the result will
   * contain the coerced result when successful.
   */


  validate(value, options = {}) {
    return validate(value, this, options);
  }

}
/**
 * Assert that a value passes a struct, throwing if it doesn't.
 */

function assert(value, struct) {
  const result = validate(value, struct);

  if (result[0]) {
    throw result[0];
  }
}
/**
 * Create a value with the coercion logic of struct and validate it.
 */

function create(value, struct) {
  const result = validate(value, struct, {
    coerce: true
  });

  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
/**
 * Mask a value, returning only the subset of properties defined by a struct.
 */

function mask(value, struct) {
  const result = validate(value, struct, {
    coerce: true,
    mask: true
  });

  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
/**
 * Check if a value passes a struct.
 */

function is(value, struct) {
  const result = validate(value, struct);
  return !result[0];
}
/**
 * Validate a value against a struct, returning an error if invalid, or the
 * value (with potential coercion) if valid.
 */

function validate(value, struct, options = {}) {
  const tuples = run(value, struct, options);
  const tuple = shiftIterator(tuples);

  if (tuple[0]) {
    const error = new StructError(tuple[0], function* () {
      for (const t of tuples) {
        if (t[0]) {
          yield t[0];
        }
      }
    });
    return [error, undefined];
  } else {
    const v = tuple[1];
    return [undefined, v];
  }
}

function assign(...Structs) {
  const isType = Structs[0].type === 'type';
  const schemas = Structs.map(s => s.schema);
  const schema = Object.assign({}, ...schemas);
  return isType ? type$1(schema) : object(schema);
}
/**
 * Define a new struct type with a custom validation function.
 */

function define(name, validator) {
  return new Struct({
    type: name,
    schema: null,
    validator
  });
}
/**
 * Create a struct with dynamic validation logic.
 *
 * The callback will receive the value currently being validated, and must
 * return a struct object to validate it with. This can be useful to model
 * validation logic that changes based on its input.
 */

function dynamic(fn) {
  return new Struct({
    type: 'dynamic',
    schema: null,

    *entries(value, ctx) {
      const struct = fn(value, ctx);
      yield* struct.entries(value, ctx);
    },

    validator(value, ctx) {
      const struct = fn(value, ctx);
      return struct.validator(value, ctx);
    },

    coercer(value, ctx) {
      const struct = fn(value, ctx);
      return struct.coercer(value, ctx);
    },

    refiner(value, ctx) {
      const struct = fn(value, ctx);
      return struct.refiner(value, ctx);
    }

  });
}

/**
 * Ensure that any value passes validation.
 */

function any() {
  return define('any', () => true);
}
function array(Element) {
  return new Struct({
    type: 'array',
    schema: Element,

    *entries(value) {
      if (Element && Array.isArray(value)) {
        for (const [i, v] of value.entries()) {
          yield [i, v, Element];
        }
      }
    },

    coercer(value) {
      return Array.isArray(value) ? value.slice() : value;
    },

    validator(value) {
      return Array.isArray(value) || "Expected an array value, but received: " + print(value);
    }

  });
}
/**
 * Ensure that a value is a boolean.
 */

function boolean() {
  return define('boolean', value => {
    return typeof value === 'boolean';
  });
}
function enums(values) {
  const schema = {};
  const description = values.map(v => print(v)).join();

  for (const key of values) {
    schema[key] = key;
  }

  return new Struct({
    type: 'enums',
    schema,

    validator(value) {
      return values.includes(value) || "Expected one of `" + description + "`, but received: " + print(value);
    }

  });
}
function literal(constant) {
  const description = print(constant);
  const t = typeof constant;
  return new Struct({
    type: 'literal',
    schema: t === 'string' || t === 'number' || t === 'boolean' ? constant : null,

    validator(value) {
      return value === constant || "Expected the literal `" + description + "`, but received: " + print(value);
    }

  });
}
/**
 * Ensure that no value ever passes validation.
 */

function never() {
  return define('never', () => false);
}
/**
 * Ensure that a value is a number.
 */

function number() {
  return define('number', value => {
    return typeof value === 'number' && !isNaN(value) || "Expected a number, but received: " + print(value);
  });
}
function object(schema) {
  const knowns = schema ? Object.keys(schema) : [];
  const Never = never();
  return new Struct({
    type: 'object',
    schema: schema ? schema : null,

    *entries(value) {
      if (schema && isObject$1(value)) {
        const unknowns = new Set(Object.keys(value));

        for (const key of knowns) {
          unknowns.delete(key);
          yield [key, value[key], schema[key]];
        }

        for (const key of unknowns) {
          yield [key, value[key], Never];
        }
      }
    },

    validator(value) {
      return isObject$1(value) || "Expected an object, but received: " + print(value);
    },

    coercer(value) {
      return isObject$1(value) ? { ...value
      } : value;
    }

  });
}
/**
 * Augment a struct to allow `undefined` values.
 */

function optional(struct) {
  return new Struct({ ...struct,
    validator: (value, ctx) => value === undefined || struct.validator(value, ctx),
    refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx)
  });
}
/**
 * Ensure that a value is a string.
 */

function string() {
  return define('string', value => {
    return typeof value === 'string' || "Expected a string, but received: " + print(value);
  });
}
/**
 * Ensure that a value has a set of known properties of specific types.
 *
 * Note: Unrecognized properties are allowed and untouched. This is similar to
 * how TypeScript's structural typing works.
 */

function type$1(schema) {
  const keys = Object.keys(schema);
  return new Struct({
    type: 'type',
    schema,

    *entries(value) {
      if (isObject$1(value)) {
        for (const k of keys) {
          yield [k, value[k], schema[k]];
        }
      }
    },

    validator(value) {
      return isObject$1(value) || "Expected an object, but received: " + print(value);
    }

  });
}
/**
 * Ensure that a value matches one of a set of types.
 */

function union(Structs) {
  const description = Structs.map(s => s.type).join(' | ');
  return new Struct({
    type: 'union',
    schema: null,

    coercer(value, ctx) {
      const firstMatch = Structs.find(s => {
        const [e] = s.validate(value, {
          coerce: true
        });
        return !e;
      }) || unknown();
      return firstMatch.coercer(value, ctx);
    },

    validator(value, ctx) {
      const failures = [];

      for (const S of Structs) {
        const [...tuples] = run(value, S, ctx);
        const [first] = tuples;

        if (!first[0]) {
          return [];
        } else {
          for (const [failure] of tuples) {
            if (failure) {
              failures.push(failure);
            }
          }
        }
      }

      return ["Expected the value to satisfy a union of `" + description + "`, but received: " + print(value), ...failures];
    }

  });
}
/**
 * Ensure that any value passes validation, without widening its type to `any`.
 */

function unknown() {
  return define('unknown', () => true);
}

const handleStructError = (hass, err) => {
    if (!(err instanceof StructError)) {
        return { warnings: [err.message], errors: undefined };
    }
    const errors = [];
    const warnings = [];
    for (const failure of err.failures()) {
        if (failure.value === undefined) {
            errors.push(hass.localize("ui.errors.config.key_missing", "key", failure.path.join(".")));
        }
        else if (failure.type === "never") {
            warnings.push(hass.localize("ui.errors.config.key_not_expected", "key", failure.path.join(".")));
        }
        else if (failure.type === "union") {
            continue;
        }
        else if (failure.type === "enums") {
            warnings.push(hass.localize("ui.errors.config.key_wrong_type", "key", failure.path.join("."), "type_correct", failure.message.replace("Expected ", "").split(", ")[0], "type_wrong", JSON.stringify(failure.value)));
        }
        else {
            warnings.push(hass.localize("ui.errors.config.key_wrong_type", "key", failure.path.join("."), "type_correct", failure.refinement || failure.type, "type_wrong", JSON.stringify(failure.value)));
        }
    }
    return { warnings, errors };
};

function computeRTL(hass) {
    const lang = hass.language || "en";
    if (hass.translationMetadata.translations[lang]) {
        return hass.translationMetadata.translations[lang].isRTL || false;
    }
    return false;
}

// From: https://davidwalsh.name/javascript-debounce-function
// Returns a function, that, as long as it continues to be invoked, will not
// be triggered. The function will be called after it stops being called for
// N milliseconds. If `immediate` is passed, trigger the function on the
// leading edge, instead of the trailing.
const debounce = (func, wait, immediate = false) => {
    let timeout;
    const debouncedFunc = (...args) => {
        const later = () => {
            timeout = undefined;
            if (!immediate) {
                func(...args);
            }
        };
        const callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = window.setTimeout(later, wait);
        if (callNow) {
            func(...args);
        }
    };
    debouncedFunc.cancel = () => {
        clearTimeout(timeout);
    };
    return debouncedFunc;
};

// From https://github.com/epoberezkin/fast-deep-equal
// MIT License - Copyright (c) 2017 Evgeny Poberezkin
const deepEqual = (a, b) => {
    if (a === b) {
        return true;
    }
    if (a && b && typeof a === "object" && typeof b === "object") {
        if (a.constructor !== b.constructor) {
            return false;
        }
        let i;
        let length;
        if (Array.isArray(a)) {
            length = a.length;
            if (length !== b.length) {
                return false;
            }
            for (i = length; i-- !== 0;) {
                if (!deepEqual(a[i], b[i])) {
                    return false;
                }
            }
            return true;
        }
        if (a instanceof Map && b instanceof Map) {
            if (a.size !== b.size) {
                return false;
            }
            for (i of a.entries()) {
                if (!b.has(i[0])) {
                    return false;
                }
            }
            for (i of a.entries()) {
                if (!deepEqual(i[1], b.get(i[0]))) {
                    return false;
                }
            }
            return true;
        }
        if (a instanceof Set && b instanceof Set) {
            if (a.size !== b.size) {
                return false;
            }
            for (i of a.entries()) {
                if (!b.has(i[0])) {
                    return false;
                }
            }
            return true;
        }
        if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
            // @ts-ignore
            length = a.length;
            // @ts-ignore
            if (length !== b.length) {
                return false;
            }
            for (i = length; i-- !== 0;) {
                if (a[i] !== b[i]) {
                    return false;
                }
            }
            return true;
        }
        if (a.constructor === RegExp) {
            return a.source === b.source && a.flags === b.flags;
        }
        if (a.valueOf !== Object.prototype.valueOf) {
            return a.valueOf() === b.valueOf();
        }
        if (a.toString !== Object.prototype.toString) {
            return a.toString() === b.toString();
        }
        const keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) {
            return false;
        }
        for (i = length; i-- !== 0;) {
            if (!Object.prototype.hasOwnProperty.call(b, keys[i])) {
                return false;
            }
        }
        for (i = length; i-- !== 0;) {
            const key = keys[i];
            if (!deepEqual(a[key], b[key])) {
                return false;
            }
        }
        return true;
    }
    // true if both NaN, false otherwise
    // eslint-disable-next-line no-self-compare
    return a !== a && b !== b;
};

const afterNextRender = (cb) => {
    requestAnimationFrame(() => setTimeout(cb, 0));
};
const nextRender = () => new Promise((resolve) => {
    afterNextRender(resolve);
});

const hvacModeOrdering = {
    auto: 1,
    heat_cool: 2,
    heat: 3,
    cool: 4,
    dry: 5,
    fan_only: 6,
    off: 7,
};
const compareClimateHvacModes = (mode1, mode2) => hvacModeOrdering[mode1] - hvacModeOrdering[mode2];

const COVER_SUPPORT_OPEN = 1;
const COVER_SUPPORT_CLOSE = 2;
const COVER_SUPPORT_STOP = 8;
function isFullyOpen(stateObj) {
    if (stateObj.attributes.current_position !== undefined) {
        return stateObj.attributes.current_position === 100;
    }
    return stateObj.state === "open";
}
function isFullyClosed(stateObj) {
    if (stateObj.attributes.current_position !== undefined) {
        return stateObj.attributes.current_position === 0;
    }
    return stateObj.state === "closed";
}
function isOpening(stateObj) {
    return stateObj.state === "opening";
}
function isClosing(stateObj) {
    return stateObj.state === "closing";
}

/**
 * Broadcast haptic feedback requests
 */
const forwardHaptic = (hapticType) => {
    fireEvent(window, "haptic", hapticType);
};

const domainToName = (localize, domain, manifest) => localize(`component.${domain}.title`) || (manifest === null || manifest === void 0 ? void 0 : manifest.name) || domain;

const modesSupportingColor = [
    "hs" /* HS */,
    "xy" /* XY */,
    "rgb" /* RGB */,
    "rgbw" /* RGBW */,
    "rgbww" /* RGBWW */,
];
const modesSupportingDimming = [
    ...modesSupportingColor,
    "color_temp" /* COLOR_TEMP */,
    "brightness" /* BRIGHTNESS */,
];
const lightSupportsColor = (entity) => { var _a; return (_a = entity.attributes.supported_color_modes) === null || _a === void 0 ? void 0 : _a.some((mode) => modesSupportingColor.includes(mode)); };
const lightSupportsDimming = (entity) => { var _a; return (_a = entity.attributes.supported_color_modes) === null || _a === void 0 ? void 0 : _a.some((mode) => modesSupportingDimming.includes(mode)); };

const LOCK_STATE_LOCKED = "locked";
const LOCK_STATE_LOCKING = "locking";
const LOCK_STATE_UNLOCKED = "unlocked";
const LOCK_STATE_UNLOCKING = "unlocking";
const LOCK_SUPPORT_OPEN = 1;

const MEDIA_PLAYER_SUPPORT_PAUSE = 1;
const MEDIA_PLAYER_SUPPORT_VOLUME_SET = 4;
const MEDIA_PLAYER_SUPPORT_VOLUME_MUTE = 8;
const MEDIA_PLAYER_SUPPORT_PREVIOUS_TRACK = 16;
const MEDIA_PLAYER_SUPPORT_NEXT_TRACK = 32;
const MEDIA_PLAYER_SUPPORT_TURN_ON = 128;
const MEDIA_PLAYER_SUPPORT_TURN_OFF = 256;
const MEDIA_PLAYER_SUPPORT_VOLUME_BUTTONS = 1024;
const MEDIA_PLAYER_SUPPORT_STOP = 4096;
const MEDIA_PLAYER_SUPPORT_PLAY = 16384;
const MEDIA_PLAYER_SUPPORT_REPEAT_SET = 262144;
const MEDIA_PLAYER_SUPPORT_SHUFFLE_SET = 32768;
const computeMediaDescription = (stateObj) => {
    let secondaryTitle;
    switch (stateObj.attributes.media_content_type) {
        case "music":
        case "image":
            secondaryTitle = stateObj.attributes.media_artist;
            break;
        case "playlist":
            secondaryTitle = stateObj.attributes.media_playlist;
            break;
        case "tvshow":
            secondaryTitle = stateObj.attributes.media_series_title;
            if (stateObj.attributes.media_season) {
                secondaryTitle += " S" + stateObj.attributes.media_season;
                if (stateObj.attributes.media_episode) {
                    secondaryTitle += "E" + stateObj.attributes.media_episode;
                }
            }
            break;
        default:
            secondaryTitle = stateObj.attributes.app_name || "";
    }
    return secondaryTitle;
};

const STATE_ON = "on";
const STATE_OFF = "off";
const STATE_CLEANING = "cleaning";
const STATE_DOCKED = "docked";
const STATE_IDLE = "idle";
const STATE_RETURNING = "returning";
const VACUUM_SUPPORT_TURN_ON = 1;
const VACUUM_SUPPORT_TURN_OFF = 2;
const VACUUM_SUPPORT_PAUSE = 4;
const VACUUM_SUPPORT_STOP = 8;
const VACUUM_SUPPORT_RETURN_HOME = 16;
const VACUUM_SUPPORT_LOCATE = 512;
const VACUUM_SUPPORT_CLEAN_SPOT = 1024;
const VACUUM_SUPPORT_START = 8192;

const subscribeRenderTemplate = (conn, onChange, params) => conn.subscribeMessage((msg) => onChange(msg), Object.assign({ type: "render_template" }, params));

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t={ATTRIBUTE:1,CHILD:2,PROPERTY:3,BOOLEAN_ATTRIBUTE:4,EVENT:5,ELEMENT:6},e$1=t=>(...e)=>({_$litDirective$:t,values:e});class i$3{constructor(t){}get _$AU(){return this._$AM._$AU}_$AT(t,e,i){this._$Ct=t,this._$AM=e,this._$Ci=i;}_$AS(t,e){return this.update(t,e)}update(t,e){return this.render(...e)}}

const getActionHandler = () => {
    const body = document.body;
    if (body.querySelector("action-handler")) {
        return body.querySelector("action-handler");
    }
    const actionhandler = document.createElement("action-handler");
    body.appendChild(actionhandler);
    return actionhandler;
};
const actionHandlerBind = (element, options) => {
    const actionhandler = getActionHandler();
    if (!actionhandler) {
        return;
    }
    actionhandler.bind(element, options);
};
const actionHandler = e$1(class extends i$3 {
    update(part, [options]) {
        actionHandlerBind(part.element, options);
        return b;
    }
    render(_options) { }
});

const turnOnOffEntity = (hass, entityId, turnOn = true) => {
    const stateDomain = computeDomain(entityId);
    const serviceDomain = stateDomain === "group" ? "homeassistant" : stateDomain;
    let service;
    switch (stateDomain) {
        case "lock":
            service = turnOn ? "unlock" : "lock";
            break;
        case "cover":
            service = turnOn ? "open_cover" : "close_cover";
            break;
        case "button":
        case "input_button":
            service = "press";
            break;
        case "scene":
            service = "turn_on";
            break;
        default:
            service = turnOn ? "turn_on" : "turn_off";
    }
    return hass.callService(serviceDomain, service, { entity_id: entityId });
};

const toggleEntity = (hass, entityId) => {
    const turnOn = STATES_OFF.includes(hass.states[entityId].state);
    return turnOnOffEntity(hass, entityId, turnOn);
};

const handleAction = async (node, hass, config, action) => {
    var _a;
    let actionConfig;
    if (action === "double_tap" && config.double_tap_action) {
        actionConfig = config.double_tap_action;
    }
    else if (action === "hold" && config.hold_action) {
        actionConfig = config.hold_action;
    }
    else if (action === "tap" && config.tap_action) {
        actionConfig = config.tap_action;
    }
    if (!actionConfig) {
        actionConfig = {
            action: "more-info",
        };
    }
    if (actionConfig.confirmation &&
        (!actionConfig.confirmation.exemptions ||
            !actionConfig.confirmation.exemptions.some((e) => e.user === hass.user.id))) {
        forwardHaptic("warning");
        let serviceName;
        if (actionConfig.action === "call-service") {
            const [domain, service] = actionConfig.service.split(".", 2);
            const serviceDomains = hass.services;
            if (domain in serviceDomains && service in serviceDomains[domain]) {
                const localize = await hass.loadBackendTranslation("title");
                serviceName = `${domainToName(localize, domain)}: ${serviceDomains[domain][service].name || service}`;
            }
        }
        if (!confirm(actionConfig.confirmation.text ||
            hass.localize("ui.panel.lovelace.cards.actions.action_confirmation", "action", serviceName ||
                hass.localize("ui.panel.lovelace.editor.action-editor.actions." +
                    actionConfig.action) ||
                actionConfig.action))) {
            return;
        }
    }
    switch (actionConfig.action) {
        case "more-info": {
            if (config.entity || config.camera_image) {
                fireEvent(node, "hass-more-info", {
                    entityId: config.entity ? config.entity : config.camera_image,
                });
            }
            else {
                showToast(node, {
                    message: hass.localize("ui.panel.lovelace.cards.actions.no_entity_more_info"),
                });
                forwardHaptic("failure");
            }
            break;
        }
        case "navigate":
            if (actionConfig.navigation_path) {
                navigate(actionConfig.navigation_path);
            }
            else {
                showToast(node, {
                    message: hass.localize("ui.panel.lovelace.cards.actions.no_navigation_path"),
                });
                forwardHaptic("failure");
            }
            break;
        case "url": {
            if (actionConfig.url_path) {
                window.open(actionConfig.url_path);
            }
            else {
                showToast(node, {
                    message: hass.localize("ui.panel.lovelace.cards.actions.no_url"),
                });
                forwardHaptic("failure");
            }
            break;
        }
        case "toggle": {
            if (config.entity) {
                toggleEntity(hass, config.entity);
                forwardHaptic("light");
            }
            else {
                showToast(node, {
                    message: hass.localize("ui.panel.lovelace.cards.actions.no_entity_toggle"),
                });
                forwardHaptic("failure");
            }
            break;
        }
        case "call-service": {
            if (!actionConfig.service) {
                showToast(node, {
                    message: hass.localize("ui.panel.lovelace.cards.actions.no_service"),
                });
                forwardHaptic("failure");
                return;
            }
            const [domain, service] = actionConfig.service.split(".", 2);
            hass.callService(domain, service, (_a = actionConfig.data) !== null && _a !== void 0 ? _a : actionConfig.service_data, actionConfig.target);
            forwardHaptic("light");
            break;
        }
        case "fire-dom-event": {
            fireEvent(node, "ll-custom", actionConfig);
        }
    }
};
const showToast = (el, params) => fireEvent(el, "hass-notification", params);

function hasAction(config) {
    return config !== undefined && config.action !== "none";
}

function checkConditionsMet(conditions, hass) {
    return conditions.every((c) => {
        const state = hass.states[c.entity] ? hass.states[c.entity].state : UNAVAILABLE;
        return c.state ? state === c.state : state !== c.state_not;
    });
}
function validateConditionalConfig(conditions) {
    return conditions.every((c) => (c.entity && (c.state || c.state_not)));
}

const actionConfigStructUser = object({
    user: string(),
});
const actionConfigStructConfirmation = union([
    boolean(),
    object({
        text: optional(string()),
        excemptions: optional(array(actionConfigStructUser)),
    }),
]);
const actionConfigStructUrl = object({
    action: literal("url"),
    url_path: string(),
    confirmation: optional(actionConfigStructConfirmation),
});
const actionConfigStructService = object({
    action: literal("call-service"),
    service: string(),
    service_data: optional(object()),
    data: optional(object()),
    target: optional(object({
        entity_id: optional(union([string(), array(string())])),
        device_id: optional(union([string(), array(string())])),
        area_id: optional(union([string(), array(string())])),
    })),
    confirmation: optional(actionConfigStructConfirmation),
});
const actionConfigStructNavigate = object({
    action: literal("navigate"),
    navigation_path: string(),
    confirmation: optional(actionConfigStructConfirmation),
});
const actionConfigStructCustom = type$1({
    action: literal("fire-dom-event"),
});
const actionConfigStructType = object({
    action: enums(["none", "toggle", "more-info", "call-service", "url", "navigate"]),
    confirmation: optional(actionConfigStructConfirmation),
});
const actionConfigStruct = dynamic((value) => {
    if (value && typeof value === "object" && "action" in value) {
        switch (value.action) {
            case "call-service": {
                return actionConfigStructService;
            }
            case "fire-dom-event": {
                return actionConfigStructCustom;
            }
            case "navigate": {
                return actionConfigStructNavigate;
            }
            case "url": {
                return actionConfigStructUrl;
            }
        }
    }
    return actionConfigStructType;
});

const sortableStyles = r$3 `
    #sortable a:nth-of-type(2n) paper-icon-item {
        animation-name: keyframes1;
        animation-iteration-count: infinite;
        transform-origin: 50% 10%;
        animation-delay: -0.75s;
        animation-duration: 0.25s;
    }

    #sortable a:nth-of-type(2n-1) paper-icon-item {
        animation-name: keyframes2;
        animation-iteration-count: infinite;
        animation-direction: alternate;
        transform-origin: 30% 5%;
        animation-delay: -0.5s;
        animation-duration: 0.33s;
    }

    #sortable a {
        height: 48px;
        display: flex;
    }

    #sortable {
        outline: none;
        display: block !important;
    }

    .hidden-panel {
        display: flex !important;
    }

    .sortable-fallback {
        display: none;
    }

    .sortable-ghost {
        opacity: 0.4;
    }

    .sortable-fallback {
        opacity: 0;
    }

    @keyframes keyframes1 {
        0% {
            transform: rotate(-1deg);
            animation-timing-function: ease-in;
        }

        50% {
            transform: rotate(1.5deg);
            animation-timing-function: ease-out;
        }
    }

    @keyframes keyframes2 {
        0% {
            transform: rotate(1deg);
            animation-timing-function: ease-in;
        }

        50% {
            transform: rotate(-1.5deg);
            animation-timing-function: ease-out;
        }
    }

    .show-panel,
    .hide-panel {
        display: none;
        position: absolute;
        top: 0;
        right: 4px;
        --mdc-icon-button-size: 40px;
    }

    :host([rtl]) .show-panel {
        right: initial;
        left: 4px;
    }

    .hide-panel {
        top: 4px;
        right: 8px;
    }

    :host([rtl]) .hide-panel {
        right: initial;
        left: 8px;
    }

    :host([expanded]) .hide-panel {
        display: block;
    }

    :host([expanded]) .show-panel {
        display: inline-flex;
    }

    paper-icon-item.hidden-panel,
    paper-icon-item.hidden-panel span,
    paper-icon-item.hidden-panel ha-icon[slot="item-icon"] {
        color: var(--secondary-text-color);
        cursor: pointer;
    }
`;

var editor$p = {
	form: {
		color_picker: {
			values: {
				"default": "اللون الإفتراضي"
			}
		},
		info_picker: {
			values: {
				"default": "المعلومات الافتراضية",
				name: "الإسم",
				state: "الحالة",
				"last-changed": "آخر تغيير",
				"last-updated": "آخر تحديث",
				none: "لا شئ"
			}
		},
		icon_type_picker: {
			values: {
				"default": "النوع افتراضي",
				icon: "أيقونة",
				"entity-picture": "صورة الكيان",
				none: "لا شئ"
			}
		},
		layout_picker: {
			values: {
				"default": "تخطيط افتراضي",
				vertical: "تخطيط رأسي",
				horizontal: "تخطيط أفقي"
			}
		},
		alignment_picker: {
			values: {
				"default": "المحاذاة الافتراضية",
				start: "بداية",
				end: "نهاية",
				center: "توسيط",
				justify: "مساواة"
			}
		}
	},
	card: {
		generic: {
			icon_color: "لون الأيقونة",
			layout: "التخطيط",
			fill_container: "ملئ الحاوية",
			primary_info: "المعلومات الأساسية",
			secondary_info: "المعلومات الفرعية",
			icon_type: "نوع الأيقونة",
			content_info: "المحتوى",
			use_entity_picture: "استخدم صورة الكيان؟",
			collapsible_controls: "تصغير عناصر التحكم عند الإيقاف",
			icon_animation: "تحريك الرمز عندما يكون نشطًا؟"
		},
		light: {
			show_brightness_control: "التحكم في السطوع؟",
			use_light_color: "استخدم لون فاتح",
			show_color_temp_control: "التحكم في حرارة اللون؟",
			show_color_control: "التحكم في اللون؟",
			incompatible_controls: "قد لا يتم عرض بعض عناصر التحكم إذا كان الضوء الخاص بك لا يدعم الميزة."
		},
		fan: {
			show_percentage_control: "التحكم في النسبة المئوية؟",
			show_oscillate_control: "التحكم في التذبذب؟"
		},
		cover: {
			show_buttons_control: "أزرار التحكم؟",
			show_position_control: "التحكم في الموقع؟"
		},
		alarm_control_panel: {
			show_keypad: "إظهار لوحة المفاتيح"
		},
		template: {
			primary: "المعلومات الأساسية",
			secondary: "المعلومات الثانوية",
			multiline_secondary: "متعدد الأسطر الثانوية؟",
			entity_extra: "تستخدم في القوالب والإجراءات",
			content: "المحتوى",
			badge_icon: "أيقونة الشارة",
			badge_color: "لون الشارة",
			picture: "صورة (ستحل محل الأيقونة)"
		},
		title: {
			title: "العنوان",
			subtitle: "العنوان الفرعي"
		},
		chips: {
			alignment: "محاذاة"
		},
		weather: {
			show_conditions: "الأحوال الجوية؟",
			show_temperature: "الطقس؟"
		},
		update: {
			show_buttons_control: "أزرار التحكم؟"
		},
		vacuum: {
			commands: "الاوامر"
		},
		"media-player": {
			use_media_info: "استخدم معلومات الوسائط",
			use_media_artwork: "استخدم صورة الوسائط",
			show_volume_level: "إظهار مستوى الصوت",
			media_controls: "التحكم في الوسائط",
			media_controls_list: {
				on_off: "تشغيل/إيقاف",
				shuffle: "خلط",
				previous: "السابق",
				play_pause_stop: "تشغيل/إيقاف مؤقت/إيقاف",
				next: "التالي",
				repeat: "وضع التكرار"
			},
			volume_controls: "التحكم في الصوت",
			volume_controls_list: {
				volume_buttons: "أزرار الصوت",
				volume_set: "مستوى الصوت",
				volume_mute: "كتم"
			}
		},
		lock: {
			lock: "مقفل",
			unlock: "إلغاء قفل",
			open: "مفتوح"
		},
		humidifier: {
			show_target_humidity_control: "التحكم في الرطوبة؟?"
		},
		climate: {
			show_temperature_control: "التحكم في درجة الحرارة؟",
			hvac_modes: "أوضاع HVAC"
		}
	},
	chip: {
		sub_element_editor: {
			title: "محرر الرقاقة"
		},
		conditional: {
			chip: "رقاقة"
		},
		"chip-picker": {
			chips: "رقاقات",
			add: "أضف رقاقة",
			edit: "تعديل",
			clear: "مسح",
			select: "اختر الرقاقة",
			types: {
				action: "إجراء",
				"alarm-control-panel": "تنبيه",
				back: "رجوع",
				conditional: "مشروط",
				entity: "الكيان",
				light: "Light",
				menu: "القائمة",
				template: "قالب",
				weather: "الطقس"
			}
		}
	}
};
var ar = {
	editor: editor$p
};

var ar$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  editor: editor$p,
  'default': ar
});

var editor$o = {
	form: {
		color_picker: {
			values: {
				"default": "Основен цвят"
			}
		},
		info_picker: {
			values: {
				"default": "Основна информация",
				name: "Име",
				state: "Състояние",
				"last-changed": "Последно Променен",
				"last-updated": "Последно Актуализиран",
				none: "Липсва"
			}
		},
		icon_type_picker: {
			values: {
				"default": "Основен тип",
				icon: "Икона",
				"entity-picture": "Картина на обекта",
				none: "Липсва"
			}
		},
		layout_picker: {
			values: {
				"default": "Основно оформление",
				vertical: "Вертикално оформление",
				horizontal: "Хоризонтално оформление"
			}
		},
		alignment_picker: {
			values: {
				"default": "Основно подравняване",
				start: "Старт",
				end: "Край",
				center: "Център",
				justify: "Подравнен"
			}
		}
	},
	card: {
		generic: {
			icon_color: "Цвят на икона",
			layout: "Оформление",
			fill_container: "Изпълване на контейнера",
			primary_info: "Първостепенна информация",
			secondary_info: "Второстепенна информация",
			icon_type: "Тип на икона",
			content_info: "Съдържание",
			use_entity_picture: "Използвай снимката на обекта?",
			collapsible_controls: "Свий контролите при изключен",
			icon_animation: "Анимирай иконата при активен?"
		},
		light: {
			show_brightness_control: "Контрол на яркостта?",
			use_light_color: "Използвай цвета на светлината",
			show_color_temp_control: "Контрол на температурата?",
			show_color_control: "Контрол на цвета?",
			incompatible_controls: "Някои опции могат да бъдат скрити при условие че осветителното тяло не поддържа фунцията."
		},
		fan: {
			show_percentage_control: "Процентов контрол?",
			show_oscillate_control: "Контрол на трептенето?"
		},
		cover: {
			show_buttons_control: "Контролни бутони?",
			show_position_control: "Контрол на позицията?",
			show_tilt_position_control: "Контрол на наклона?"
		},
		alarm_control_panel: {
			show_keypad: "Покажи клавиатура"
		},
		template: {
			primary: "Първостепенна информация",
			secondary: "Второстепенна информация",
			multiline_secondary: "Много-редова второстепенна информация?",
			entity_extra: "Използван в шаблони и действия",
			content: "Съдържание",
			badge_icon: "Икона на значка",
			badge_color: "Цвят на значка",
			picture: "Картина (ще замени иконата)"
		},
		title: {
			title: "Заглавие",
			subtitle: "Подзаглавие"
		},
		chips: {
			alignment: "Подравняване"
		},
		weather: {
			show_conditions: "Условия?",
			show_temperature: "Температура?"
		},
		update: {
			show_buttons_control: "Контролни бутони?"
		},
		vacuum: {
			commands: "Конади",
			commands_list: {
				on_off: "Вкл./Изкл."
			}
		},
		"media-player": {
			use_media_info: "Използвай информация от медията",
			use_media_artwork: "Използвай визуалните детайли от медията",
			show_volume_level: "Покажи контрола за звук",
			media_controls: "Контрол на Медиата",
			media_controls_list: {
				on_off: "Вкл./Изкл.",
				shuffle: "Разбъркано",
				previous: "Предишен",
				play_pause_stop: "Пусни/пауза/стоп",
				next: "Следващ",
				repeat: "Повтаряне"
			},
			volume_controls: "Контрол на звука",
			volume_controls_list: {
				volume_buttons: "Бутони за звук",
				volume_set: "Ниво на звука",
				volume_mute: "Заглуши"
			}
		},
		lock: {
			lock: "Заключен",
			unlock: "Отключен",
			open: "Отворен"
		},
		humidifier: {
			show_target_humidity_control: "Контрол на влажността?"
		},
		climate: {
			show_temperature_control: "Контрол на температурата?",
			hvac_modes: "HVAC Режими"
		}
	},
	chip: {
		sub_element_editor: {
			title: "Чип редактор"
		},
		conditional: {
			chip: "Чип"
		},
		"chip-picker": {
			chips: "Чипове",
			add: "Добави чип",
			edit: "Редактирай",
			clear: "Изчисти",
			select: "Избери чип",
			types: {
				action: "Действия",
				"alarm-control-panel": "Аларма",
				back: "Назад",
				conditional: "Условни",
				entity: "Обект",
				light: "Осветление",
				menu: "Меню",
				template: "Шаблон",
				weather: "Време"
			}
		}
	}
};
var bg = {
	editor: editor$o
};

var bg$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  editor: editor$o,
  'default': bg
});

var editor$n = {
	form: {
		color_picker: {
			values: {
				"default": "Výchozí barva"
			}
		},
		info_picker: {
			values: {
				"default": "Základní informace",
				name: "Název",
				state: "Stav",
				"last-changed": "Poslední změna",
				"last-updated": "Poslední update",
				none: "Nic"
			}
		},
		icon_type_picker: {
			values: {
				"default": "Výchozí typ",
				icon: "Ikona",
				"entity-picture": "Ikona entity",
				none: "Nic"
			}
		},
		layout_picker: {
			values: {
				"default": "Výchozí rozložení",
				vertical: "Svislé rozložení",
				horizontal: "Vodorovné rozložení"
			}
		},
		alignment_picker: {
			values: {
				"default": "Výchozí zarovnání",
				start: "Začátek",
				end: "Konec",
				center: "Na střed",
				justify: "Důvod"
			}
		}
	},
	card: {
		generic: {
			icon_color: "Barva ikony",
			layout: "Rozložení",
			fill_container: "Vyplnit prostor",
			primary_info: "Základní informace",
			secondary_info: "Sekundární informace",
			icon_type: "Typ ikony",
			content_info: "Obsah",
			use_entity_picture: "Použít ikonu entity?",
			collapsible_controls: "Skrýt ovládací prvky pokud je VYP",
			icon_animation: "Animovaná ikona, pokud je aktivní?"
		},
		light: {
			show_brightness_control: "Ovládání jasu?",
			use_light_color: "Použít ovládání světla",
			show_color_temp_control: "Ovládání teploty světla?",
			show_color_control: "Ovládání baryv světla?",
			incompatible_controls: "Některé ovládací prvky se nemusí zobrazit, pokud vaše světlo tuto funkci nepodporuje."
		},
		fan: {
			show_percentage_control: "Ovládání v procentech?",
			show_oscillate_control: "Oscillate control?"
		},
		cover: {
			show_buttons_control: "Zobrazit ovládací tlačítka?",
			show_position_control: "Zobrazit ovládání polohy?"
		},
		alarm_control_panel: {
			show_keypad: "Zobrazit klávesnici"
		},
		template: {
			primary: "Základní informace",
			secondary: "Sekundární informace",
			multiline_secondary: "Víceřádková sekundární informace?",
			entity_extra: "Použito v šablonách a akcích",
			content: "Obsah",
			badge_icon: "Ikona odznaku",
			badge_color: "Barva odznaku",
			picture: "Obrázek (nahradí ikonu)"
		},
		title: {
			title: "Titulek",
			subtitle: "Popis"
		},
		chips: {
			alignment: "Zarovnání"
		},
		weather: {
			show_conditions: "Zobrazit podmínky?",
			show_temperature: "Zobrazit teplot?u"
		},
		update: {
			show_buttons_control: "Zobrazit ovládací tlačítka?"
		},
		vacuum: {
			commands: "Příkazy"
		},
		"media-player": {
			use_media_info: "Použít informace o médiích",
			use_media_artwork: "Použít ilustrace médií",
			show_volume_level: "Zobrazit úroveň hlasitosti",
			media_controls: "Ovládání médií",
			media_controls_list: {
				on_off: "Vyp / Zap",
				shuffle: "Zamíchat",
				previous: "Předchozí skladba",
				play_pause_stop: "hrát/pauza/zastavit",
				next: "Další skladba",
				repeat: "Opakovat"
			},
			volume_controls: "Ovládání hlasitosti",
			volume_controls_list: {
				volume_buttons: "Tlačítka hlasitosti",
				volume_set: "Úroveň hlasitosti",
				volume_mute: "Ztlumit"
			}
		},
		lock: {
			lock: "Zamčeno",
			unlock: "Odemčeno",
			open: "Otevřeno"
		},
		humidifier: {
			show_target_humidity_control: "Ovládání vlhkosti?"
		},
		climate: {
			show_temperature_control: "Ovládání teploty?",
			hvac_modes: "HVAC Mód"
		}
	},
	chip: {
		sub_element_editor: {
			title: "Editor tlačítek"
		},
		conditional: {
			chip: "Tlačítko"
		},
		"chip-picker": {
			chips: "Tlačítka",
			add: "Přidat tlačítko",
			edit: "Editovat",
			clear: "Vymazat",
			select: "Vybrat tlačítko",
			types: {
				action: "Akce",
				"alarm-control-panel": "Alarm",
				back: "Zpět",
				conditional: "Podmínky",
				entity: "Entita",
				light: "Světlo",
				menu: "Menu",
				template: "Šablona",
				weather: "Počasí"
			}
		}
	}
};
var cs$1 = {
	editor: editor$n
};

var cs$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  editor: editor$n,
  'default': cs$1
});

var editor$m = {
	form: {
		color_picker: {
			values: {
				"default": "Standard farve"
			}
		},
		info_picker: {
			values: {
				"default": "Standard information",
				name: "Navn",
				state: "Status",
				"last-changed": "Sidst ændret",
				"last-updated": "Sidst opdateret",
				none: "Ingen"
			}
		},
		icon_type_picker: {
			values: {
				"default": "Standard type",
				icon: "Ikon",
				"entity-picture": "Enheds billede",
				none: "Ingen"
			}
		},
		layout_picker: {
			values: {
				"default": "Standard layout",
				vertical: "Vertikal layout",
				horizontal: "Horisontal layout"
			}
		},
		alignment_picker: {
			values: {
				"default": "Standard justering",
				start: "Start",
				end: "Slut",
				center: "Centrer",
				justify: "Lige margener"
			}
		}
	},
	card: {
		generic: {
			icon_color: "Ikon farve",
			layout: "Layout",
			fill_container: "Fyld container",
			primary_info: "Primær information",
			secondary_info: "Sekundær information",
			icon_type: "Ikon type",
			content_info: "Indhold",
			use_entity_picture: "Brug enheds billede?",
			collapsible_controls: "Skjul kontroller når slukket",
			icon_animation: "Animér ikon når aktiv?"
		},
		light: {
			show_brightness_control: "Lysstyrkekontrol?",
			use_light_color: "Brug lysfarve",
			show_color_temp_control: "Temperatur farvekontrol?",
			show_color_control: "Farvekontrol?",
			incompatible_controls: "Nogle kontroller vises muligvis ikke, hvis dit lys ikke understøtter funktionen."
		},
		fan: {
			show_percentage_control: "Procentvis kontrol?",
			show_oscillate_control: "Oscillerende kontrol?"
		},
		cover: {
			show_buttons_control: "Betjeningsknapper?",
			show_position_control: "Positionskontrol?"
		},
		alarm_control_panel: {
			show_keypad: "Vis tastatur"
		},
		template: {
			primary: "Primær information",
			secondary: "Sekundær information",
			multiline_secondary: "Multi-linje skundær?",
			entity_extra: "Anvendes i skabelober og handlinger",
			content: "Indhold",
			badge_icon: "Badge ikon",
			badge_color: "Badge farve",
			picture: "Billede (erstatter ikonen)"
		},
		title: {
			title: "Titel",
			subtitle: "Undertitel"
		},
		chips: {
			alignment: "Justering"
		},
		weather: {
			show_conditions: "Forhold?",
			show_temperature: "Temperatur?"
		},
		update: {
			show_buttons_control: "Betjeningsknapper?"
		},
		vacuum: {
			commands: "Kommandoer"
		},
		"media-player": {
			use_media_info: "Brug medie info",
			use_media_artwork: "Brug mediebilleder",
			show_volume_level: "Vis volumen niveau",
			media_controls: "Medie kontrol",
			media_controls_list: {
				on_off: "Tænd/Sluk",
				shuffle: "Bland",
				previous: "Forrige nummer",
				play_pause_stop: "Afspil/Pause/Stop",
				next: "Næste nummer",
				repeat: "Gentagelsestilstand"
			},
			volume_controls: "Volumen kontrol",
			volume_controls_list: {
				volume_buttons: "Volumen knapper",
				volume_set: "Volumenniveau",
				volume_mute: "Lydløs"
			}
		},
		lock: {
			lock: "Lås",
			unlock: "Lås op",
			open: "Åben"
		},
		humidifier: {
			show_target_humidity_control: "Luftfugtigheds kontrol?"
		},
		climate: {
			show_temperature_control: "Temperatur kontrol?",
			hvac_modes: "HVAC-tilstande"
		}
	},
	chip: {
		sub_element_editor: {
			title: "Chip-editor"
		},
		conditional: {
			chip: "Chip"
		},
		"chip-picker": {
			chips: "Chips",
			add: "Tilføj chip",
			edit: "Rediger",
			clear: "Nulstil",
			select: "Vælg chip",
			types: {
				action: "Handling",
				"alarm-control-panel": "Alarm",
				back: "Tilbage",
				conditional: "Betinget",
				entity: "Enhed",
				light: "Lys",
				menu: "Menu",
				template: "Skabelon",
				weather: "Vejr"
			}
		}
	}
};
var da = {
	editor: editor$m
};

var da$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  editor: editor$m,
  'default': da
});

var editor$l = {
	form: {
		color_picker: {
			values: {
				"default": "Standardfarbe"
			}
		},
		info_picker: {
			values: {
				"default": "Standard-Information",
				name: "Name",
				state: "Zustand",
				"last-changed": "Letzte Änderung",
				"last-updated": "Letzte Aktualisierung",
				none: "Keine"
			}
		},
		icon_type_picker: {
			values: {
				"default": "Standard-Typ",
				icon: "Icon",
				"entity-picture": "Entitätsbild",
				none: "Keines"
			}
		},
		layout_picker: {
			values: {
				"default": "Standard-Layout",
				vertical: "Vertikales Layout",
				horizontal: "Horizontales Layout"
			}
		},
		alignment_picker: {
			values: {
				"default": "Standard",
				start: "Anfang",
				end: "Ende",
				center: "Mitte",
				justify: "Ausrichten"
			}
		}
	},
	card: {
		generic: {
			icon_color: "Icon-Farbe",
			layout: "Layout",
			fill_container: "Container ausfüllen",
			primary_info: "Primäre Information",
			secondary_info: "Sekundäre Information",
			icon_type: "Icon-Typ",
			content_info: "Inhalt",
			use_entity_picture: "Entitätsbild verwenden?",
			collapsible_controls: "Schieberegler einklappen, wenn aus",
			icon_animation: "Icon animieren, wenn aktiv?"
		},
		light: {
			show_brightness_control: "Helligkeitsregelung?",
			use_light_color: "Farbsteuerung verwenden",
			show_color_temp_control: "Farbtemperatursteuerung?",
			show_color_control: "Farbsteuerung?",
			incompatible_controls: "Einige Steuerelemente werden möglicherweise nicht angezeigt, wenn Ihr Licht diese Funktion nicht unterstützt."
		},
		fan: {
			show_percentage_control: "Prozentuale Kontrolle?",
			show_oscillate_control: "Oszillationssteuerung?"
		},
		cover: {
			show_buttons_control: "Schaltflächensteuerung?",
			show_position_control: "Positionssteuerung?",
			show_tilt_position_control: "Winkelsteuerung?"
		},
		alarm_control_panel: {
			show_keypad: "Keypad anzeigen"
		},
		template: {
			primary: "Primäre Information",
			secondary: "Sekundäre Information",
			multiline_secondary: "Mehrzeilig sekundär?",
			entity_extra: "Wird in Vorlagen und Aktionen verwendet",
			content: "Inhalt",
			badge_icon: "Badge-Icon",
			badge_color: "Badge-Farbe",
			picture: "Bild (ersetzt das Icon)"
		},
		title: {
			title: "Titel",
			subtitle: "Untertitel"
		},
		chips: {
			alignment: "Ausrichtung"
		},
		weather: {
			show_conditions: "Bedingungen?",
			show_temperature: "Temperatur?"
		},
		update: {
			show_buttons_control: "Schaltflächensteuerung?"
		},
		vacuum: {
			commands: "Befehle",
			commands_list: {
				on_off: "An/Ausschalten"
			}
		},
		"media-player": {
			use_media_info: "Medieninfos verwenden",
			use_media_artwork: "Mediengrafik verwenden",
			show_volume_level: "Lautstärke-Level anzeigen",
			media_controls: "Mediensteuerung",
			media_controls_list: {
				on_off: "Ein/Aus",
				shuffle: "Zufällige Wiedergabe",
				previous: "Vorheriger Titel",
				play_pause_stop: "Play/Pause/Stop",
				next: "Nächster Titel",
				repeat: "Wiederholen"
			},
			volume_controls: "Lautstärkesteuerung",
			volume_controls_list: {
				volume_buttons: "Lautstärke-Buttons",
				volume_set: "Lautstärke-Level",
				volume_mute: "Stumm"
			}
		},
		lock: {
			lock: "Verriegeln",
			unlock: "Entriegeln",
			open: "Öffnen"
		},
		humidifier: {
			show_target_humidity_control: "Luftfeuchtigkeitssteuerung?"
		},
		climate: {
			show_temperature_control: "Temperatursteuerung?",
			hvac_modes: "HVAC-Modi"
		}
	},
	chip: {
		sub_element_editor: {
			title: "Chip Editor"
		},
		conditional: {
			chip: "Chip"
		},
		"chip-picker": {
			chips: "Chips",
			add: "Chip hinzufügen",
			edit: "Editieren",
			clear: "Löschen",
			select: "Chip auswählen",
			types: {
				action: "Aktion",
				"alarm-control-panel": "Alarm",
				back: "Zurück",
				conditional: "Bedingung",
				entity: "Entität",
				light: "Licht",
				menu: "Menü",
				template: "Vorlage",
				weather: "Wetter"
			}
		}
	}
};
var de = {
	editor: editor$l
};

var de$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  editor: editor$l,
  'default': de
});

var editor$k = {
	form: {
		color_picker: {
			values: {
				"default": "Προεπιλεγμένο χρώμα"
			}
		},
		info_picker: {
			values: {
				"default": "Προεπιλεγμένες πληροφορίες",
				name: "Όνομα",
				state: "Κατάσταση",
				"last-changed": "Τελευταία αλλαγή",
				"last-updated": "Τελευταία ενημέρωση",
				none: "Τίποτα"
			}
		},
		layout_picker: {
			values: {
				"default": "Προεπιλεγμένη διάταξη",
				vertical: "Κάθετη διάταξη",
				horizontal: "Οριζόντια διάταξη"
			}
		},
		alignment_picker: {
			values: {
				"default": "Προεπιλεγμένη στοίχιση",
				start: "Στοίχιση αριστερά",
				end: "Στοίχιση δεξιά",
				center: "Στοίχιση στο κέντρο",
				justify: "Πλήρης στοίχιση"
			}
		}
	},
	card: {
		generic: {
			icon_color: "Χρώμα εικονιδίου",
			layout: "Διάταξη",
			primary_info: "Πρωτεύουσες πληροφορίες",
			secondary_info: "Δευτερεύουσες πληροφορίες",
			content_info: "Περιεχόμενο",
			use_entity_picture: "Χρήση εικόνας οντότητας;",
			icon_animation: "Κίνηση εικονιδίου όταν είναι ενεργό;"
		},
		light: {
			show_brightness_control: "Έλεγχος φωτεινότητας;",
			use_light_color: "Χρήση χρώματος φωτος",
			show_color_temp_control: "Έλεγχος χρώματος θερμοκρασίας;",
			show_color_control: "Έλεγχος χρώματος;",
			incompatible_controls: "Ορισμένα στοιχεία ελέγχου ενδέχεται να μην εμφανίζονται εάν το φωτιστικό σας δεν υποστηρίζει τη λειτουργία."
		},
		fan: {
			show_percentage_control: "Έλεγχος ποσοστού;",
			show_oscillate_control: "Έλεγχος ταλάντωσης;"
		},
		cover: {
			show_buttons_control: "Έλεγχος κουμπιών;",
			show_position_control: "Έλεγχος θέσης;"
		},
		template: {
			primary: "Πρωτεύουσες πληροφορίες",
			secondary: "Δευτερεύουσες πληροφορίες",
			multiline_secondary: "Δευτερεύουσες πολλαπλών γραμμών;",
			entity_extra: "Χρησιμοποιείται σε πρότυπα και ενέργειες",
			content: "Περιεχόμενο"
		},
		title: {
			title: "Τίτλος",
			subtitle: "Υπότιτλος"
		},
		chips: {
			alignment: "Ευθυγράμμιση"
		},
		weather: {
			show_conditions: "Συνθήκες;",
			show_temperature: "Θερμοκρασία;"
		},
		update: {
			show_buttons_control: "Έλεγχος κουμπιών;"
		},
		vacuum: {
			commands: "Εντολές"
		},
		"media-player": {
			use_media_info: "Χρήση πληροφοριών πολυμέσων",
			use_media_artwork: "Χρήση έργων τέχνης πολυμέσων",
			media_controls: "Έλεγχος πολυμέσων",
			media_controls_list: {
				on_off: "Ενεργοποίηση/απενεργοποίηση",
				shuffle: "Τυχαία σειρά",
				previous: "Προηγούμενο κομμάτι",
				play_pause_stop: "Αναπαραγωγή/παύση/διακοπή",
				next: "Επόμενο κομμάτι",
				repeat: "Λειτουργία επανάληψης"
			},
			volume_controls: "Χειριστήρια έντασης ήχου",
			volume_controls_list: {
				volume_buttons: "Κουμπιά έντασης ήχου",
				volume_set: "Επίπεδο έντασης ήχου",
				volume_mute: "Σίγαση"
			}
		}
	},
	chip: {
		sub_element_editor: {
			title: "Επεξεργαστής Chip"
		},
		conditional: {
			chip: "Chip"
		},
		"chip-picker": {
			chips: "Chips",
			add: "Προσθήκη chip",
			edit: "Επεξεργασία",
			clear: "Καθαρισμός",
			select: "Επιλογή chip",
			types: {
				action: "Ενέργεια",
				"alarm-control-panel": "Συναγερμός",
				back: "Πίσω",
				conditional: "Υπό προϋποθέσεις",
				entity: "Οντότητα",
				light: "Φως",
				menu: "Μενού",
				template: "Πρότυπο",
				weather: "Καιρός"
			}
		}
	}
};
var el = {
	editor: editor$k
};

var el$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  editor: editor$k,
  'default': el
});

var editor$j = {
	form: {
		color_picker: {
			values: {
				"default": "Default color"
			}
		},
		info_picker: {
			values: {
				"default": "Default information",
				name: "Name",
				state: "State",
				"last-changed": "Last Changed",
				"last-updated": "Last Updated",
				none: "None"
			}
		},
		icon_type_picker: {
			values: {
				"default": "Default type",
				icon: "Icon",
				"entity-picture": "Entity picture",
				none: "None"
			}
		},
		layout_picker: {
			values: {
				"default": "Default layout",
				vertical: "Vertical layout",
				horizontal: "Horizontal layout"
			}
		},
		alignment_picker: {
			values: {
				"default": "Default alignment",
				start: "Start",
				end: "End",
				center: "Center",
				justify: "Justify"
			}
		}
	},
	card: {
		generic: {
			icon_color: "Icon color",
			layout: "Layout",
			fill_container: "Fill container",
			primary_info: "Primary information",
			secondary_info: "Secondary information",
			icon_type: "Icon type",
			content_info: "Content",
			use_entity_picture: "Use entity picture?",
			collapsible_controls: "Collapse controls when off",
			icon_animation: "Animate icon when active?"
		},
		light: {
			show_brightness_control: "Brightness control?",
			use_light_color: "Use light color",
			show_color_temp_control: "Temperature color control?",
			show_color_control: "Color control?",
			incompatible_controls: "Some controls may not be displayed if your light does not support the feature."
		},
		fan: {
			show_percentage_control: "Percentage control?",
			show_oscillate_control: "Oscillate control?"
		},
		cover: {
			show_buttons_control: "Control buttons?",
			show_position_control: "Position control?",
			show_tilt_position_control: "Tilt control?"
		},
		alarm_control_panel: {
			show_keypad: "Show keypad"
		},
		template: {
			primary: "Primary information",
			secondary: "Secondary information",
			multiline_secondary: "Multiline secondary?",
			entity_extra: "Used in templates and actions",
			content: "Content",
			badge_icon: "Badge icon",
			badge_color: "Badge color",
			picture: "Picture (will replace the icon)"
		},
		title: {
			title: "Title",
			subtitle: "Subtitle"
		},
		chips: {
			alignment: "Alignment"
		},
		weather: {
			show_conditions: "Conditions?",
			show_temperature: "Temperature?"
		},
		update: {
			show_buttons_control: "Control buttons?"
		},
		vacuum: {
			commands: "Commands",
			commands_list: {
				on_off: "Turn on/off"
			}
		},
		"media-player": {
			use_media_info: "Use media info",
			use_media_artwork: "Use media artwork",
			show_volume_level: "Show volume level",
			media_controls: "Media controls",
			media_controls_list: {
				on_off: "Turn on/off",
				shuffle: "Shuffle",
				previous: "Previous track",
				play_pause_stop: "Play/pause/stop",
				next: "Next track",
				repeat: "Repeat mode"
			},
			volume_controls: "Volume controls",
			volume_controls_list: {
				volume_buttons: "Volume buttons",
				volume_set: "Volume level",
				volume_mute: "Mute"
			}
		},
		lock: {
			lock: "Lock",
			unlock: "Unlock",
			open: "Open"
		},
		humidifier: {
			show_target_humidity_control: "Humidity control?"
		},
		climate: {
			show_temperature_control: "Temperature control?",
			hvac_modes: "HVAC Modes"
		}
	},
	chip: {
		sub_element_editor: {
			title: "Chip editor"
		},
		conditional: {
			chip: "Chip"
		},
		"chip-picker": {
			chips: "Chips",
			add: "Add chip",
			edit: "Edit",
			clear: "Clear",
			select: "Select chip",
			types: {
				action: "Action",
				"alarm-control-panel": "Alarm",
				back: "Back",
				conditional: "Conditional",
				entity: "Entity",
				light: "Light",
				menu: "Menu",
				template: "Template",
				weather: "Weather"
			}
		}
	}
};
var en = {
	editor: editor$j
};

var en$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  editor: editor$j,
  'default': en
});

var editor$i = {
	form: {
		color_picker: {
			values: {
				"default": "Color predeterminado"
			}
		},
		info_picker: {
			values: {
				"default": "Informacion predeterminada",
				name: "Nombre",
				state: "Estado",
				"last-changed": "Último cambio",
				"last-updated": "Última actualización",
				none: "Ninguno"
			}
		},
		layout_picker: {
			values: {
				"default": "Diseño predeterminado",
				vertical: "Diseño vertical",
				horizontal: "Diseño Horizontal"
			}
		},
		alignment_picker: {
			values: {
				"default": "Alineación predeterminada",
				start: "Inicio",
				end: "Final",
				center: "Centrado",
				justify: "Justificado"
			}
		}
	},
	card: {
		generic: {
			icon_color: "Color de icono",
			layout: "Diseño",
			fill_container: "Rellenar",
			primary_info: "Información primaria",
			secondary_info: "Información secundaria",
			content_info: "Contenido",
			use_entity_picture: "¿Usar imagen de entidad?",
			collapsible_controls: "Contraer controles cuando está apagado",
			icon_animation: "¿Icono animado cuando está activo?"
		},
		light: {
			show_brightness_control: "¿Controlar brillo?",
			use_light_color: "Usar color de la luz",
			show_color_temp_control: "¿Controlar temperatura del color?",
			show_color_control: "¿Controlar Color?",
			incompatible_controls: "Es posible que algunos controles no se muestren si su luz no es compatible con la función."
		},
		fan: {
			show_percentage_control: "¿Controlar porcentaje?",
			show_oscillate_control: "¿Controlar oscilación?"
		},
		cover: {
			show_buttons_control: "¿Botones de control?",
			show_position_control: "¿Control de posición?"
		},
		alarm_control_panel: {
			show_keypad: "Mostrar teclado"
		},
		template: {
			primary: "Información primaria",
			secondary: "Información secundaria",
			multiline_secondary: "¿Secundaria multilínea?",
			entity_extra: "Utilizado en plantillas y acciones.",
			content: "Contenido"
		},
		title: {
			title: "Título",
			subtitle: "Subtítulo"
		},
		chips: {
			alignment: "Alineación"
		},
		weather: {
			show_conditions: "¿Condiciones?",
			show_temperature: "¿Temperatura?"
		},
		update: {
			show_buttons_control: "¿Botones de control?"
		},
		vacuum: {
			commands: "Comandos"
		},
		"media-player": {
			use_media_info: "Usar información multimedia",
			use_media_artwork: "Usar ilustraciones multimedia",
			show_volume_level: "Mostrar nivel de volumen",
			media_controls: "Controles multimedia",
			media_controls_list: {
				on_off: "Encender/apagar",
				shuffle: "Aleatoria",
				previous: "Pista anterior",
				play_pause_stop: "Play/pausa/parar",
				next: "Pista siguiente",
				repeat: "Modo de repetición"
			},
			volume_controls: "Controles de volumen",
			volume_controls_list: {
				volume_buttons: "Botones de volumen",
				volume_set: "Nivel de volumen",
				volume_mute: "Silenciar"
			}
		},
		lock: {
			lock: "Bloquear",
			unlock: "Desbloquear",
			open: "Abrir"
		},
		humidifier: {
			show_target_humidity_control: "¿Controlar humedad?"
		}
	},
	chip: {
		sub_element_editor: {
			title: "Editor de chip"
		},
		conditional: {
			chip: "Chip"
		},
		"chip-picker": {
			chips: "Chips",
			add: "Añadir chip",
			edit: "Editar",
			clear: "Limpiar",
			select: "Seleccionar chip",
			types: {
				action: "Acción",
				"alarm-control-panel": "Alarma",
				back: "Volver",
				conditional: "Condicional",
				entity: "Entidad",
				light: "Luz",
				menu: "Menú",
				template: "Plantilla",
				weather: "Clima"
			}
		}
	}
};
var es = {
	editor: editor$i
};

var es$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  editor: editor$i,
  'default': es
});

var editor$h = {
	form: {
		color_picker: {
			values: {
				"default": "Oletusväri"
			}
		},
		info_picker: {
			values: {
				"default": "Oletustiedot",
				name: "Nimi",
				state: "Tila",
				"last-changed": "Viimeksi muuttunut",
				"last-updated": "Viimeksi päivittynyt",
				none: "Ei mitään"
			}
		},
		icon_type_picker: {
			values: {
				"default": "Oletustyyppi",
				icon: "Kuvake",
				"entity-picture": "Kohteen kuva",
				none: "Ei mitään"
			}
		},
		layout_picker: {
			values: {
				"default": "Oletusasettelu",
				vertical: "Pystysuuntainen",
				horizontal: "Vaakasuuntainen"
			}
		},
		alignment_picker: {
			values: {
				"default": "Keskitys",
				start: "Alku",
				end: "Loppu",
				center: "Keskitä",
				justify: "Sovita"
			}
		}
	},
	card: {
		generic: {
			icon_color: "Ikonin väri",
			layout: "Asettelu",
			fill_container: "Täytä alue",
			primary_info: "Ensisijaiset tiedot",
			secondary_info: "Toissijaiset tiedot",
			icon_type: "Kuvakkeen tyyppi",
			content_info: "Sisältö",
			use_entity_picture: "Käytä kohteen kuvaa?",
			collapsible_controls: "Piilota toiminnot off-tilassa",
			icon_animation: "Animoi kuvake, kun aktiivinen?"
		},
		light: {
			show_brightness_control: "Kirkkauden säätö?",
			use_light_color: "Käytä valaisimen väriä",
			show_color_temp_control: "Värilämpötilan säätö?",
			show_color_control: "Värin säätö?",
			incompatible_controls: "Jotkin toiminnot eivät näy, jos valaisimesi ei tue niitä."
		},
		fan: {
			show_percentage_control: "Prosentuaalinen säätö?",
			show_oscillate_control: "Oskillaation säätö?"
		},
		cover: {
			show_buttons_control: "Toimintopainikkeet?",
			show_position_control: "Sijainnin hallinta?"
		},
		alarm_control_panel: {
			show_keypad: "Näytä näppäimet"
		},
		template: {
			primary: "Ensisijaiset tiedot",
			secondary: "Toissijaiset tiedot",
			multiline_secondary: "Monirivinen toissijainen tieto?",
			entity_extra: "Käytetään malleissa ja toiminnoissa",
			content: "Sisältö",
			badge_icon: "Merkin kuvake",
			badge_color: "Merkin väri",
			picture: "Kuva (korvaa kuvakkeen)"
		},
		title: {
			title: "Otsikko",
			subtitle: "Tekstitys"
		},
		chips: {
			alignment: "Asettelu"
		},
		weather: {
			show_conditions: "Ehdot?",
			show_temperature: "Lämpötila?"
		},
		update: {
			show_buttons_control: "Toimintopainikkeet?"
		},
		vacuum: {
			commands: "Komennot"
		},
		"media-player": {
			use_media_info: "Käytä median tietoja",
			use_media_artwork: "Käytä median kuvituksia",
			show_volume_level: "Näytä äänenvoimakkuuden hallinta",
			media_controls: "Toiminnot",
			media_controls_list: {
				on_off: "Päälle/pois",
				shuffle: "Sekoita",
				previous: "Edellinen kappale",
				play_pause_stop: "Toista/keskeytä/pysäytä",
				next: "Seuraava kappale",
				repeat: "Jatkuva toisto"
			},
			volume_controls: "Äänenvoimakkuuden hallinta",
			volume_controls_list: {
				volume_buttons: "Äänenvoimakkuuspainikkeet",
				volume_set: "Äänenvoimakkuus",
				volume_mute: "Mykistä"
			}
		},
		lock: {
			lock: "Lukitse",
			unlock: "Poista lukitus",
			open: "Avaa"
		},
		humidifier: {
			show_target_humidity_control: "Kosteudenhallinta?"
		}
	},
	chip: {
		sub_element_editor: {
			title: "Merkkieditori"
		},
		conditional: {
			chip: "Merkki"
		},
		"chip-picker": {
			chips: "Merkit",
			add: "Lisää merkki",
			edit: "Muokkaa",
			clear: "Tyhjennä",
			select: "Valitse merkki",
			types: {
				action: "Toiminto",
				"alarm-control-panel": "Hälytys",
				back: "Takaisin",
				conditional: "Ehdollinen",
				entity: "Kohde",
				light: "Valaisin",
				menu: "Valikko",
				template: "Malli",
				weather: "Sää"
			}
		}
	}
};
var fi = {
	editor: editor$h
};

var fi$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  editor: editor$h,
  'default': fi
});

var editor$g = {
	form: {
		color_picker: {
			values: {
				"default": "Couleur par défaut"
			}
		},
		info_picker: {
			values: {
				"default": "Information par défaut",
				name: "Nom",
				state: "État",
				"last-changed": "Dernière modification",
				"last-updated": "Dernière mise à jour",
				none: "Aucune"
			}
		},
		icon_type_picker: {
			values: {
				"default": "Type par défaut",
				icon: "Icône",
				"entity-picture": "Image de l'entité",
				none: "Aucune"
			}
		},
		layout_picker: {
			values: {
				"default": "Disposition par défault",
				vertical: "Disposition verticale",
				horizontal: "Disposition horizontale"
			}
		},
		alignment_picker: {
			values: {
				"default": "Alignement par défaut",
				start: "Début",
				end: "Fin",
				center: "Centré",
				justify: "Justifié"
			}
		}
	},
	card: {
		generic: {
			icon_color: "Couleur de l'icône",
			layout: "Disposition",
			fill_container: "Remplir le conteneur",
			primary_info: "Information principale",
			secondary_info: "Information secondaire",
			icon_type: "Type d'icône",
			content_info: "Contenu",
			use_entity_picture: "Utiliser l'image de l'entité ?",
			collapsible_controls: "Reduire les contrôles quand éteint",
			icon_animation: "Animation de l'icône ?"
		},
		light: {
			show_brightness_control: "Contrôle de luminosité ?",
			use_light_color: "Utiliser la couleur de la lumière",
			show_color_temp_control: "Contrôle de la température ?",
			show_color_control: "Contrôle de la couleur ?",
			incompatible_controls: "Certains contrôles peuvent ne pas être affichés si votre lumière ne supporte pas la fonctionnalité."
		},
		fan: {
			show_percentage_control: "Contrôle de la vitesse ?",
			show_oscillate_control: "Contrôle de l'oscillation ?"
		},
		cover: {
			show_buttons_control: "Contrôle avec boutons ?",
			show_position_control: "Contrôle de la position ?"
		},
		alarm_control_panel: {
			show_keypad: "Afficher le clavier"
		},
		template: {
			primary: "Information principale",
			secondary: "Information secondaire",
			multiline_secondary: "Information secondaire sur plusieurs lignes ?",
			entity_extra: "Utilisée pour les templates et les actions",
			content: "Contenu",
			badge_icon: "Icône du badge",
			badge_color: "Couleur du badge",
			picture: "Picture (remplacera l'icône)"
		},
		title: {
			title: "Titre",
			subtitle: "Sous-titre"
		},
		chips: {
			alignment: "Alignement"
		},
		weather: {
			show_conditons: "Conditions ?",
			show_temperature: "Température ?"
		},
		update: {
			show_buttons_control: "Contrôle avec boutons ?"
		},
		vacuum: {
			commands: "Commandes",
			commands_list: {
				on_off: "Allumer/Éteindre"
			}
		},
		"media-player": {
			use_media_info: "Utiliser les informations du media",
			use_media_artwork: "Utiliser l'illustration du media",
			show_volume_level: "Afficher le niveau de volume",
			media_controls: "Contrôles du media",
			media_controls_list: {
				on_off: "Allumer/Éteindre",
				shuffle: "Lecture aléatoire",
				previous: "Précédent",
				play_pause_stop: "Lecture/pause/stop",
				next: "Suivant",
				repeat: "Mode de répétition"
			},
			volume_controls: "Contrôles du volume",
			volume_controls_list: {
				volume_buttons: "Bouton de volume",
				volume_set: "Niveau de volume",
				volume_mute: "Muet"
			}
		},
		lock: {
			lock: "Verrouiller",
			unlock: "Déverrouiller",
			open: "Ouvrir"
		},
		humidifier: {
			show_target_humidity_control: "Contrôle d'humidité ?"
		},
		climate: {
			show_temperature_control: "Contrôle de la température?",
			hvac_modes: "Modes du thermostat"
		}
	},
	chip: {
		sub_element_editor: {
			title: "Éditeur de \"chip\""
		},
		conditional: {
			chip: "Chip"
		},
		"chip-picker": {
			chips: "\"Chips\"",
			add: "Ajouter une \"chip\"",
			edit: "Modifier",
			clear: "Effacer",
			select: "Sélectionner une \"chip\"",
			types: {
				action: "Action",
				"alarm-control-panel": "Alarme",
				back: "Retour",
				conditional: "Conditionnel",
				entity: "Entité",
				light: "Lumière",
				menu: "Menu",
				template: "Template",
				weather: "Météo"
			}
		}
	}
};
var fr = {
	editor: editor$g
};

var fr$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  editor: editor$g,
  'default': fr
});

var editor$f = {
	form: {
		color_picker: {
			values: {
				"default": "צבע ברירת מחדל"
			}
		},
		info_picker: {
			values: {
				"default": "מידע ברירת מחדל",
				name: "שם",
				state: "מצב",
				"last-changed": "שונה לאחרונה",
				"last-updated": "עודכן לאחרונה",
				none: "ריק"
			}
		},
		layout_picker: {
			values: {
				"default": "סידור ברירת מחדל",
				vertical: "סידור מאונך",
				horizontal: "סידור מאוזן"
			}
		},
		alignment_picker: {
			values: {
				"default": "יישור ברירת מחדל",
				start: "התחלה",
				end: "סוף",
				center: "אמצע",
				justify: "מוצדק"
			}
		}
	},
	card: {
		generic: {
			icon_color: "צבע אייקון",
			layout: "סידור",
			fill_container: "מלא גבולות",
			primary_info: "מידע ראשי",
			secondary_info: "מידע מישני",
			content_info: "תוכן",
			use_entity_picture: "השתמש בתמונת ישות?",
			collapsible_controls: "הסתר שליטה כשאר מכובה?",
			icon_animation: "להנפיש אייקון כאשר דלוק?"
		},
		light: {
			show_brightness_control: "שליטה בבהירות?",
			use_light_color: "השתמש בצבע האור",
			show_color_temp_control: "שליטה בגוון האור?",
			show_color_control: "שליטה בצבע האור?",
			incompatible_controls: "יתכן וחלק מהכפתורים לא יופיעו אם התאורה אינה תומכת בתכונה."
		},
		fan: {
			show_percentage_control: "שליטה באחוז?",
			show_oscillate_control: "שליטה בהתנדנדות?"
		},
		cover: {
			show_buttons_control: "כפתורי שליטה?",
			show_position_control: "שליטה במיקום?"
		},
		alarm_control_panel: {
			show_keypad: "הצג מקלדת"
		},
		template: {
			primary: "מידע ראשי",
			secondary: "מידע מישני",
			multiline_secondary: "מידע מישני רו קווי?",
			entity_extra: "משמש בתבניות ופעולות",
			content: "תוכן"
		},
		title: {
			title: "כותרת",
			subtitle: "כתובית"
		},
		chips: {
			alignment: "יישור"
		},
		weather: {
			show_conditions: "הצג תנאים?",
			show_temperature: "הצג טמפרטורה?"
		},
		update: {
			show_buttons_control: "הצג כפתורי שליטה?"
		},
		vacuum: {
			commands: "פקודות",
			icon_animation: "להנפיש אייקון כאשר דלוק?"
		},
		"media-player": {
			use_media_info: "השתמש במידע מדיה",
			use_media_artwork: "השתמש באומנות מדיה",
			show_volume_level: "הצג שליטת ווליום",
			media_controls: "שליטה במדיה",
			media_controls_list: {
				on_off: "הדלק/כבה",
				shuffle: "ערבב",
				previous: "רצועה קודמת",
				play_pause_stop: "נגן/השהה/הפסק",
				next: "רצועה הבאה",
				repeat: "חזרה"
			},
			volume_controls: "שליטה בווליום",
			volume_controls_list: {
				volume_buttons: "כפתורי ווליום",
				volume_set: "רמת ווליום",
				volume_mute: "השתק"
			}
		},
		lock: {
			lock: "נעל",
			unlock: "בטל נעילה",
			open: "פתח"
		},
		humidifier: {
			show_target_humidity_control: "שליטה בלחות?"
		}
	},
	chip: {
		sub_element_editor: {
			title: "עורך שבב"
		},
		conditional: {
			chip: "שבב"
		},
		"chip-picker": {
			chips: "שבבים",
			add: "הוסף שבב",
			edit: "ערוך",
			clear: "נקה",
			select: "בחר שבב",
			types: {
				action: "פעולה",
				"alarm-control-panel": "אזעקה",
				back: "חזור",
				conditional: "מותנה",
				entity: "ישות",
				light: "אור",
				menu: "תפריט",
				template: "תבנית",
				weather: "מזג אוויר"
			}
		}
	}
};
var he = {
	editor: editor$f
};

var he$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  editor: editor$f,
  'default': he
});

var editor$e = {
	form: {
		color_picker: {
			values: {
				"default": "Alapértelmezett szín"
			}
		},
		info_picker: {
			values: {
				"default": "Alepértelmezett információ",
				name: "Név",
				state: "Állapot",
				"last-changed": "Utoljára módosítva",
				"last-updated": "Utoljára frissítve",
				none: "Egyik sem"
			}
		},
		icon_type_picker: {
			values: {
				"default": "Alapértelmezett típus",
				icon: "Ikon",
				"entity-picture": "Entitás kép",
				none: "Egyik sem"
			}
		},
		layout_picker: {
			values: {
				"default": "Alapértelmezet elrendezés",
				vertical: "Függőleges elrendezés",
				horizontal: "Vízszintes elrendezés"
			}
		},
		alignment_picker: {
			values: {
				"default": "Alapértelmezett rendezés",
				start: "Kezdete",
				end: "Vége",
				center: "Közepe",
				justify: "Sorkizárt"
			}
		}
	},
	card: {
		generic: {
			icon_color: "Ikon szín",
			layout: "Elrendezés",
			fill_container: "Tároló kitöltése",
			primary_info: "Elsődleges információ",
			secondary_info: "Másodlagos információ",
			icon_type: "Ikon típus",
			content_info: "Tartalom",
			use_entity_picture: "Entitás kép használata",
			collapsible_controls: "Vezérlők összezárása kikapcsolt állapotban",
			icon_animation: "Ikon animálása aktív állapotban"
		},
		light: {
			show_brightness_control: "Fényerő vezérlő",
			use_light_color: "Fény szín használata",
			show_color_temp_control: "Színhőmérséklet vezérlő",
			show_color_control: "Szín vezérlő",
			incompatible_controls: "Azok a vezérlők nem lesznek megjelenítve, amelyeket a fényforrás nem támogat."
		},
		fan: {
			show_percentage_control: "Százalékos vezérlő",
			show_oscillate_control: "Oszcilláció vezérlő"
		},
		cover: {
			show_buttons_control: "Vezérlő gombok",
			show_position_control: "Pozíció vezérlő"
		},
		alarm_control_panel: {
			show_keypad: "Billentyűzet mutatása"
		},
		template: {
			primary: "Elsődleges információ",
			secondary: "Másodlagos információ",
			multiline_secondary: "Másodlagost több sorba?",
			entity_extra: "Used in templates and actions",
			content: "Tartalom",
			badge_icon: "Jelvény ikon",
			badge_color: "Jelvény szín",
			picture: "Kép (helyettesíteni fogja az ikont)"
		},
		title: {
			title: "Fejléc",
			subtitle: "Alcím"
		},
		chips: {
			alignment: "Rendezés"
		},
		weather: {
			show_conditions: "Állapotok",
			show_temperature: "Hőmérséklet"
		},
		update: {
			show_buttons_control: "Vezérlő gombok"
		},
		vacuum: {
			commands: "Utasítások"
		},
		"media-player": {
			use_media_info: "Média infó használata",
			use_media_artwork: "Média borító használata",
			show_volume_level: "Hangerő mutatása",
			media_controls: "Média vezérlők",
			media_controls_list: {
				on_off: "Ki/bekapcsolás",
				shuffle: "Véletlen lejátszás",
				previous: "Előző szám",
				play_pause_stop: "Lejátszás/szünet/állj",
				next: "Következő szám",
				repeat: "Ismétlés módja"
			},
			volume_controls: "Hangerő vezérlők",
			volume_controls_list: {
				volume_buttons: "Hangerő gombok",
				volume_set: "Hangerő szint",
				volume_mute: "Némítás"
			}
		},
		lock: {
			lock: "Zár",
			unlock: "Nyit",
			open: "Nyitva"
		},
		humidifier: {
			show_target_humidity_control: "Páratartalom vezérlő"
		},
		climate: {
			show_temperature_control: "Hőmérséklet vezérlő",
			hvac_modes: "HVAC mód"
		}
	},
	chip: {
		sub_element_editor: {
			title: "Chip szerkesztő"
		},
		conditional: {
			chip: "Chip"
		},
		"chip-picker": {
			chips: "Chip-ek",
			add: "Chip hozzáadása",
			edit: "Szerkesztés",
			clear: "Ürítés",
			select: "Chip kiválasztása",
			types: {
				action: "Művelet",
				"alarm-control-panel": "Riasztó",
				back: "Vissza",
				conditional: "Feltételes",
				entity: "Entitás",
				light: "Fényforrás",
				menu: "Menü",
				template: "Sablon",
				weather: "Időjárás"
			}
		}
	}
};
var hu = {
	editor: editor$e
};

var hu$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  editor: editor$e,
  'default': hu
});

var editor$d = {
	form: {
		color_picker: {
			values: {
				"default": "Colore predefinito"
			}
		},
		info_picker: {
			values: {
				"default": "Informazione predefinita",
				name: "Nome",
				state: "Stato",
				"last-changed": "Ultimo Cambiamento",
				"last-updated": "Ultimo Aggiornamento",
				none: "Nessuno"
			}
		},
		icon_type_picker: {
			values: {
				"default": "Tipo predefinito",
				icon: "Icona",
				"entity-picture": "Immagine dell'entità",
				none: "Nessuna"
			}
		},
		layout_picker: {
			values: {
				"default": "Disposizione Predefinita",
				vertical: "Disposizione Verticale",
				horizontal: "Disposizione Orizzontale"
			}
		},
		alignment_picker: {
			values: {
				"default": "Allineamento predefinito",
				start: "Inizio",
				end: "Fine",
				center: "Centro",
				justify: "Giustificato"
			}
		}
	},
	card: {
		generic: {
			icon_color: "Colore dell'icona",
			layout: "Disposizione",
			fill_container: "Riempi il contenitore",
			primary_info: "Informazione primaria",
			secondary_info: "Informazione secondaria",
			icon_type: "Tipo icona",
			content_info: "Contenuto",
			use_entity_picture: "Usa l'immagine dell'entità",
			collapsible_controls: "Nascondi i controlli quando spento",
			icon_animation: "Anima l'icona quando attiva"
		},
		light: {
			use_light_color: "Usa il colore della luce",
			show_brightness_control: "Controllo luminosità",
			show_color_temp_control: "Controllo temperatura",
			show_color_control: "Controllo colore",
			incompatible_controls: "Alcuni controlli potrebbero non essere mostrati se la tua luce non li supporta."
		},
		fan: {
			show_percentage_control: "Controllo potenza",
			show_oscillate_control: "Controllo oscillazione"
		},
		cover: {
			show_buttons_control: "Pulsanti di controllo",
			show_position_control: "Controllo percentuale apertura",
			show_tilt_position_control: "Controllo percentuale inclinazione"
		},
		alarm_control_panel: {
			show_keypad: "Mostra il tastierino numerico"
		},
		template: {
			primary: "Informazione primaria",
			secondary: "Informazione secondaria",
			multiline_secondary: "Abilita frasi multilinea",
			entity_extra: "Usato in templates ed azioni",
			content: "Contenuto",
			badge_icon: "Icona del badge",
			badge_color: "Colore del badge",
			picture: "Immagine (sostituirà l'icona)"
		},
		title: {
			title: "Titolo",
			subtitle: "Sottotitolo"
		},
		chips: {
			alignment: "Allineamento"
		},
		weather: {
			show_conditions: "Condizioni",
			show_temperature: "Temperatura"
		},
		update: {
			show_buttons_control: "Pulsanti di controllo"
		},
		vacuum: {
			commands: "Comandi",
			commands_list: {
				on_off: "Accendi/Spegni"
			}
		},
		"media-player": {
			use_media_info: "Mostra le Informazioni Sorgente",
			use_media_artwork: "Usa la copertina della Sorgente",
			show_volume_level: "Mostra Volume",
			media_controls: "Controlli Media",
			media_controls_list: {
				on_off: "Accendi/Spegni",
				shuffle: "Riproduzione Casuale",
				previous: "Traccia Precedente",
				play_pause_stop: "Play/Pausa/Stop",
				next: "Traccia Successiva",
				repeat: "Loop"
			},
			volume_controls: "Controlli del Volume",
			volume_controls_list: {
				volume_buttons: "Bottoni del Volume",
				volume_set: "Livello del Volume",
				volume_mute: "Silenzia"
			}
		},
		lock: {
			lock: "Blocca",
			unlock: "Sblocca",
			open: "Aperto"
		},
		humidifier: {
			show_target_humidity_control: "Controllo umidità"
		},
		climate: {
			show_temperature_control: "Controllo della temperatura?",
			hvac_modes: "Modalità del termostato"
		}
	},
	chip: {
		sub_element_editor: {
			title: "Editor di chip"
		},
		conditional: {
			chip: "Chip"
		},
		"chip-picker": {
			chips: "Chips",
			add: "Aggiungi chip",
			edit: "Modifica",
			clear: "Rimuovi",
			select: "Seleziona chip",
			types: {
				action: "Azione",
				"alarm-control-panel": "Allarme",
				back: "Pulsante indietro",
				conditional: "Condizione",
				entity: "Entità",
				light: "Luce",
				menu: "Menù",
				template: "Template",
				weather: "Meteo"
			}
		}
	}
};
var it = {
	editor: editor$d
};

var it$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  editor: editor$d,
  'default': it
});

var editor$c = {
	form: {
		color_picker: {
			values: {
				"default": "Standard farge"
			}
		},
		info_picker: {
			values: {
				"default": "Standard informasjon",
				name: "Navn",
				state: "Tilstand",
				"last-changed": "Sist endret",
				"last-updated": "Sist oppdatert",
				none: "Ingen"
			}
		},
		layout_picker: {
			values: {
				"default": "Standardoppsett",
				vertical: "Vertikalt oppsett",
				horizontal: "Horisontalt oppsett"
			}
		},
		alignment_picker: {
			values: {
				"default": "Standard justering",
				start: "Start",
				end: "Slutt",
				center: "Senter",
				justify: "Bekreft"
			}
		}
	},
	card: {
		generic: {
			icon_color: "Ikon farge",
			layout: "Oppsett",
			primary_info: "Primærinformasjon",
			secondary_info: "Sekundærinformasjon",
			content_info: "Innhold",
			use_entity_picture: "Bruk enhetsbilde?",
			icon_animation: "Animer ikon når aktivt?"
		},
		light: {
			show_brightness_control: "Lysstyrkekontroll?",
			use_light_color: "Bruk lys farge",
			show_color_temp_control: "Temperatur fargekontroll?",
			show_color_control: "Fargekontroll?",
			incompatible_controls: "Noen kontroller vises kanskje ikke hvis lyset ditt ikke støtter denne funksjonen."
		},
		fan: {
			show_percentage_control: "Prosentvis kontroll?",
			show_oscillate_control: "Oscillerende kontroll?"
		},
		cover: {
			show_buttons_control: "Kontollere med knapper?",
			show_position_control: "Posisjonskontroll?"
		},
		template: {
			primary: "Primærinformasjon",
			secondary: "Sekundærinformasjon",
			multiline_secondary: "Multiline sekundær?",
			entity_extra: "Brukes i maler og handlinger",
			content: "Inhold"
		},
		title: {
			title: "Tittel",
			subtitle: "Undertekst"
		},
		chips: {
			alignment: "Justering"
		},
		weather: {
			show_conditions: "Forhold?",
			show_temperature: "Temperatur?"
		},
		vacuum: {
			commands: "Kommandoer"
		}
	},
	chip: {
		sub_element_editor: {
			title: "Chip redaktør"
		},
		conditional: {
			chip: "Chip"
		},
		"chip-picker": {
			chips: "Chips",
			add: "Legg til chip",
			edit: "Endre",
			clear: "Klare",
			select: "Velg chip",
			types: {
				action: "Handling",
				"alarm-control-panel": "Alarm",
				back: "Tilbake",
				conditional: "Betinget",
				entity: "Entitet",
				light: "Lys",
				menu: "Meny",
				template: "Mal",
				weather: "Vær"
			}
		}
	}
};
var nb = {
	editor: editor$c
};

var nb$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  editor: editor$c,
  'default': nb
});

var editor$b = {
	form: {
		color_picker: {
			values: {
				"default": "Standaard kleur"
			}
		},
		info_picker: {
			values: {
				"default": "Standaard informatie",
				name: "Naam",
				state: "Staat",
				"last-changed": "Laatst gewijzigd",
				"last-updated": "Laatst bijgewerkt",
				none: "Geen"
			}
		},
		icon_type_picker: {
			values: {
				"default": "Standaard icoon type",
				icon: "Icoon",
				"entity-picture": "Entiteit afbeelding",
				none: "Geen"
			}
		},
		layout_picker: {
			values: {
				"default": "Standaard lay-out",
				vertical: "Verticale lay-out",
				horizontal: "Horizontale lay-out"
			}
		},
		alignment_picker: {
			values: {
				"default": "Standaard uitlijning",
				start: "Begin",
				end: "Einde",
				center: "Midden",
				justify: "Uitlijnen "
			}
		}
	},
	card: {
		generic: {
			icon_color: "Icoon kleur",
			layout: "Lay-out",
			fill_container: "Vul container",
			primary_info: "Primaire informatie",
			secondary_info: "Secundaire informatie",
			icon_type: "Icoon type",
			content_info: "Inhoud",
			use_entity_picture: "Gebruik entiteit afbeelding",
			collapsible_controls: "Bedieningselementen verbergen wanneer uitgeschakeld",
			icon_animation: "Pictogram animeren indien actief"
		},
		light: {
			show_brightness_control: "Bediening helderheid",
			use_light_color: "Gebruik licht kleur",
			show_color_temp_control: "Bediening kleurtemperatuur",
			show_color_control: "Bediening kleur",
			incompatible_controls: "Sommige bedieningselementen worden mogelijk niet weergegeven als uw lamp deze functie niet ondersteunt."
		},
		fan: {
			show_percentage_control: "Bediening middels percentage",
			show_oscillate_control: "Bediening oscillatie"
		},
		cover: {
			show_buttons_control: "Toon knoppen",
			show_position_control: "Toon positie bediening",
			show_tilt_position_control: "Toon tilt control?"
		},
		alarm_control_panel: {
			show_keypad: "Toon toetsenbord"
		},
		template: {
			primary: "Primaire informatie",
			secondary: "Secundaire informatie",
			multiline_secondary: "Meerlijnig secundair?",
			entity_extra: "Gebruikt in sjablonen en acties",
			content: "Inhoud",
			badge_icon: "Badge icoon",
			badge_color: "Badge kleur",
			picture: "Afbeeling (zal het icoon vervangen)"
		},
		title: {
			title: "Titel",
			subtitle: "Ondertitel"
		},
		chips: {
			alignment: "Uitlijning"
		},
		weather: {
			show_conditions: "Weerbeeld",
			show_temperature: "Temperatuur"
		},
		update: {
			show_buttons_control: "Bedieningsknoppen?"
		},
		vacuum: {
			commands: "Commando's",
			commands_list: {
				on_off: "Zet aan/uit"
			}
		},
		"media-player": {
			use_media_info: "Gebruik media informatie",
			use_media_artwork: "Gebruik media omslag",
			show_volume_level: "Toon volumeniveau",
			media_controls: "Mediabediening",
			media_controls_list: {
				on_off: "zet aan/uit",
				shuffle: "Shuffle",
				previous: "Vorige nummer",
				play_pause_stop: "Speel/pauze/stop",
				next: "Volgende nummer",
				repeat: "Herhalen"
			},
			volume_controls: "Volumeregeling",
			volume_controls_list: {
				volume_buttons: "Volume knoppen",
				volume_set: "Volumeniveau",
				volume_mute: "Dempen"
			}
		},
		lock: {
			lock: "Vergrendel",
			unlock: "Ontgrendel",
			open: "Open"
		},
		humidifier: {
			show_target_humidity_control: "Vochtigheid controle?"
		},
		climate: {
			show_temperature_control: "Temperatuur controle?",
			hvac_modes: "HVAC Modes"
		}
	},
	chip: {
		sub_element_editor: {
			title: "Chip-editor"
		},
		conditional: {
			chip: "Chip"
		},
		"chip-picker": {
			chips: "Chips",
			add: "Toevoegen chip",
			edit: "Bewerk",
			clear: "Maak leeg",
			select: "Selecteer chip",
			types: {
				action: "Actie",
				"alarm-control-panel": "Alarm",
				back: "Terug",
				conditional: "Voorwaardelijk",
				entity: "Entiteit",
				light: "Licht",
				menu: "Menu",
				template: "Sjabloon",
				weather: "Weer"
			}
		}
	}
};
var nl = {
	editor: editor$b
};

var nl$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  editor: editor$b,
  'default': nl
});

var editor$a = {
	form: {
		color_picker: {
			values: {
				"default": "Domyślny kolor"
			}
		},
		info_picker: {
			values: {
				"default": "Domyślne informacje",
				name: "Nazwa",
				state: "Stan",
				"last-changed": "Ostatnia zmiana",
				"last-updated": "Ostatnia aktualizacja",
				none: "Brak"
			}
		},
		icon_type_picker: {
			values: {
				"default": "Domyślny typ",
				icon: "Ikona",
				"entity-picture": "Obraz encji",
				none: "Brak"
			}
		},
		layout_picker: {
			values: {
				"default": "Układ domyślny",
				vertical: "Układ pionowy",
				horizontal: "Układ poziomy"
			}
		},
		alignment_picker: {
			values: {
				"default": "Wyrównanie domyślne",
				start: "Wyrównanie do lewej",
				end: "Wyrównanie do prawej",
				center: "Wyśrodkowanie",
				justify: "Justowanie"
			}
		}
	},
	card: {
		generic: {
			icon_color: "Kolor ikony",
			layout: "Układ",
			fill_container: "Wypełnij zawartością",
			primary_info: "Informacje główne",
			secondary_info: "Informacje drugorzędne",
			icon_type: "Typ ikony",
			content_info: "Zawartość",
			use_entity_picture: "Użyć obrazu encji?",
			collapsible_controls: "Zwiń sterowanie, jeśli wyłączone",
			icon_animation: "Animować, gdy aktywny?"
		},
		light: {
			show_brightness_control: "Sterowanie jasnością?",
			use_light_color: "Użyj koloru światła",
			show_color_temp_control: "Sterowanie temperaturą światła?",
			show_color_control: "Sterowanie kolorami?",
			incompatible_controls: "Niektóre funkcje są niewidoczne, jeśli światło ich nie obsługuje."
		},
		fan: {
			show_percentage_control: "Sterowanie procentowe?",
			show_oscillate_control: "Sterowanie oscylacją?"
		},
		cover: {
			show_buttons_control: "Przyciski sterujące?",
			show_position_control: "Sterowanie położeniem?",
			show_tilt_position_control: "Sterowanie poziomem otwarcia?"
		},
		alarm_control_panel: {
			show_keypad: "Wyświetl klawiaturę"
		},
		template: {
			primary: "Informacje główne",
			secondary: "Informacje drugorzędne",
			multiline_secondary: "Drugorzędne wielowierszowe?",
			entity_extra: "Używane w szablonach i akcjach",
			content: "Zawartość",
			badge_icon: "Ikona odznaki",
			badge_color: "Kolor odznaki",
			picture: "Obraz (zamiast ikony)"
		},
		title: {
			title: "Tytuł",
			subtitle: "Podtytuł"
		},
		chips: {
			alignment: "Wyrównanie"
		},
		weather: {
			show_conditions: "Warunki?",
			show_temperature: "Temperatura?"
		},
		update: {
			show_buttons_control: "Przyciski sterujące?"
		},
		vacuum: {
			commands: "Polecenia"
		},
		"media-player": {
			use_media_info: "Użyj informacji o multimediach",
			use_media_artwork: "Użyj okładek multimediów",
			show_volume_level: "Wyświetl poziom głośności",
			media_controls: "Sterowanie multimediami",
			media_controls_list: {
				on_off: "Włącz/wyłącz",
				shuffle: "Losowo",
				previous: "Poprzednie nagranie",
				play_pause_stop: "Odtwórz/Pauza/Zatrzymaj",
				next: "Następne nagranie",
				repeat: "Powtarzanie"
			},
			volume_controls: "Sterowanie głośnością",
			volume_controls_list: {
				volume_buttons: "Przyciski głośności",
				volume_set: "Poziom głośności",
				volume_mute: "Wycisz"
			}
		},
		lock: {
			lock: "Zablokuj",
			unlock: "Odblokuj",
			open: "Otwórz"
		},
		humidifier: {
			show_target_humidity_control: "Sterowanie wilgotnością?"
		},
		climate: {
			show_temperature_control: "Sterowanie temperaturą?",
			hvac_modes: "Tryby urządzenia"
		}
	},
	chip: {
		sub_element_editor: {
			title: "Edytor czipów"
		},
		conditional: {
			chip: "Czip"
		},
		"chip-picker": {
			chips: "Czipy",
			add: "Dodaj czip",
			edit: "Edytuj",
			clear: "Wyczyść",
			select: "Wybierz czip",
			types: {
				action: "Akcja",
				"alarm-control-panel": "Alarm",
				back: "Wstecz",
				conditional: "Warunkowy",
				entity: "Encja",
				light: "Światło",
				menu: "Menu",
				template: "Szablon",
				weather: "Pogoda"
			}
		}
	}
};
var pl = {
	editor: editor$a
};

var pl$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  editor: editor$a,
  'default': pl
});

var editor$9 = {
	form: {
		color_picker: {
			values: {
				"default": "Cor padrão"
			}
		},
		info_picker: {
			values: {
				"default": "Informações padrão",
				name: "Nome",
				state: "Estado",
				"last-changed": "Última alteração",
				"last-updated": "Última atualização",
				none: "Nenhum"
			}
		},
		layout_picker: {
			values: {
				"default": "Layout padrão",
				vertical: "Layout vertical",
				horizontal: "Layout horizontal"
			}
		},
		alignment_picker: {
			values: {
				"default": "Padrão (inicio)",
				end: "Final",
				center: "Centro",
				justify: "Justificado"
			}
		}
	},
	card: {
		generic: {
			icon_color: "Cor do ícone?",
			layout: "Layout",
			primary_info: "Informações primárias",
			secondary_info: "Informações secundárias",
			use_entity_picture: "Usar imagem da entidade?",
			icon_animation: "Animar ícone quando ativo?"
		},
		light: {
			show_brightness_control: "Mostrar controle de brilho?",
			use_light_color: "Usar cor da luz?",
			show_color_temp_control: "Mostrar controle de temperatura?",
			show_color_control: "Mostrar controle de cor?",
			incompatible_controls: "Alguns controles podem não ser exibidos se sua luz não suportar o recurso."
		},
		fan: {
			show_percentage_control: "Mostrar controle de porcentagem?",
			show_oscillate_control: "Mostrar controle de oscilação?"
		},
		cover: {
			show_buttons_control: "Mostrar botões?",
			show_position_control: "Mostrar controle de posição?"
		},
		template: {
			primary: "Informações primárias",
			secondary: "Informações secundárias",
			multiline_secondary: "Multilinha secundária?",
			content: "Conteúdo"
		},
		title: {
			title: "Título",
			subtitle: "Subtítulo"
		},
		chips: {
			alignment: "Alinhamento"
		},
		weather: {
			show_conditions: "Condições?",
			show_temperature: "Temperatura?"
		}
	},
	chip: {
		sub_element_editor: {
			title: "Editor de fichas"
		},
		conditional: {
			chip: "Ficha"
		},
		"chip-picker": {
			chips: "Fichas",
			add: "Adicionar ficha",
			edit: "Editar",
			clear: "Limpar",
			select: "Selecionar ficha",
			types: {
				action: "Ação",
				"alarm-control-panel": "Alarme",
				back: "Voltar",
				conditional: "Condicional",
				entity: "Entidade",
				light: "Iluminação",
				menu: "Menu",
				template: "Modelo",
				weather: "Clima"
			}
		}
	}
};
var ptBR = {
	editor: editor$9
};

var pt_BR = /*#__PURE__*/Object.freeze({
  __proto__: null,
  editor: editor$9,
  'default': ptBR
});

var editor$8 = {
	form: {
		color_picker: {
			values: {
				"default": "Cor padrão"
			}
		},
		info_picker: {
			values: {
				"default": "Informações padrão",
				name: "Nome",
				state: "Estado",
				"last-changed": "Última alteração",
				"last-updated": "Última atualização",
				none: "Nenhum"
			}
		},
		layout_picker: {
			values: {
				"default": "Layout padrão",
				vertical: "Layout vertical",
				horizontal: "Layout horizontal"
			}
		},
		alignment_picker: {
			values: {
				"default": "Padrão (inicio)",
				end: "Fim",
				center: "Centrado",
				justify: "Justificado"
			}
		}
	},
	card: {
		generic: {
			icon_color: "Cor do ícone?",
			layout: "Layout",
			primary_info: "Informações primárias",
			secondary_info: "Informações secundárias",
			use_entity_picture: "Usar imagem da entidade?",
			icon_animation: "Animar ícone quando ativo?"
		},
		light: {
			show_brightness_control: "Mostrar controle de brilho?",
			use_light_color: "Usar cor da luz?",
			show_color_temp_control: "Mostrar controle de temperatura?",
			show_color_control: "Mostrar controle de cor?",
			incompatible_controls: "Alguns controles podem não ser exibidos se a luz não suportar o recurso."
		},
		fan: {
			show_percentage_control: "Mostrar controle de porcentagem?",
			show_oscillate_control: "Mostrar controle de oscilação?"
		},
		cover: {
			show_buttons_control: "Mostrar botões?",
			show_position_control: "Mostrar controle de posição?"
		},
		template: {
			primary: "Informações primárias",
			secondary: "Informações secundárias",
			multiline_secondary: "Multilinha secundária?",
			content: "Conteúdo"
		},
		title: {
			title: "Título",
			subtitle: "Subtítulo"
		},
		chips: {
			alignment: "Alinhamento"
		},
		weather: {
			show_conditions: "Condições?",
			show_temperature: "Temperatura?"
		}
	},
	chip: {
		sub_element_editor: {
			title: "Editor de fichas"
		},
		conditional: {
			chip: "Ficha"
		},
		"chip-picker": {
			chips: "Fichas",
			add: "Adicionar ficha",
			edit: "Editar",
			clear: "Limpar",
			select: "Selecionar ficha",
			types: {
				action: "Ação",
				"alarm-control-panel": "Alarme",
				back: "Voltar",
				conditional: "Condicional",
				entity: "Entidade",
				light: "Iluminação",
				menu: "Menu",
				template: "Modelo",
				weather: "Clima"
			}
		}
	}
};
var ptPT = {
	editor: editor$8
};

var pt_PT = /*#__PURE__*/Object.freeze({
  __proto__: null,
  editor: editor$8,
  'default': ptPT
});

var editor$7 = {
	form: {
		color_picker: {
			values: {
				"default": "Culoare implicită"
			}
		},
		info_picker: {
			values: {
				"default": "Informație implicită",
				name: "Nume",
				state: "Stare",
				"last-changed": "Ultima modificare",
				"last-updated": "Ultima actulizare",
				none: "Niciuna"
			}
		},
		icon_type_picker: {
			values: {
				"default": "Tip implicit",
				icon: "Pictogramă",
				"entity-picture": "Imagine",
				none: "Niciuna"
			}
		},
		layout_picker: {
			values: {
				"default": "Aranjare implicită",
				vertical: "Verticală",
				horizontal: "Orizontală"
			}
		},
		alignment_picker: {
			values: {
				"default": "Aliniere implicită",
				start: "Stânga",
				end: "Dreapta",
				center: "Centrat",
				justify: "Umplere"
			}
		}
	},
	card: {
		generic: {
			icon_color: "Culoare pictogramă",
			layout: "Aranjare",
			fill_container: "Umplere container",
			primary_info: "Informație principală",
			secondary_info: "Informație secundară",
			icon_type: "Tip pictogramă",
			content_info: "Conținut",
			use_entity_picture: "Imagine?",
			collapsible_controls: "Restrângere la dezactivare"
		},
		light: {
			show_brightness_control: "Comandă pentru strălucire?",
			use_light_color: "Folosește culoarea luminii",
			show_color_temp_control: "Comandă pentru temperatură de culoare?",
			show_color_control: "Comandă pentru culoare?",
			incompatible_controls: "Unele comenzi ar putea să nu fie afișate dacă lumina nu suportă această caracteristică."
		},
		fan: {
			icon_animation: "Animare pictograma la activare?",
			show_percentage_control: "Comandă procent?",
			show_oscillate_control: "Comandă oscilație?"
		},
		cover: {
			show_buttons_control: "Comenzi pentru control?",
			show_position_control: "Comandă pentru poziție?",
			show_tilt_position_control: "Comandă pentru înclinare?"
		},
		alarm_control_panel: {
			show_keypad: "Arată tastatura"
		},
		template: {
			primary: "Informație principală",
			secondary: "Informație secundară",
			multiline_secondary: "Informație secundară pe mai multe linii?",
			entity_extra: "Folosită în șabloane și acțiuni",
			content: "Conținut",
			badge_icon: "Pictogramă insignă",
			badge_color: "Culoare insignă",
			picture: "Imagine (inlocuiește pictograma)"
		},
		title: {
			title: "Titlu",
			subtitle: "Subtitlu"
		},
		chips: {
			alignment: "Aliniere"
		},
		weather: {
			show_conditions: "Condiții?",
			show_temperature: "Temperatură?"
		},
		update: {
			show_buttons_control: "Comenzi control?"
		},
		vacuum: {
			commands: "Comenzi"
		},
		"media-player": {
			use_media_info: "Informații media",
			use_media_artwork: "Grafică media",
			show_volume_level: "Nivel volum",
			media_controls: "Comenzi media",
			media_controls_list: {
				on_off: "Pornit/Oprit",
				shuffle: "Amestecare",
				previous: "Pista anterioară",
				play_pause_stop: "Redare/Pauză/Stop",
				next: "Pista următoare",
				repeat: "Mod repetare"
			},
			volume_controls: "Comenzi volum",
			volume_controls_list: {
				volume_buttons: "Comenzi volum",
				volume_set: "Nivel volum",
				volume_mute: "Dezactivare sunet"
			}
		},
		lock: {
			lock: "Încuie",
			unlock: "Descuie",
			open: "Deschide"
		},
		humidifier: {
			show_target_humidity_control: "Comenzi umiditate?"
		},
		climate: {
			show_temperature_control: "Comenzi temperatură?",
			hvac_modes: "Moduri HVAC"
		}
	},
	chip: {
		sub_element_editor: {
			title: "Editor jeton"
		},
		conditional: {
			chip: "Jeton"
		},
		"chip-picker": {
			chips: "Jetoane",
			add: "Adaugă jeton",
			edit: "Modifică",
			clear: "Șterge",
			select: "Alege jeton",
			types: {
				action: "Acțiune",
				"alarm-control-panel": "Alarmă",
				back: "Înapoi",
				conditional: "Condițional",
				entity: "Entitate",
				light: "Lumină",
				menu: "Meniu",
				template: "Șablon",
				weather: "Vreme"
			}
		}
	}
};
var ro = {
	editor: editor$7
};

var ro$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  editor: editor$7,
  'default': ro
});

var editor$6 = {
	form: {
		color_picker: {
			values: {
				"default": "Цвет по-умолчанию"
			}
		},
		info_picker: {
			values: {
				"default": "По-умолчанию",
				name: "Имя",
				state: "Статус",
				"last-changed": "Последнее изменение",
				"last-updated": "Последнее обновление",
				none: "Нет"
			}
		},
		icon_type_picker: {
			values: {
				"default": "По-умолчанию",
				icon: "Иконка",
				"entity-picture": "Изображение",
				none: "Нет"
			}
		},
		layout_picker: {
			values: {
				"default": "Расположение по-умолчанию",
				vertical: "Вертикальное расположение",
				horizontal: "Горизонтальное расположение"
			}
		},
		alignment_picker: {
			values: {
				"default": "Выравнивание по-умолчанию",
				start: "По правому краю",
				end: "По левому краю",
				center: "По-центру",
				justify: "На всю ширину"
			}
		}
	},
	card: {
		generic: {
			icon_color: "Цвет иконки",
			layout: "Расположение",
			fill_container: "Заполнение",
			primary_info: "Основная информация",
			secondary_info: "Второстепенная информация",
			icon_type: "Тип иконки",
			content_info: "Содержимое",
			use_entity_picture: "Использовать изображение объекта?",
			collapsible_controls: "Сворачивать элементы управления при выключении"
		},
		light: {
			show_brightness_control: "Управлять яркостью?",
			use_light_color: "Использовать текущий цвет света",
			show_color_temp_control: "Управлять цветовой температурой?",
			show_color_control: "Управлять цветом?",
			incompatible_controls: "Некоторые элементы управления могут не отображаться, если ваш светильник не поддерживает эти функции."
		},
		fan: {
			icon_animation: "Анимировать иконку когда включено?",
			show_percentage_control: "Управлять процентами?",
			show_oscillate_control: "Oscillate control?"
		},
		cover: {
			show_buttons_control: "Добавить кнопки управления?",
			show_position_control: "Управлять позицией?",
			show_tilt_position_control: "Управлять наклоном?"
		},
		alarm_control_panel: {
			show_keypad: "Показ клавиатуры"
		},
		template: {
			primary: "Основная информация",
			secondary: "Второстепенная информация",
			multiline_secondary: "Многострочная Второстепенная информация?",
			entity_extra: "Используется в шаблонах и действиях",
			content: "Содержимое",
			badge_icon: "Иконка значка",
			badge_color: "Цвет значка",
			picture: "Изображение (заменить иконку)"
		},
		title: {
			title: "Заголовок",
			subtitle: "Подзаголовок"
		},
		chips: {
			alignment: "Выравнивание"
		},
		weather: {
			show_conditions: "Условия?",
			show_temperature: "Температура?"
		},
		update: {
			show_buttons_control: "Кнопки управления?"
		},
		vacuum: {
			commands: "Команды"
		},
		"media-player": {
			use_media_info: "Использовать информацию с медиа-устройства",
			use_media_artwork: "Использовать обложку с медиа-устройства",
			show_volume_level: "Показать уровень громкости",
			media_controls: "Управление медиа-устройством",
			media_controls_list: {
				on_off: "Включение/выключение",
				shuffle: "Перемешивание",
				previous: "Предыдущий трек",
				play_pause_stop: "Воспроизведение/пауза/остановка",
				next: "Следующий трек",
				repeat: "Режим повтора"
			},
			volume_controls: "Регулятор громкости",
			volume_controls_list: {
				volume_buttons: "Кнопки громкости",
				volume_set: "Уровень громкости",
				volume_mute: "Без звука"
			}
		},
		lock: {
			lock: "Закрыто",
			unlock: "Разблокировано",
			open: "Открыто"
		},
		humidifier: {
			show_target_humidity_control: "Управлять целевым уровенем влажности?"
		},
		climate: {
			show_temperature_control: "Управлять целевой температурой?",
			hvac_modes: "Режимы работы"
		}
	},
	chip: {
		sub_element_editor: {
			title: "Редактор мини-карточек"
		},
		conditional: {
			chip: "Мини-карточка"
		},
		"chip-picker": {
			chips: "Мини-карточки",
			add: "Добавить мини-карточку",
			edit: "Изменить",
			clear: "Очистить",
			select: "Выбрать мини-карточку",
			types: {
				action: "Действие",
				"alarm-control-panel": "Тревога",
				back: "Назад",
				conditional: "Условия",
				entity: "Объект",
				light: "Освещение",
				menu: "Меню",
				template: "Шаблон",
				weather: "Погода"
			}
		}
	}
};
var ru = {
	editor: editor$6
};

var ru$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  editor: editor$6,
  'default': ru
});

var editor$5 = {
	form: {
		color_picker: {
			values: {
				"default": "Predvolená farba"
			}
		},
		info_picker: {
			values: {
				"default": "Predvolené informácie",
				name: "Názov",
				state: "Stav",
				"last-changed": "Posledná zmena",
				"last-updated": "Posledná aktualizácia",
				none: "Žiadna"
			}
		},
		icon_type_picker: {
			values: {
				"default": "Predvolený typ",
				icon: "Ikona",
				"entity-picture": "Obrázok entity",
				none: "Žiadny"
			}
		},
		layout_picker: {
			values: {
				"default": "Predvolené rozloženie",
				vertical: "Zvislé rozloženie",
				horizontal: "Vodorovné rozloženie"
			}
		},
		alignment_picker: {
			values: {
				"default": "Predvolené zarovnanie",
				start: "Začiatok",
				end: "Koniec",
				center: "Stred",
				justify: "Vyplniť"
			}
		}
	},
	card: {
		generic: {
			icon_color: "Farba ikony",
			layout: "Rozloženie",
			fill_container: "Vyplniť priestor",
			primary_info: "Základné info",
			secondary_info: "Doplnkové info",
			icon_type: "Typ ikony",
			content_info: "Obsah",
			use_entity_picture: "Použiť obrázok entity?",
			collapsible_controls: "Skryť ovládanie v stave VYP.",
			icon_animation: "Animovaná ikona v stave ZAP?"
		},
		light: {
			show_brightness_control: "Ovládanie jasu?",
			use_light_color: "Použiť farbu svetla",
			show_color_temp_control: "Ovládanie teploty?",
			show_color_control: "Ovládanie farby?",
			incompatible_controls: "Niektoré ovládacie prvky sa nemusia zobraziť, pokiaľ ich svetlo nepodporuje."
		},
		fan: {
			show_percentage_control: "Ovládanie rýchlosti v percentách?",
			show_oscillate_control: "Ovládanie oscilácie?"
		},
		cover: {
			show_buttons_control: "Zobraziť ovládacie tlačidlá?",
			show_position_control: "Ovládanie pozície?",
			show_tilt_position_control: "Ovládanie natočenia?"
		},
		alarm_control_panel: {
			show_keypad: "Zobraziť klávesnicu"
		},
		template: {
			primary: "Základné info",
			secondary: "Doplnkové info",
			multiline_secondary: "Viacriadkové doplnkové info?",
			entity_extra: "Použitá v šablónach a akciách",
			content: "Obsah",
			badge_icon: "Ikona odznaku",
			badge_color: "Farba odznaku",
			picture: "Obrázok (nahrádza ikonu)"
		},
		title: {
			title: "Nadpis",
			subtitle: "Podnadpis"
		},
		chips: {
			alignment: "Zarovnanie"
		},
		weather: {
			show_conditions: "Zobraziť podmienky?",
			show_temperature: "Zobraziť teplotu?"
		},
		update: {
			show_buttons_control: "Zobraziť ovládacie tlačidlá?"
		},
		vacuum: {
			commands: "Príkazy"
		},
		"media-player": {
			use_media_info: "Použiť info o médiu",
			use_media_artwork: "Použiť obrázok z média",
			show_volume_level: "Zobraziť úroveň hlasitosti",
			media_controls: "Ovládanie média",
			media_controls_list: {
				on_off: "Zap / Vyp",
				shuffle: "Premiešať",
				previous: "Predchádzajúca",
				play_pause_stop: "Spustiť/pauza/stop",
				next: "Ďalšia",
				repeat: "Opakovať"
			},
			volume_controls: "Ovládanie hlasitosti",
			volume_controls_list: {
				volume_buttons: "Tlačidlá hlasitosti",
				volume_set: "Úroveň hlasitosti",
				volume_mute: "Stlmiť"
			}
		},
		lock: {
			lock: "Zamknuté",
			unlock: "Odomknuté",
			open: "Otvorené"
		},
		humidifier: {
			show_target_humidity_control: "Ovládanie vlhkosti?"
		},
		climate: {
			show_temperature_control: "Ovládanie teploty?",
			hvac_modes: "HVAC mód"
		}
	},
	chip: {
		sub_element_editor: {
			title: "Editor štítkov"
		},
		conditional: {
			chip: "Štítok"
		},
		"chip-picker": {
			chips: "Štítky",
			add: "Pridať štítok",
			edit: "Editovať",
			clear: "Vymazať",
			select: "Vybrať štítok",
			types: {
				action: "Akcia",
				"alarm-control-panel": "Alarm",
				back: "Späť",
				conditional: "Podmienka",
				entity: "Entita",
				light: "Svetlo",
				menu: "Menu",
				template: "Šablóna",
				weather: "Počasie"
			}
		}
	}
};
var sk = {
	editor: editor$5
};

var sk$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  editor: editor$5,
  'default': sk
});

var editor$4 = {
	form: {
		color_picker: {
			values: {
				"default": "Standardfärg"
			}
		},
		info_picker: {
			values: {
				"default": "Förvald information",
				name: "Namn",
				state: "Status",
				"last-changed": "Sist ändrad",
				"last-updated": "Sist uppdaterad",
				none: "Ingen"
			}
		},
		layout_picker: {
			values: {
				"default": "Standard",
				vertical: "Vertikal",
				horizontal: "Horisontell"
			}
		},
		alignment_picker: {
			values: {
				"default": "Standard (början)",
				end: "Slutet",
				center: "Centrerad",
				justify: "Anpassa"
			}
		}
	},
	card: {
		generic: {
			icon_color: "Ikonens färg",
			layout: "Layout",
			primary_info: "Primär information",
			secondary_info: "Sekundär information",
			use_entity_picture: "Använd enheten bild?",
			icon_animation: "Animera ikonen när fläkten är på?"
		},
		light: {
			show_brightness_control: "Styr ljushet?",
			use_light_color: "Styr ljusets färg",
			show_color_temp_control: "Styr färgtemperatur?",
			show_color_control: "Styr färg?",
			incompatible_controls: "Kontroller som inte stöds av enheten kommer inte visas."
		},
		fan: {
			show_percentage_control: "Procentuell kontroll?",
			show_oscillate_control: "Kontroll för oscillera?"
		},
		cover: {
			show_buttons_control: "Visa kontrollknappar?",
			show_position_control: "Visa positionskontroll?"
		},
		template: {
			primary: "Primär information",
			secondary: "Sekundär information",
			multiline_secondary: "Sekundär med flera rader?",
			content: "Innehåll"
		},
		title: {
			title: "Rubrik",
			subtitle: "Underrubrik"
		},
		chips: {
			alignment: "Justering"
		},
		weather: {
			show_conditions: "Förhållanden?",
			show_temperature: "Temperatur?"
		}
	},
	chip: {
		sub_element_editor: {
			title: "Chipredigerare"
		},
		conditional: {
			chip: "Chip"
		},
		"chip-picker": {
			chips: "Chips",
			add: "Lägg till chip",
			edit: "Redigera",
			clear: "Rensa",
			select: "Välj chip",
			types: {
				action: "Händelse",
				"alarm-control-panel": "Alarm",
				back: "Bakåt",
				conditional: "Villkorad",
				entity: "Enhet",
				light: "Ljus",
				menu: "Meny",
				template: "Mall",
				weather: "Väder"
			}
		}
	}
};
var sv = {
	editor: editor$4
};

var sv$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  editor: editor$4,
  'default': sv
});

var editor$3 = {
	form: {
		color_picker: {
			values: {
				"default": "Varsayılan renk"
			}
		},
		info_picker: {
			values: {
				"default": "Varsayılan bilgi",
				name: "İsim",
				state: "Durum",
				"last-changed": "Son Değişim",
				"last-updated": "Son Güncelleme",
				none: "None"
			}
		},
		layout_picker: {
			values: {
				"default": "Varsayılan düzen",
				vertical: "Dikey düzen",
				horizontal: "Yatay düzen"
			}
		},
		alignment_picker: {
			values: {
				"default": "Varsayılan hizalama",
				start: "Sola yasla",
				end: "Sağa yasla",
				center: "Ortala",
				justify: "İki yana yasla"
			}
		}
	},
	card: {
		generic: {
			icon_color: "Simge renki",
			layout: "Düzen",
			primary_info: "Birinci bilgi",
			secondary_info: "İkinci bilgi",
			content_info: "İçerik",
			use_entity_picture: "Varlık resmi kullanılsın",
			icon_animation: "Aktif olduğunda simgeyi hareket ettir"
		},
		light: {
			show_brightness_control: "Parlaklık kontrolü",
			use_light_color: "Işık rengini kullan",
			show_color_temp_control: "Renk ısısı kontrolü",
			show_color_control: "Renk kontrolü",
			incompatible_controls: "Kullandığınız lamba bu özellikleri desteklemiyorsa bazı kontroller görüntülenemeyebilir."
		},
		fan: {
			show_percentage_control: "Yüzde kontrolü",
			show_oscillate_control: "Salınım kontrolü"
		},
		cover: {
			show_buttons_control: "Düğme kontrolleri",
			show_position_control: "Pozisyon kontrolü"
		},
		template: {
			primary: "Birinci bilgi",
			secondary: "İkinci bilgi",
			multiline_secondary: "İkinci bilgi çok satır olsun",
			entity_extra: "Şablonlarda ve eylemlerde kullanılsın",
			content: "İçerik"
		},
		title: {
			title: "Başlık",
			subtitle: "Altbaşlık"
		},
		chips: {
			alignment: "Hizalama"
		},
		weather: {
			show_conditions: "Hava koşulu",
			show_temperature: "Sıcaklık"
		},
		update: {
			show_buttons_control: "Düğme kontrolü"
		},
		vacuum: {
			commands: "Komutlar"
		}
	},
	chip: {
		sub_element_editor: {
			title: "Chip düzenleyici"
		},
		conditional: {
			chip: "Chip"
		},
		"chip-picker": {
			chips: "Chips",
			add: "Chip ekle",
			edit: "Düzenle",
			clear: "Temizle",
			select: "Chip seç",
			types: {
				action: "Eylem",
				"alarm-control-panel": "Alarm",
				back: "Geri",
				conditional: "Koşullu",
				entity: "Varlık",
				light: "Işık",
				menu: "Menü",
				template: "Şablon",
				weather: "Hava Durumu"
			}
		}
	}
};
var tr = {
	editor: editor$3
};

var tr$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  editor: editor$3,
  'default': tr
});

var editor$2 = {
	form: {
		color_picker: {
			values: {
				"default": "Màu mặc định"
			}
		},
		info_picker: {
			values: {
				"default": "Thông tin mặc định",
				name: "Tên",
				state: "Trạng thái",
				"last-changed": "Lần cuối thay đổi",
				"last-updated": "Lần cuối cập nhật",
				none: "Rỗng"
			}
		},
		layout_picker: {
			values: {
				"default": "Bố cục mặc định",
				vertical: "Bố cục dọc",
				horizontal: "Bố cục ngang"
			}
		},
		alignment_picker: {
			values: {
				"default": "Căn chỉnh mặc định",
				start: "Căn đầu",
				end: "Căn cuối",
				center: "Căn giữa",
				justify: "Căn hai bên"
			}
		}
	},
	card: {
		generic: {
			icon_color: "Màu biểu tượng",
			layout: "Bố cục",
			fill_container: "Làm đầy",
			primary_info: "Thông tin chính",
			secondary_info: "Thông tin phụ",
			content_info: "Nội dung",
			use_entity_picture: "Dùng ảnh của thực thể?",
			collapsible_controls: "Thu nhỏ điều kiển khi tắt",
			icon_animation: "Biểu tượng hoạt ảnh khi hoạt động?"
		},
		light: {
			show_brightness_control: "Điều khiển độ sáng?",
			use_light_color: "Dùng ánh sáng màu",
			show_color_temp_control: "Điều khiển nhiệt độ màu?",
			show_color_control: "Điều khiển màu sắc?",
			incompatible_controls: "Một số màu sẽ không được hiển thị nếu đèn của bạn không hỗ trợ tính năng này."
		},
		fan: {
			show_percentage_control: "Điều khiển dạng phần trăm?",
			show_oscillate_control: "Điều khiển xoay?"
		},
		cover: {
			show_buttons_control: "Nút điều khiển?",
			show_position_control: "Điều khiển vị trí?"
		},
		alarm_control_panel: {
			show_keypad: "Hiện bàn phím"
		},
		template: {
			primary: "Thông tin chính",
			secondary: "Thông tin phụ",
			multiline_secondary: "Nhiều dòng thông tin phụ?",
			entity_extra: "Được sử dụng trong mẫu và hành động",
			content: "Nội dung"
		},
		title: {
			title: "Tiêu đề",
			subtitle: "Phụ đề"
		},
		chips: {
			alignment: "Căn chỉnh"
		},
		weather: {
			show_conditions: "Điều kiện?",
			show_temperature: "Nhiệt độ?"
		},
		update: {
			show_buttons_control: "Nút điều khiển?"
		},
		vacuum: {
			commands: "Mệnh lệnh"
		},
		"media-player": {
			use_media_info: "Dùng thông tin đa phương tiện",
			use_media_artwork: "Dùng ảnh đa phương tiện",
			media_controls: "Điều khiển đa phương tiện",
			media_controls_list: {
				on_off: "Bật/Tắt",
				shuffle: "Xáo trộn",
				previous: "Bài trước",
				play_pause_stop: "Phát/Tạm dừng/Dừng",
				next: "Bài tiếp theo",
				repeat: "Chế độ lặp lại"
			},
			volume_controls: "Điều khiển âm lượng",
			volume_controls_list: {
				volume_buttons: "Nút âm lượng",
				volume_set: "Mức âm lượng",
				volume_mute: "Im lặng"
			}
		},
		lock: {
			lock: "Khóa",
			unlock: "Mở khóa",
			open: "Mở"
		}
	},
	chip: {
		sub_element_editor: {
			title: "Chỉnh sửa chip"
		},
		conditional: {
			chip: "Chip"
		},
		"chip-picker": {
			chips: "Các chip",
			add: "Thêm chip",
			edit: "Chỉnh sửa",
			clear: "Làm mới",
			select: "Chọn chip",
			types: {
				action: "Hành động",
				"alarm-control-panel": "Báo động",
				back: "Quay về",
				conditional: "Điều kiện",
				entity: "Thực thể",
				light: "Đèn",
				menu: "Menu",
				template: "Mẫu",
				weather: "Thời tiết"
			}
		}
	}
};
var vi = {
	editor: editor$2
};

var vi$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  editor: editor$2,
  'default': vi
});

var editor$1 = {
	form: {
		color_picker: {
			values: {
				"default": "默认颜色"
			}
		},
		info_picker: {
			values: {
				"default": "默认信息",
				name: "名称",
				state: "状态",
				"last-changed": "变更时间",
				"last-updated": "更新时间",
				none: "无"
			}
		},
		layout_picker: {
			values: {
				"default": "默认布局",
				vertical: "垂直布局",
				horizontal: "水平布局"
			}
		},
		alignment_picker: {
			values: {
				"default": "默认 (左对齐)",
				end: "右对齐",
				center: "居中对齐",
				justify: "两端对齐"
			}
		}
	},
	card: {
		generic: {
			icon_color: "图标颜色",
			primary_info: "首要信息",
			secondary_info: "次要信息",
			use_entity_picture: "使用实体图片?",
			icon_animation: "激活时使用动态图标?"
		},
		light: {
			show_brightness_control: "亮度控制?",
			use_light_color: "使用灯光颜色",
			show_color_temp_control: "色温控制?",
			show_color_control: "颜色控制?",
			incompatible_controls: "设备不支持的控制器将不会显示。"
		},
		fan: {
			show_percentage_control: "百分比控制?",
			show_oscillate_control: "摆动控制?"
		},
		cover: {
			show_buttons_control: "按钮控制?",
			show_position_control: "位置控制?"
		},
		template: {
			primary: "首要信息",
			secondary: "次要信息",
			multiline_secondary: "多行次要信息?",
			content: "内容"
		},
		title: {
			title: "标题",
			subtitle: "子标题"
		},
		chips: {
			alignment: "对齐"
		},
		weather: {
			show_conditions: "条件?",
			show_temperature: "温度?"
		}
	},
	chip: {
		sub_element_editor: {
			title: "Chip 编辑"
		},
		conditional: {
			chip: "Chip"
		},
		"chip-picker": {
			chips: "Chips",
			add: "添加 chip",
			edit: "编辑",
			clear: "清除",
			select: "选择 chip",
			types: {
				action: "动作",
				"alarm-control-panel": "警戒控制台",
				back: "返回",
				conditional: "条件显示",
				entity: "实体",
				light: "灯光",
				menu: "菜单",
				template: "模板",
				weather: "天气"
			}
		}
	}
};
var zhHans = {
	editor: editor$1
};

var zh_Hans = /*#__PURE__*/Object.freeze({
  __proto__: null,
  editor: editor$1,
  'default': zhHans
});

var editor = {
	form: {
		color_picker: {
			values: {
				"default": "預設顏色"
			}
		},
		info_picker: {
			values: {
				"default": "預設訊息",
				name: "名稱",
				state: "狀態",
				"last-changed": "最近變動時間",
				"last-updated": "最近更新時間",
				none: "無"
			}
		},
		icon_type_picker: {
			values: {
				"default": "預設樣式",
				icon: "圖示",
				"entity-picture": "實體圖片",
				none: "無"
			}
		},
		layout_picker: {
			values: {
				"default": "預設佈局",
				vertical: "垂直佈局",
				horizontal: "水平佈局"
			}
		},
		alignment_picker: {
			values: {
				"default": "預設對齊",
				start: "居左對齊",
				end: "居右對齊",
				center: "居中對齊",
				justify: "兩端對齊"
			}
		}
	},
	card: {
		generic: {
			icon_color: "圖示顏色",
			layout: "佈局",
			fill_container: "填滿容器",
			primary_info: "主要訊息",
			secondary_info: "次要訊息",
			icon_type: "圖示樣式",
			content_info: "內容",
			use_entity_picture: "使用實體圖片?",
			collapsible_controls: "關閉時隱藏控制項",
			icon_animation: "啟動時使用動態圖示?"
		},
		light: {
			show_brightness_control: "亮度控制?",
			use_light_color: "使用燈光顏色",
			show_color_temp_control: "色溫控制?",
			show_color_control: "色彩控制?",
			incompatible_controls: "裝置不支援的控制不會顯示。"
		},
		fan: {
			show_percentage_control: "百分比控制?",
			show_oscillate_control: "擺頭控制?"
		},
		cover: {
			show_buttons_control: "按鈕控制?",
			show_position_control: "位置控制?",
			show_tilt_position_control: "傾斜控制?"
		},
		alarm_control_panel: {
			show_keypad: "顯示鍵盤"
		},
		template: {
			primary: "主要訊息",
			secondary: "次要訊息",
			multiline_secondary: "多行次要訊息?",
			entity_extra: "用於模板與動作",
			content: "內容",
			badge_icon: "角標圖示",
			badge_color: "角標顏色",
			picture: "圖片(將會取代圖示)"
		},
		title: {
			title: "標題",
			subtitle: "副標題"
		},
		chips: {
			alignment: "對齊"
		},
		weather: {
			show_conditions: "狀況?",
			show_temperature: "溫度?"
		},
		update: {
			show_buttons_control: "按鈕控制?"
		},
		vacuum: {
			commands: "指令",
			commands_list: {
				on_off: "開啟、關閉"
			}
		},
		"media-player": {
			use_media_info: "使用媒體資訊",
			use_media_artwork: "使用媒體插圖",
			show_volume_level: "顯示音量大小",
			media_controls: "媒體控制",
			media_controls_list: {
				on_off: "開啟、關閉",
				shuffle: "隨機播放",
				previous: "上一首",
				play_pause_stop: "播放、暫停、停止",
				next: "下一首",
				repeat: "重複播放"
			},
			volume_controls: "音量控制",
			volume_controls_list: {
				volume_buttons: "音量按鈕",
				volume_set: "音量等級",
				volume_mute: "靜音"
			}
		},
		lock: {
			lock: "上鎖",
			unlock: "解鎖",
			open: "打開"
		},
		humidifier: {
			show_target_humidity_control: "溼度控制?"
		},
		climate: {
			show_temperature_control: "溫度控制?",
			hvac_modes: "空調模式"
		}
	},
	chip: {
		sub_element_editor: {
			title: "Chip 編輯"
		},
		conditional: {
			chip: "Chip"
		},
		"chip-picker": {
			chips: "Chips",
			add: "新增 chip",
			edit: "編輯",
			clear: "清除",
			select: "選擇 chip",
			types: {
				action: "動作",
				"alarm-control-panel": "警報器控制",
				back: "返回",
				conditional: "條件",
				entity: "實體",
				light: "燈光",
				menu: "選單",
				template: "模板",
				weather: "天氣"
			}
		}
	}
};
var zhHant = {
	editor: editor
};

var zh_Hant = /*#__PURE__*/Object.freeze({
  __proto__: null,
  editor: editor,
  'default': zhHant
});

const languages = {
    ar: ar$1,
    bg: bg$1,
    cs: cs$2,
    da: da$1,
    de: de$1,
    el: el$1,
    en: en$1,
    es: es$1,
    fi: fi$1,
    fr: fr$1,
    he: he$1,
    hu: hu$1,
    it: it$1,
    nb: nb$1,
    nl: nl$1,
    pl: pl$1,
    "pt-BR": pt_BR,
    "pt-PT": pt_PT,
    ro: ro$1,
    ru: ru$1,
    sk: sk$1,
    sv: sv$1,
    tr: tr$1,
    vi: vi$1,
    "zh-Hans": zh_Hans,
    "zh-Hant": zh_Hant,
};
const DEFAULT_LANG = "en";
function getTranslatedString(key, lang) {
    try {
        return key
            .split(".")
            .reduce((o, i) => o[i], languages[lang]);
    }
    catch (_) {
        return undefined;
    }
}
function setupCustomlocalize(hass) {
    return function (key) {
        var _a;
        const lang = (_a = hass === null || hass === void 0 ? void 0 : hass.locale.language) !== null && _a !== void 0 ? _a : DEFAULT_LANG;
        let translated = getTranslatedString(key, lang);
        if (!translated)
            translated = getTranslatedString(key, DEFAULT_LANG);
        return translated !== null && translated !== void 0 ? translated : key;
    };
}

/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * KEY provides normalized string values for keys.
 */
var KEY$2 = {
    UNKNOWN: 'Unknown',
    BACKSPACE: 'Backspace',
    ENTER: 'Enter',
    SPACEBAR: 'Spacebar',
    PAGE_UP: 'PageUp',
    PAGE_DOWN: 'PageDown',
    END: 'End',
    HOME: 'Home',
    ARROW_LEFT: 'ArrowLeft',
    ARROW_UP: 'ArrowUp',
    ARROW_RIGHT: 'ArrowRight',
    ARROW_DOWN: 'ArrowDown',
    DELETE: 'Delete',
    ESCAPE: 'Escape',
    TAB: 'Tab',
};
var normalizedKeys$2 = new Set();
// IE11 has no support for new Map with iterable so we need to initialize this
// by hand.
normalizedKeys$2.add(KEY$2.BACKSPACE);
normalizedKeys$2.add(KEY$2.ENTER);
normalizedKeys$2.add(KEY$2.SPACEBAR);
normalizedKeys$2.add(KEY$2.PAGE_UP);
normalizedKeys$2.add(KEY$2.PAGE_DOWN);
normalizedKeys$2.add(KEY$2.END);
normalizedKeys$2.add(KEY$2.HOME);
normalizedKeys$2.add(KEY$2.ARROW_LEFT);
normalizedKeys$2.add(KEY$2.ARROW_UP);
normalizedKeys$2.add(KEY$2.ARROW_RIGHT);
normalizedKeys$2.add(KEY$2.ARROW_DOWN);
normalizedKeys$2.add(KEY$2.DELETE);
normalizedKeys$2.add(KEY$2.ESCAPE);
normalizedKeys$2.add(KEY$2.TAB);
var KEY_CODE$2 = {
    BACKSPACE: 8,
    ENTER: 13,
    SPACEBAR: 32,
    PAGE_UP: 33,
    PAGE_DOWN: 34,
    END: 35,
    HOME: 36,
    ARROW_LEFT: 37,
    ARROW_UP: 38,
    ARROW_RIGHT: 39,
    ARROW_DOWN: 40,
    DELETE: 46,
    ESCAPE: 27,
    TAB: 9,
};
var mappedKeyCodes$2 = new Map();
// IE11 has no support for new Map with iterable so we need to initialize this
// by hand.
mappedKeyCodes$2.set(KEY_CODE$2.BACKSPACE, KEY$2.BACKSPACE);
mappedKeyCodes$2.set(KEY_CODE$2.ENTER, KEY$2.ENTER);
mappedKeyCodes$2.set(KEY_CODE$2.SPACEBAR, KEY$2.SPACEBAR);
mappedKeyCodes$2.set(KEY_CODE$2.PAGE_UP, KEY$2.PAGE_UP);
mappedKeyCodes$2.set(KEY_CODE$2.PAGE_DOWN, KEY$2.PAGE_DOWN);
mappedKeyCodes$2.set(KEY_CODE$2.END, KEY$2.END);
mappedKeyCodes$2.set(KEY_CODE$2.HOME, KEY$2.HOME);
mappedKeyCodes$2.set(KEY_CODE$2.ARROW_LEFT, KEY$2.ARROW_LEFT);
mappedKeyCodes$2.set(KEY_CODE$2.ARROW_UP, KEY$2.ARROW_UP);
mappedKeyCodes$2.set(KEY_CODE$2.ARROW_RIGHT, KEY$2.ARROW_RIGHT);
mappedKeyCodes$2.set(KEY_CODE$2.ARROW_DOWN, KEY$2.ARROW_DOWN);
mappedKeyCodes$2.set(KEY_CODE$2.DELETE, KEY$2.DELETE);
mappedKeyCodes$2.set(KEY_CODE$2.ESCAPE, KEY$2.ESCAPE);
mappedKeyCodes$2.set(KEY_CODE$2.TAB, KEY$2.TAB);
var navigationKeys$2 = new Set();
// IE11 has no support for new Set with iterable so we need to initialize this
// by hand.
navigationKeys$2.add(KEY$2.PAGE_UP);
navigationKeys$2.add(KEY$2.PAGE_DOWN);
navigationKeys$2.add(KEY$2.END);
navigationKeys$2.add(KEY$2.HOME);
navigationKeys$2.add(KEY$2.ARROW_LEFT);
navigationKeys$2.add(KEY$2.ARROW_UP);
navigationKeys$2.add(KEY$2.ARROW_RIGHT);
navigationKeys$2.add(KEY$2.ARROW_DOWN);
/**
 * normalizeKey returns the normalized string for a navigational action.
 */
function normalizeKey$2(evt) {
    var key = evt.key;
    // If the event already has a normalized key, return it
    if (normalizedKeys$2.has(key)) {
        return key;
    }
    // tslint:disable-next-line:deprecation
    var mappedKey = mappedKeyCodes$2.get(evt.keyCode);
    if (mappedKey) {
        return mappedKey;
    }
    return KEY$2.UNKNOWN;
}

/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * KEY provides normalized string values for keys.
 */
var KEY$1 = {
    UNKNOWN: 'Unknown',
    BACKSPACE: 'Backspace',
    ENTER: 'Enter',
    SPACEBAR: 'Spacebar',
    PAGE_UP: 'PageUp',
    PAGE_DOWN: 'PageDown',
    END: 'End',
    HOME: 'Home',
    ARROW_LEFT: 'ArrowLeft',
    ARROW_UP: 'ArrowUp',
    ARROW_RIGHT: 'ArrowRight',
    ARROW_DOWN: 'ArrowDown',
    DELETE: 'Delete',
    ESCAPE: 'Escape',
    TAB: 'Tab',
};
var normalizedKeys$1 = new Set();
// IE11 has no support for new Map with iterable so we need to initialize this
// by hand.
normalizedKeys$1.add(KEY$1.BACKSPACE);
normalizedKeys$1.add(KEY$1.ENTER);
normalizedKeys$1.add(KEY$1.SPACEBAR);
normalizedKeys$1.add(KEY$1.PAGE_UP);
normalizedKeys$1.add(KEY$1.PAGE_DOWN);
normalizedKeys$1.add(KEY$1.END);
normalizedKeys$1.add(KEY$1.HOME);
normalizedKeys$1.add(KEY$1.ARROW_LEFT);
normalizedKeys$1.add(KEY$1.ARROW_UP);
normalizedKeys$1.add(KEY$1.ARROW_RIGHT);
normalizedKeys$1.add(KEY$1.ARROW_DOWN);
normalizedKeys$1.add(KEY$1.DELETE);
normalizedKeys$1.add(KEY$1.ESCAPE);
normalizedKeys$1.add(KEY$1.TAB);
var KEY_CODE$1 = {
    BACKSPACE: 8,
    ENTER: 13,
    SPACEBAR: 32,
    PAGE_UP: 33,
    PAGE_DOWN: 34,
    END: 35,
    HOME: 36,
    ARROW_LEFT: 37,
    ARROW_UP: 38,
    ARROW_RIGHT: 39,
    ARROW_DOWN: 40,
    DELETE: 46,
    ESCAPE: 27,
    TAB: 9,
};
var mappedKeyCodes$1 = new Map();
// IE11 has no support for new Map with iterable so we need to initialize this
// by hand.
mappedKeyCodes$1.set(KEY_CODE$1.BACKSPACE, KEY$1.BACKSPACE);
mappedKeyCodes$1.set(KEY_CODE$1.ENTER, KEY$1.ENTER);
mappedKeyCodes$1.set(KEY_CODE$1.SPACEBAR, KEY$1.SPACEBAR);
mappedKeyCodes$1.set(KEY_CODE$1.PAGE_UP, KEY$1.PAGE_UP);
mappedKeyCodes$1.set(KEY_CODE$1.PAGE_DOWN, KEY$1.PAGE_DOWN);
mappedKeyCodes$1.set(KEY_CODE$1.END, KEY$1.END);
mappedKeyCodes$1.set(KEY_CODE$1.HOME, KEY$1.HOME);
mappedKeyCodes$1.set(KEY_CODE$1.ARROW_LEFT, KEY$1.ARROW_LEFT);
mappedKeyCodes$1.set(KEY_CODE$1.ARROW_UP, KEY$1.ARROW_UP);
mappedKeyCodes$1.set(KEY_CODE$1.ARROW_RIGHT, KEY$1.ARROW_RIGHT);
mappedKeyCodes$1.set(KEY_CODE$1.ARROW_DOWN, KEY$1.ARROW_DOWN);
mappedKeyCodes$1.set(KEY_CODE$1.DELETE, KEY$1.DELETE);
mappedKeyCodes$1.set(KEY_CODE$1.ESCAPE, KEY$1.ESCAPE);
mappedKeyCodes$1.set(KEY_CODE$1.TAB, KEY$1.TAB);
var navigationKeys$1 = new Set();
// IE11 has no support for new Set with iterable so we need to initialize this
// by hand.
navigationKeys$1.add(KEY$1.PAGE_UP);
navigationKeys$1.add(KEY$1.PAGE_DOWN);
navigationKeys$1.add(KEY$1.END);
navigationKeys$1.add(KEY$1.HOME);
navigationKeys$1.add(KEY$1.ARROW_LEFT);
navigationKeys$1.add(KEY$1.ARROW_UP);
navigationKeys$1.add(KEY$1.ARROW_RIGHT);
navigationKeys$1.add(KEY$1.ARROW_DOWN);
/**
 * normalizeKey returns the normalized string for a navigational action.
 */
function normalizeKey$1(evt) {
    var key = evt.key;
    // If the event already has a normalized key, return it
    if (normalizedKeys$1.has(key)) {
        return key;
    }
    // tslint:disable-next-line:deprecation
    var mappedKey = mappedKeyCodes$1.get(evt.keyCode);
    if (mappedKey) {
        return mappedKey;
    }
    return KEY$1.UNKNOWN;
}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var _a$1, _b$1;
var cssClasses$4 = {
    LIST_ITEM_ACTIVATED_CLASS: 'mdc-list-item--activated',
    LIST_ITEM_CLASS: 'mdc-list-item',
    LIST_ITEM_DISABLED_CLASS: 'mdc-list-item--disabled',
    LIST_ITEM_SELECTED_CLASS: 'mdc-list-item--selected',
    LIST_ITEM_TEXT_CLASS: 'mdc-list-item__text',
    LIST_ITEM_PRIMARY_TEXT_CLASS: 'mdc-list-item__primary-text',
    ROOT: 'mdc-list',
};
(_a$1 = {},
    _a$1["" + cssClasses$4.LIST_ITEM_ACTIVATED_CLASS] = 'mdc-list-item--activated',
    _a$1["" + cssClasses$4.LIST_ITEM_CLASS] = 'mdc-list-item',
    _a$1["" + cssClasses$4.LIST_ITEM_DISABLED_CLASS] = 'mdc-list-item--disabled',
    _a$1["" + cssClasses$4.LIST_ITEM_SELECTED_CLASS] = 'mdc-list-item--selected',
    _a$1["" + cssClasses$4.LIST_ITEM_PRIMARY_TEXT_CLASS] = 'mdc-list-item__primary-text',
    _a$1["" + cssClasses$4.ROOT] = 'mdc-list',
    _a$1);
var deprecatedClassNameMap = (_b$1 = {},
    _b$1["" + cssClasses$4.LIST_ITEM_ACTIVATED_CLASS] = 'mdc-deprecated-list-item--activated',
    _b$1["" + cssClasses$4.LIST_ITEM_CLASS] = 'mdc-deprecated-list-item',
    _b$1["" + cssClasses$4.LIST_ITEM_DISABLED_CLASS] = 'mdc-deprecated-list-item--disabled',
    _b$1["" + cssClasses$4.LIST_ITEM_SELECTED_CLASS] = 'mdc-deprecated-list-item--selected',
    _b$1["" + cssClasses$4.LIST_ITEM_TEXT_CLASS] = 'mdc-deprecated-list-item__text',
    _b$1["" + cssClasses$4.LIST_ITEM_PRIMARY_TEXT_CLASS] = 'mdc-deprecated-list-item__primary-text',
    _b$1["" + cssClasses$4.ROOT] = 'mdc-deprecated-list',
    _b$1);
({
    ACTION_EVENT: 'MDCList:action',
    ARIA_CHECKED: 'aria-checked',
    ARIA_CHECKED_CHECKBOX_SELECTOR: '[role="checkbox"][aria-checked="true"]',
    ARIA_CHECKED_RADIO_SELECTOR: '[role="radio"][aria-checked="true"]',
    ARIA_CURRENT: 'aria-current',
    ARIA_DISABLED: 'aria-disabled',
    ARIA_ORIENTATION: 'aria-orientation',
    ARIA_ORIENTATION_HORIZONTAL: 'horizontal',
    ARIA_ROLE_CHECKBOX_SELECTOR: '[role="checkbox"]',
    ARIA_SELECTED: 'aria-selected',
    ARIA_INTERACTIVE_ROLES_SELECTOR: '[role="listbox"], [role="menu"]',
    ARIA_MULTI_SELECTABLE_SELECTOR: '[aria-multiselectable="true"]',
    CHECKBOX_RADIO_SELECTOR: 'input[type="checkbox"], input[type="radio"]',
    CHECKBOX_SELECTOR: 'input[type="checkbox"]',
    CHILD_ELEMENTS_TO_TOGGLE_TABINDEX: "\n    ." + cssClasses$4.LIST_ITEM_CLASS + " button:not(:disabled),\n    ." + cssClasses$4.LIST_ITEM_CLASS + " a,\n    ." + deprecatedClassNameMap[cssClasses$4.LIST_ITEM_CLASS] + " button:not(:disabled),\n    ." + deprecatedClassNameMap[cssClasses$4.LIST_ITEM_CLASS] + " a\n  ",
    DEPRECATED_SELECTOR: '.mdc-deprecated-list',
    FOCUSABLE_CHILD_ELEMENTS: "\n    ." + cssClasses$4.LIST_ITEM_CLASS + " button:not(:disabled),\n    ." + cssClasses$4.LIST_ITEM_CLASS + " a,\n    ." + cssClasses$4.LIST_ITEM_CLASS + " input[type=\"radio\"]:not(:disabled),\n    ." + cssClasses$4.LIST_ITEM_CLASS + " input[type=\"checkbox\"]:not(:disabled),\n    ." + deprecatedClassNameMap[cssClasses$4.LIST_ITEM_CLASS] + " button:not(:disabled),\n    ." + deprecatedClassNameMap[cssClasses$4.LIST_ITEM_CLASS] + " a,\n    ." + deprecatedClassNameMap[cssClasses$4.LIST_ITEM_CLASS] + " input[type=\"radio\"]:not(:disabled),\n    ." + deprecatedClassNameMap[cssClasses$4.LIST_ITEM_CLASS] + " input[type=\"checkbox\"]:not(:disabled)\n  ",
    RADIO_SELECTOR: 'input[type="radio"]',
    SELECTED_ITEM_SELECTOR: '[aria-selected="true"], [aria-current="true"]',
});
var numbers$2 = {
    UNSET_INDEX: -1,
    TYPEAHEAD_BUFFER_CLEAR_TIMEOUT_MS: 300
};

/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var ELEMENTS_KEY_ALLOWED_IN = ['input', 'button', 'textarea', 'select'];
/**
 * Ensures that preventDefault is only called if the containing element
 * doesn't consume the event, and it will cause an unintended scroll.
 *
 * @param evt keyboard event to be prevented.
 */
var preventDefaultEvent = function (evt) {
    var target = evt.target;
    if (!target) {
        return;
    }
    var tagName = ("" + target.tagName).toLowerCase();
    if (ELEMENTS_KEY_ALLOWED_IN.indexOf(tagName) === -1) {
        evt.preventDefault();
    }
};

/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * Initializes a state object for typeahead. Use the same reference for calls to
 * typeahead functions.
 *
 * @return The current state of the typeahead process. Each state reference
 *     represents a typeahead instance as the reference is typically mutated
 *     in-place.
 */
function initState() {
    var state = {
        bufferClearTimeout: 0,
        currentFirstChar: '',
        sortedIndexCursor: 0,
        typeaheadBuffer: '',
    };
    return state;
}
/**
 * Initializes typeahead state by indexing the current list items by primary
 * text into the sortedIndexByFirstChar data structure.
 *
 * @param listItemCount numer of items in the list
 * @param getPrimaryTextByItemIndex function that returns the primary text at a
 *     given index
 *
 * @return Map that maps the first character of the primary text to the full
 *     list text and it's index
 */
function initSortedIndex(listItemCount, getPrimaryTextByItemIndex) {
    var sortedIndexByFirstChar = new Map();
    // Aggregate item text to index mapping
    for (var i = 0; i < listItemCount; i++) {
        var primaryText = getPrimaryTextByItemIndex(i).trim();
        if (!primaryText) {
            continue;
        }
        var firstChar = primaryText[0].toLowerCase();
        if (!sortedIndexByFirstChar.has(firstChar)) {
            sortedIndexByFirstChar.set(firstChar, []);
        }
        sortedIndexByFirstChar.get(firstChar).push({ text: primaryText.toLowerCase(), index: i });
    }
    // Sort the mapping
    // TODO(b/157162694): Investigate replacing forEach with Map.values()
    sortedIndexByFirstChar.forEach(function (values) {
        values.sort(function (first, second) {
            return first.index - second.index;
        });
    });
    return sortedIndexByFirstChar;
}
/**
 * Given the next desired character from the user, it attempts to find the next
 * list option matching the buffer. Wraps around if at the end of options.
 *
 * @param opts Options and accessors
 *   - nextChar - the next character to match against items
 *   - sortedIndexByFirstChar - output of `initSortedIndex(...)`
 *   - focusedItemIndex - the index of the currently focused item
 *   - focusItemAtIndex - function that focuses a list item at given index
 *   - skipFocus - whether or not to focus the matched item
 *   - isItemAtIndexDisabled - function that determines whether an item at a
 *        given index is disabled
 * @param state The typeahead state instance. See `initState`.
 *
 * @return The index of the matched item, or -1 if no match.
 */
function matchItem(opts, state) {
    var nextChar = opts.nextChar, focusItemAtIndex = opts.focusItemAtIndex, sortedIndexByFirstChar = opts.sortedIndexByFirstChar, focusedItemIndex = opts.focusedItemIndex, skipFocus = opts.skipFocus, isItemAtIndexDisabled = opts.isItemAtIndexDisabled;
    clearTimeout(state.bufferClearTimeout);
    state.bufferClearTimeout = setTimeout(function () {
        clearBuffer(state);
    }, numbers$2.TYPEAHEAD_BUFFER_CLEAR_TIMEOUT_MS);
    state.typeaheadBuffer = state.typeaheadBuffer + nextChar;
    var index;
    if (state.typeaheadBuffer.length === 1) {
        index = matchFirstChar(sortedIndexByFirstChar, focusedItemIndex, isItemAtIndexDisabled, state);
    }
    else {
        index = matchAllChars(sortedIndexByFirstChar, isItemAtIndexDisabled, state);
    }
    if (index !== -1 && !skipFocus) {
        focusItemAtIndex(index);
    }
    return index;
}
/**
 * Matches the user's single input character in the buffer to the
 * next option that begins with such character. Wraps around if at
 * end of options. Returns -1 if no match is found.
 */
function matchFirstChar(sortedIndexByFirstChar, focusedItemIndex, isItemAtIndexDisabled, state) {
    var firstChar = state.typeaheadBuffer[0];
    var itemsMatchingFirstChar = sortedIndexByFirstChar.get(firstChar);
    if (!itemsMatchingFirstChar) {
        return -1;
    }
    // Has the same firstChar been recently matched?
    // Also, did starting index remain the same between key presses?
    // If both hold true, simply increment index.
    if (firstChar === state.currentFirstChar &&
        itemsMatchingFirstChar[state.sortedIndexCursor].index ===
            focusedItemIndex) {
        state.sortedIndexCursor =
            (state.sortedIndexCursor + 1) % itemsMatchingFirstChar.length;
        var newIndex = itemsMatchingFirstChar[state.sortedIndexCursor].index;
        if (!isItemAtIndexDisabled(newIndex)) {
            return newIndex;
        }
    }
    // If we're here, it means one of the following happened:
    // - either firstChar or startingIndex has changed, invalidating the
    // cursor.
    // - The next item of typeahead is disabled, so we have to look further.
    state.currentFirstChar = firstChar;
    var newCursorPosition = -1;
    var cursorPosition;
    // Find the first non-disabled item as a fallback.
    for (cursorPosition = 0; cursorPosition < itemsMatchingFirstChar.length; cursorPosition++) {
        if (!isItemAtIndexDisabled(itemsMatchingFirstChar[cursorPosition].index)) {
            newCursorPosition = cursorPosition;
            break;
        }
    }
    // Advance cursor to first item matching the firstChar that is positioned
    // after starting item. Cursor is unchanged from fallback if there's no
    // such item.
    for (; cursorPosition < itemsMatchingFirstChar.length; cursorPosition++) {
        if (itemsMatchingFirstChar[cursorPosition].index > focusedItemIndex &&
            !isItemAtIndexDisabled(itemsMatchingFirstChar[cursorPosition].index)) {
            newCursorPosition = cursorPosition;
            break;
        }
    }
    if (newCursorPosition !== -1) {
        state.sortedIndexCursor = newCursorPosition;
        return itemsMatchingFirstChar[state.sortedIndexCursor].index;
    }
    return -1;
}
/**
 * Attempts to find the next item that matches all of the typeahead buffer.
 * Wraps around if at end of options. Returns -1 if no match is found.
 */
function matchAllChars(sortedIndexByFirstChar, isItemAtIndexDisabled, state) {
    var firstChar = state.typeaheadBuffer[0];
    var itemsMatchingFirstChar = sortedIndexByFirstChar.get(firstChar);
    if (!itemsMatchingFirstChar) {
        return -1;
    }
    // Do nothing if text already matches
    var startingItem = itemsMatchingFirstChar[state.sortedIndexCursor];
    if (startingItem.text.lastIndexOf(state.typeaheadBuffer, 0) === 0 &&
        !isItemAtIndexDisabled(startingItem.index)) {
        return startingItem.index;
    }
    // Find next item that matches completely; if no match, we'll eventually
    // loop around to same position
    var cursorPosition = (state.sortedIndexCursor + 1) % itemsMatchingFirstChar.length;
    var nextCursorPosition = -1;
    while (cursorPosition !== state.sortedIndexCursor) {
        var currentItem = itemsMatchingFirstChar[cursorPosition];
        var matches = currentItem.text.lastIndexOf(state.typeaheadBuffer, 0) === 0;
        var isEnabled = !isItemAtIndexDisabled(currentItem.index);
        if (matches && isEnabled) {
            nextCursorPosition = cursorPosition;
            break;
        }
        cursorPosition = (cursorPosition + 1) % itemsMatchingFirstChar.length;
    }
    if (nextCursorPosition !== -1) {
        state.sortedIndexCursor = nextCursorPosition;
        return itemsMatchingFirstChar[state.sortedIndexCursor].index;
    }
    return -1;
}
/**
 * Whether or not the given typeahead instaance state is currently typing.
 *
 * @param state The typeahead state instance. See `initState`.
 */
function isTypingInProgress(state) {
    return state.typeaheadBuffer.length > 0;
}
/**
 * Clears the typeahaed buffer so that it resets item matching to the first
 * character.
 *
 * @param state The typeahead state instance. See `initState`.
 */
function clearBuffer(state) {
    state.typeaheadBuffer = '';
}
/**
 * Given a keydown event, it calculates whether or not to automatically focus a
 * list item depending on what was typed mimicing the typeahead functionality of
 * a standard <select> element that is open.
 *
 * @param opts Options and accessors
 *   - event - the KeyboardEvent to handle and parse
 *   - sortedIndexByFirstChar - output of `initSortedIndex(...)`
 *   - focusedItemIndex - the index of the currently focused item
 *   - focusItemAtIndex - function that focuses a list item at given index
 *   - isItemAtFocusedIndexDisabled - whether or not the currently focused item
 *      is disabled
 *   - isTargetListItem - whether or not the event target is a list item
 * @param state The typeahead state instance. See `initState`.
 *
 * @returns index of the item matched by the keydown. -1 if not matched.
 */
function handleKeydown(opts, state) {
    var event = opts.event, isTargetListItem = opts.isTargetListItem, focusedItemIndex = opts.focusedItemIndex, focusItemAtIndex = opts.focusItemAtIndex, sortedIndexByFirstChar = opts.sortedIndexByFirstChar, isItemAtIndexDisabled = opts.isItemAtIndexDisabled;
    var isArrowLeft = normalizeKey$1(event) === 'ArrowLeft';
    var isArrowUp = normalizeKey$1(event) === 'ArrowUp';
    var isArrowRight = normalizeKey$1(event) === 'ArrowRight';
    var isArrowDown = normalizeKey$1(event) === 'ArrowDown';
    var isHome = normalizeKey$1(event) === 'Home';
    var isEnd = normalizeKey$1(event) === 'End';
    var isEnter = normalizeKey$1(event) === 'Enter';
    var isSpace = normalizeKey$1(event) === 'Spacebar';
    if (event.ctrlKey || event.metaKey || isArrowLeft || isArrowUp ||
        isArrowRight || isArrowDown || isHome || isEnd || isEnter) {
        return -1;
    }
    var isCharacterKey = !isSpace && event.key.length === 1;
    if (isCharacterKey) {
        preventDefaultEvent(event);
        var matchItemOpts = {
            focusItemAtIndex: focusItemAtIndex,
            focusedItemIndex: focusedItemIndex,
            nextChar: event.key.toLowerCase(),
            sortedIndexByFirstChar: sortedIndexByFirstChar,
            skipFocus: false,
            isItemAtIndexDisabled: isItemAtIndexDisabled,
        };
        return matchItem(matchItemOpts, state);
    }
    if (!isSpace) {
        return -1;
    }
    if (isTargetListItem) {
        preventDefaultEvent(event);
    }
    var typeaheadOnListItem = isTargetListItem && isTypingInProgress(state);
    if (typeaheadOnListItem) {
        var matchItemOpts = {
            focusItemAtIndex: focusItemAtIndex,
            focusedItemIndex: focusedItemIndex,
            nextChar: ' ',
            sortedIndexByFirstChar: sortedIndexByFirstChar,
            skipFocus: false,
            isItemAtIndexDisabled: isItemAtIndexDisabled,
        };
        // space participates in typeahead matching if in rapid typing mode
        return matchItem(matchItemOpts, state);
    }
    return -1;
}

/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
// Style preference for leading underscores.
// tslint:disable:strip-private-property-underscore
/**
 * Determines whether a node is an element.
 *
 * @param node Node to check
 */
const isNodeElement = (node) => {
    return node.nodeType === Node.ELEMENT_NODE;
};
function addHasRemoveClass(element) {
    return {
        addClass: (className) => {
            element.classList.add(className);
        },
        removeClass: (className) => {
            element.classList.remove(className);
        },
        hasClass: (className) => element.classList.contains(className),
    };
}
const fn = () => { };
const optionsBlock = {
    get passive() {
        return false;
    }
};
document.addEventListener('x', fn, optionsBlock);
document.removeEventListener('x', fn);

/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
/** @soyCompatible */
class BaseElement extends s$1 {
    click() {
        if (this.mdcRoot) {
            this.mdcRoot.focus();
            this.mdcRoot.click();
            return;
        }
        super.click();
    }
    /**
     * Create and attach the MDC Foundation to the instance
     */
    createFoundation() {
        if (this.mdcFoundation !== undefined) {
            this.mdcFoundation.destroy();
        }
        if (this.mdcFoundationClass) {
            this.mdcFoundation = new this.mdcFoundationClass(this.createAdapter());
            this.mdcFoundation.init();
        }
    }
    firstUpdated() {
        this.createFoundation();
    }
}

/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
var _a, _b;
// ShadyDOM should submit <input> elements in component internals
const USING_SHADY_DOM = (_b = (_a = window.ShadyDOM) === null || _a === void 0 ? void 0 : _a.inUse) !== null && _b !== void 0 ? _b : false;
/** @soyCompatible */
class FormElement extends BaseElement {
    constructor() {
        super(...arguments);
        /**
         * Disabled state for the component. When `disabled` is set to `true`, the
         * component will not be added to form submission.
         */
        this.disabled = false;
        /**
         * Form element that contains this element
         */
        this.containingForm = null;
        this.formDataListener = (ev) => {
            if (!this.disabled) {
                this.setFormData(ev.formData);
            }
        };
    }
    findFormElement() {
        // If the component internals are not in Shadow DOM, subscribing to form
        // data events could lead to duplicated data, which may not work correctly
        // on the server side.
        if (!this.shadowRoot || USING_SHADY_DOM) {
            return null;
        }
        const root = this.getRootNode();
        const forms = root.querySelectorAll('form');
        for (const form of Array.from(forms)) {
            if (form.contains(this)) {
                return form;
            }
        }
        return null;
    }
    connectedCallback() {
        var _a;
        super.connectedCallback();
        this.containingForm = this.findFormElement();
        (_a = this.containingForm) === null || _a === void 0 ? void 0 : _a.addEventListener('formdata', this.formDataListener);
    }
    disconnectedCallback() {
        var _a;
        super.disconnectedCallback();
        (_a = this.containingForm) === null || _a === void 0 ? void 0 : _a.removeEventListener('formdata', this.formDataListener);
        this.containingForm = null;
    }
    click() {
        if (this.formElement && !this.disabled) {
            this.formElement.focus();
            this.formElement.click();
        }
    }
    firstUpdated() {
        super.firstUpdated();
        if (this.shadowRoot) {
            this.mdcRoot.addEventListener('change', (e) => {
                this.dispatchEvent(new Event('change', e));
            });
        }
    }
}
FormElement.shadowRootOptions = { mode: 'open', delegatesFocus: true };
__decorate([
    e$3({ type: Boolean })
], FormElement.prototype, "disabled", void 0);

/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * Specifies an observer callback that is run when the decorated property
 * changes. The observer receives the current and old value as arguments.
 */
const observer = (observer) => 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
(proto, propName) => {
    // if we haven't wrapped `updated` in this class, do so
    if (!proto.constructor
        ._observers) {
        proto.constructor._observers = new Map();
        const userUpdated = proto.updated;
        proto.updated = function (changedProperties) {
            userUpdated.call(this, changedProperties);
            changedProperties.forEach((v, k) => {
                const observers = this.constructor
                    ._observers;
                const observer = observers.get(k);
                if (observer !== undefined) {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    observer.call(this, this[k], v);
                }
            });
        };
        // clone any existing observers (superclasses)
        // eslint-disable-next-line no-prototype-builtins
    }
    else if (!proto.constructor.hasOwnProperty('_observers')) {
        const observers = proto.constructor._observers;
        proto.constructor._observers = new Map();
        observers.forEach(
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (v, k) => proto.constructor._observers.set(k, v));
    }
    // set this method
    proto.constructor._observers.set(propName, observer);
};

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCFoundation$3 = /** @class */ (function () {
    function MDCFoundation(adapter) {
        if (adapter === void 0) { adapter = {}; }
        this.adapter = adapter;
    }
    Object.defineProperty(MDCFoundation, "cssClasses", {
        get: function () {
            // Classes extending MDCFoundation should implement this method to return an object which exports every
            // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
            return {};
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MDCFoundation, "strings", {
        get: function () {
            // Classes extending MDCFoundation should implement this method to return an object which exports all
            // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
            return {};
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MDCFoundation, "numbers", {
        get: function () {
            // Classes extending MDCFoundation should implement this method to return an object which exports all
            // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
            return {};
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MDCFoundation, "defaultAdapter", {
        get: function () {
            // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
            // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
            // validation.
            return {};
        },
        enumerable: false,
        configurable: true
    });
    MDCFoundation.prototype.init = function () {
        // Subclasses should override this method to perform initialization routines (registering events, etc.)
    };
    MDCFoundation.prototype.destroy = function () {
        // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
    };
    return MDCFoundation;
}());

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var cssClasses$3 = {
    LABEL_FLOAT_ABOVE: 'mdc-floating-label--float-above',
    LABEL_REQUIRED: 'mdc-floating-label--required',
    LABEL_SHAKE: 'mdc-floating-label--shake',
    ROOT: 'mdc-floating-label',
};

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCFloatingLabelFoundation = /** @class */ (function (_super) {
    __extends(MDCFloatingLabelFoundation, _super);
    function MDCFloatingLabelFoundation(adapter) {
        var _this = _super.call(this, __assign(__assign({}, MDCFloatingLabelFoundation.defaultAdapter), adapter)) || this;
        _this.shakeAnimationEndHandler = function () {
            _this.handleShakeAnimationEnd();
        };
        return _this;
    }
    Object.defineProperty(MDCFloatingLabelFoundation, "cssClasses", {
        get: function () {
            return cssClasses$3;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MDCFloatingLabelFoundation, "defaultAdapter", {
        /**
         * See {@link MDCFloatingLabelAdapter} for typing information on parameters and return types.
         */
        get: function () {
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            return {
                addClass: function () { return undefined; },
                removeClass: function () { return undefined; },
                getWidth: function () { return 0; },
                registerInteractionHandler: function () { return undefined; },
                deregisterInteractionHandler: function () { return undefined; },
            };
            // tslint:enable:object-literal-sort-keys
        },
        enumerable: false,
        configurable: true
    });
    MDCFloatingLabelFoundation.prototype.init = function () {
        this.adapter.registerInteractionHandler('animationend', this.shakeAnimationEndHandler);
    };
    MDCFloatingLabelFoundation.prototype.destroy = function () {
        this.adapter.deregisterInteractionHandler('animationend', this.shakeAnimationEndHandler);
    };
    /**
     * Returns the width of the label element.
     */
    MDCFloatingLabelFoundation.prototype.getWidth = function () {
        return this.adapter.getWidth();
    };
    /**
     * Styles the label to produce a shake animation to indicate an error.
     * @param shouldShake If true, adds the shake CSS class; otherwise, removes shake class.
     */
    MDCFloatingLabelFoundation.prototype.shake = function (shouldShake) {
        var LABEL_SHAKE = MDCFloatingLabelFoundation.cssClasses.LABEL_SHAKE;
        if (shouldShake) {
            this.adapter.addClass(LABEL_SHAKE);
        }
        else {
            this.adapter.removeClass(LABEL_SHAKE);
        }
    };
    /**
     * Styles the label to float or dock.
     * @param shouldFloat If true, adds the float CSS class; otherwise, removes float and shake classes to dock the label.
     */
    MDCFloatingLabelFoundation.prototype.float = function (shouldFloat) {
        var _a = MDCFloatingLabelFoundation.cssClasses, LABEL_FLOAT_ABOVE = _a.LABEL_FLOAT_ABOVE, LABEL_SHAKE = _a.LABEL_SHAKE;
        if (shouldFloat) {
            this.adapter.addClass(LABEL_FLOAT_ABOVE);
        }
        else {
            this.adapter.removeClass(LABEL_FLOAT_ABOVE);
            this.adapter.removeClass(LABEL_SHAKE);
        }
    };
    /**
     * Styles the label as required.
     * @param isRequired If true, adds an asterisk to the label, indicating that it is required.
     */
    MDCFloatingLabelFoundation.prototype.setRequired = function (isRequired) {
        var LABEL_REQUIRED = MDCFloatingLabelFoundation.cssClasses.LABEL_REQUIRED;
        if (isRequired) {
            this.adapter.addClass(LABEL_REQUIRED);
        }
        else {
            this.adapter.removeClass(LABEL_REQUIRED);
        }
    };
    MDCFloatingLabelFoundation.prototype.handleShakeAnimationEnd = function () {
        var LABEL_SHAKE = MDCFloatingLabelFoundation.cssClasses.LABEL_SHAKE;
        this.adapter.removeClass(LABEL_SHAKE);
    };
    return MDCFloatingLabelFoundation;
}(MDCFoundation$3));

/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const createAdapter$1 = (labelElement) => {
    return {
        addClass: (className) => labelElement.classList.add(className),
        removeClass: (className) => labelElement.classList.remove(className),
        getWidth: () => labelElement.scrollWidth,
        registerInteractionHandler: (evtType, handler) => {
            labelElement.addEventListener(evtType, handler);
        },
        deregisterInteractionHandler: (evtType, handler) => {
            labelElement.removeEventListener(evtType, handler);
        },
    };
};
class FloatingLabelDirective extends i$3 {
    constructor(partInfo) {
        super(partInfo);
        this.foundation = null;
        this.previousPart = null;
        switch (partInfo.type) {
            // Only allow Attribute and Part bindings
            case t.ATTRIBUTE:
            case t.PROPERTY:
                break;
            default:
                throw new Error('FloatingLabel directive only support attribute and property parts');
        }
    }
    /**
     * There is no PropertyPart in Lit 2 so far. For more info see:
     * https://github.com/lit/lit/issues/1863
     */
    update(part, [label]) {
        if (part !== this.previousPart) {
            if (this.foundation) {
                this.foundation.destroy();
            }
            this.previousPart = part;
            const labelElement = part.element;
            labelElement.classList.add('mdc-floating-label');
            const adapter = createAdapter$1(labelElement);
            this.foundation = new MDCFloatingLabelFoundation(adapter);
            this.foundation.init();
        }
        return this.render(label);
    }
    render(_label) {
        return this.foundation;
    }
}
const floatingLabel = e$1(FloatingLabelDirective);

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCFoundation$2 = /** @class */ (function () {
    function MDCFoundation(adapter) {
        if (adapter === void 0) { adapter = {}; }
        this.adapter = adapter;
    }
    Object.defineProperty(MDCFoundation, "cssClasses", {
        get: function () {
            // Classes extending MDCFoundation should implement this method to return an object which exports every
            // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
            return {};
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MDCFoundation, "strings", {
        get: function () {
            // Classes extending MDCFoundation should implement this method to return an object which exports all
            // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
            return {};
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MDCFoundation, "numbers", {
        get: function () {
            // Classes extending MDCFoundation should implement this method to return an object which exports all
            // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
            return {};
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MDCFoundation, "defaultAdapter", {
        get: function () {
            // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
            // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
            // validation.
            return {};
        },
        enumerable: false,
        configurable: true
    });
    MDCFoundation.prototype.init = function () {
        // Subclasses should override this method to perform initialization routines (registering events, etc.)
    };
    MDCFoundation.prototype.destroy = function () {
        // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
    };
    return MDCFoundation;
}());

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var cssClasses$2 = {
    LINE_RIPPLE_ACTIVE: 'mdc-line-ripple--active',
    LINE_RIPPLE_DEACTIVATING: 'mdc-line-ripple--deactivating',
};

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCLineRippleFoundation = /** @class */ (function (_super) {
    __extends(MDCLineRippleFoundation, _super);
    function MDCLineRippleFoundation(adapter) {
        var _this = _super.call(this, __assign(__assign({}, MDCLineRippleFoundation.defaultAdapter), adapter)) || this;
        _this.transitionEndHandler = function (evt) {
            _this.handleTransitionEnd(evt);
        };
        return _this;
    }
    Object.defineProperty(MDCLineRippleFoundation, "cssClasses", {
        get: function () {
            return cssClasses$2;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MDCLineRippleFoundation, "defaultAdapter", {
        /**
         * See {@link MDCLineRippleAdapter} for typing information on parameters and return types.
         */
        get: function () {
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            return {
                addClass: function () { return undefined; },
                removeClass: function () { return undefined; },
                hasClass: function () { return false; },
                setStyle: function () { return undefined; },
                registerEventHandler: function () { return undefined; },
                deregisterEventHandler: function () { return undefined; },
            };
            // tslint:enable:object-literal-sort-keys
        },
        enumerable: false,
        configurable: true
    });
    MDCLineRippleFoundation.prototype.init = function () {
        this.adapter.registerEventHandler('transitionend', this.transitionEndHandler);
    };
    MDCLineRippleFoundation.prototype.destroy = function () {
        this.adapter.deregisterEventHandler('transitionend', this.transitionEndHandler);
    };
    MDCLineRippleFoundation.prototype.activate = function () {
        this.adapter.removeClass(cssClasses$2.LINE_RIPPLE_DEACTIVATING);
        this.adapter.addClass(cssClasses$2.LINE_RIPPLE_ACTIVE);
    };
    MDCLineRippleFoundation.prototype.setRippleCenter = function (xCoordinate) {
        this.adapter.setStyle('transform-origin', xCoordinate + "px center");
    };
    MDCLineRippleFoundation.prototype.deactivate = function () {
        this.adapter.addClass(cssClasses$2.LINE_RIPPLE_DEACTIVATING);
    };
    MDCLineRippleFoundation.prototype.handleTransitionEnd = function (evt) {
        // Wait for the line ripple to be either transparent or opaque
        // before emitting the animation end event
        var isDeactivating = this.adapter.hasClass(cssClasses$2.LINE_RIPPLE_DEACTIVATING);
        if (evt.propertyName === 'opacity') {
            if (isDeactivating) {
                this.adapter.removeClass(cssClasses$2.LINE_RIPPLE_ACTIVE);
                this.adapter.removeClass(cssClasses$2.LINE_RIPPLE_DEACTIVATING);
            }
        }
    };
    return MDCLineRippleFoundation;
}(MDCFoundation$2));

/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const createAdapter = (lineElement) => {
    return {
        addClass: (className) => lineElement.classList.add(className),
        removeClass: (className) => lineElement.classList.remove(className),
        hasClass: (className) => lineElement.classList.contains(className),
        setStyle: (propertyName, value) => lineElement.style.setProperty(propertyName, value),
        registerEventHandler: (evtType, handler) => {
            lineElement.addEventListener(evtType, handler);
        },
        deregisterEventHandler: (evtType, handler) => {
            lineElement.removeEventListener(evtType, handler);
        },
    };
};
class LineRippleDirective extends i$3 {
    constructor(partInfo) {
        super(partInfo);
        this.previousPart = null;
        this.foundation = null;
        switch (partInfo.type) {
            case t.ATTRIBUTE:
            case t.PROPERTY:
                return;
            default:
                throw new Error('LineRipple only support attribute and property parts.');
        }
    }
    /**
     * There is no PropertyPart in Lit 2 so far. For more info see:
     * https://github.com/lit/lit/issues/1863
     */
    update(part, _params) {
        if (this.previousPart !== part) {
            if (this.foundation) {
                this.foundation.destroy();
            }
            this.previousPart = part;
            const lineElement = part.element;
            lineElement.classList.add('mdc-line-ripple');
            const adapter = createAdapter(lineElement);
            this.foundation = new MDCLineRippleFoundation(adapter);
            this.foundation.init();
        }
        return this.render();
    }
    render() {
        return this.foundation;
    }
}
const lineRipple = e$1(LineRippleDirective);

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCFoundation$1 = /** @class */ (function () {
    function MDCFoundation(adapter) {
        if (adapter === void 0) { adapter = {}; }
        this.adapter = adapter;
    }
    Object.defineProperty(MDCFoundation, "cssClasses", {
        get: function () {
            // Classes extending MDCFoundation should implement this method to return an object which exports every
            // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
            return {};
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MDCFoundation, "strings", {
        get: function () {
            // Classes extending MDCFoundation should implement this method to return an object which exports all
            // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
            return {};
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MDCFoundation, "numbers", {
        get: function () {
            // Classes extending MDCFoundation should implement this method to return an object which exports all
            // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
            return {};
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MDCFoundation, "defaultAdapter", {
        get: function () {
            // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
            // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
            // validation.
            return {};
        },
        enumerable: false,
        configurable: true
    });
    MDCFoundation.prototype.init = function () {
        // Subclasses should override this method to perform initialization routines (registering events, etc.)
    };
    MDCFoundation.prototype.destroy = function () {
        // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
    };
    return MDCFoundation;
}());

/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * KEY provides normalized string values for keys.
 */
var KEY = {
    UNKNOWN: 'Unknown',
    BACKSPACE: 'Backspace',
    ENTER: 'Enter',
    SPACEBAR: 'Spacebar',
    PAGE_UP: 'PageUp',
    PAGE_DOWN: 'PageDown',
    END: 'End',
    HOME: 'Home',
    ARROW_LEFT: 'ArrowLeft',
    ARROW_UP: 'ArrowUp',
    ARROW_RIGHT: 'ArrowRight',
    ARROW_DOWN: 'ArrowDown',
    DELETE: 'Delete',
    ESCAPE: 'Escape',
    TAB: 'Tab',
};
var normalizedKeys = new Set();
// IE11 has no support for new Map with iterable so we need to initialize this
// by hand.
normalizedKeys.add(KEY.BACKSPACE);
normalizedKeys.add(KEY.ENTER);
normalizedKeys.add(KEY.SPACEBAR);
normalizedKeys.add(KEY.PAGE_UP);
normalizedKeys.add(KEY.PAGE_DOWN);
normalizedKeys.add(KEY.END);
normalizedKeys.add(KEY.HOME);
normalizedKeys.add(KEY.ARROW_LEFT);
normalizedKeys.add(KEY.ARROW_UP);
normalizedKeys.add(KEY.ARROW_RIGHT);
normalizedKeys.add(KEY.ARROW_DOWN);
normalizedKeys.add(KEY.DELETE);
normalizedKeys.add(KEY.ESCAPE);
normalizedKeys.add(KEY.TAB);
var KEY_CODE = {
    BACKSPACE: 8,
    ENTER: 13,
    SPACEBAR: 32,
    PAGE_UP: 33,
    PAGE_DOWN: 34,
    END: 35,
    HOME: 36,
    ARROW_LEFT: 37,
    ARROW_UP: 38,
    ARROW_RIGHT: 39,
    ARROW_DOWN: 40,
    DELETE: 46,
    ESCAPE: 27,
    TAB: 9,
};
var mappedKeyCodes = new Map();
// IE11 has no support for new Map with iterable so we need to initialize this
// by hand.
mappedKeyCodes.set(KEY_CODE.BACKSPACE, KEY.BACKSPACE);
mappedKeyCodes.set(KEY_CODE.ENTER, KEY.ENTER);
mappedKeyCodes.set(KEY_CODE.SPACEBAR, KEY.SPACEBAR);
mappedKeyCodes.set(KEY_CODE.PAGE_UP, KEY.PAGE_UP);
mappedKeyCodes.set(KEY_CODE.PAGE_DOWN, KEY.PAGE_DOWN);
mappedKeyCodes.set(KEY_CODE.END, KEY.END);
mappedKeyCodes.set(KEY_CODE.HOME, KEY.HOME);
mappedKeyCodes.set(KEY_CODE.ARROW_LEFT, KEY.ARROW_LEFT);
mappedKeyCodes.set(KEY_CODE.ARROW_UP, KEY.ARROW_UP);
mappedKeyCodes.set(KEY_CODE.ARROW_RIGHT, KEY.ARROW_RIGHT);
mappedKeyCodes.set(KEY_CODE.ARROW_DOWN, KEY.ARROW_DOWN);
mappedKeyCodes.set(KEY_CODE.DELETE, KEY.DELETE);
mappedKeyCodes.set(KEY_CODE.ESCAPE, KEY.ESCAPE);
mappedKeyCodes.set(KEY_CODE.TAB, KEY.TAB);
var navigationKeys = new Set();
// IE11 has no support for new Set with iterable so we need to initialize this
// by hand.
navigationKeys.add(KEY.PAGE_UP);
navigationKeys.add(KEY.PAGE_DOWN);
navigationKeys.add(KEY.END);
navigationKeys.add(KEY.HOME);
navigationKeys.add(KEY.ARROW_LEFT);
navigationKeys.add(KEY.ARROW_UP);
navigationKeys.add(KEY.ARROW_RIGHT);
navigationKeys.add(KEY.ARROW_DOWN);
/**
 * normalizeKey returns the normalized string for a navigational action.
 */
function normalizeKey(evt) {
    var key = evt.key;
    // If the event already has a normalized key, return it
    if (normalizedKeys.has(key)) {
        return key;
    }
    // tslint:disable-next-line:deprecation
    var mappedKey = mappedKeyCodes.get(evt.keyCode);
    if (mappedKey) {
        return mappedKey;
    }
    return KEY.UNKNOWN;
}

/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * Enum for bits in the {@see Corner) bitmap.
 */
var CornerBit;
(function (CornerBit) {
    CornerBit[CornerBit["BOTTOM"] = 1] = "BOTTOM";
    CornerBit[CornerBit["CENTER"] = 2] = "CENTER";
    CornerBit[CornerBit["RIGHT"] = 4] = "RIGHT";
    CornerBit[CornerBit["FLIP_RTL"] = 8] = "FLIP_RTL";
})(CornerBit || (CornerBit = {}));
/**
 * Enum for representing an element corner for positioning the menu-surface.
 *
 * The START constants map to LEFT if element directionality is left
 * to right and RIGHT if the directionality is right to left.
 * Likewise END maps to RIGHT or LEFT depending on the directionality.
 */
var Corner;
(function (Corner) {
    Corner[Corner["TOP_LEFT"] = 0] = "TOP_LEFT";
    Corner[Corner["TOP_RIGHT"] = 4] = "TOP_RIGHT";
    Corner[Corner["BOTTOM_LEFT"] = 1] = "BOTTOM_LEFT";
    Corner[Corner["BOTTOM_RIGHT"] = 5] = "BOTTOM_RIGHT";
    Corner[Corner["TOP_START"] = 8] = "TOP_START";
    Corner[Corner["TOP_END"] = 12] = "TOP_END";
    Corner[Corner["BOTTOM_START"] = 9] = "BOTTOM_START";
    Corner[Corner["BOTTOM_END"] = 13] = "BOTTOM_END";
})(Corner || (Corner = {}));

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var cssClasses$1 = {
    ACTIVATED: 'mdc-select--activated',
    DISABLED: 'mdc-select--disabled',
    FOCUSED: 'mdc-select--focused',
    INVALID: 'mdc-select--invalid',
    MENU_INVALID: 'mdc-select__menu--invalid',
    OUTLINED: 'mdc-select--outlined',
    REQUIRED: 'mdc-select--required',
    ROOT: 'mdc-select',
    WITH_LEADING_ICON: 'mdc-select--with-leading-icon',
};
var strings$1 = {
    ARIA_CONTROLS: 'aria-controls',
    ARIA_DESCRIBEDBY: 'aria-describedby',
    ARIA_SELECTED_ATTR: 'aria-selected',
    CHANGE_EVENT: 'MDCSelect:change',
    HIDDEN_INPUT_SELECTOR: 'input[type="hidden"]',
    LABEL_SELECTOR: '.mdc-floating-label',
    LEADING_ICON_SELECTOR: '.mdc-select__icon',
    LINE_RIPPLE_SELECTOR: '.mdc-line-ripple',
    MENU_SELECTOR: '.mdc-select__menu',
    OUTLINE_SELECTOR: '.mdc-notched-outline',
    SELECTED_TEXT_SELECTOR: '.mdc-select__selected-text',
    SELECT_ANCHOR_SELECTOR: '.mdc-select__anchor',
    VALUE_ATTR: 'data-value',
};
var numbers$1 = {
    LABEL_SCALE: 0.75,
    UNSET_INDEX: -1,
    CLICK_DEBOUNCE_TIMEOUT_MS: 330,
};

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCSelectFoundation = /** @class */ (function (_super) {
    __extends(MDCSelectFoundation, _super);
    /* istanbul ignore next: optional argument is not a branch statement */
    /**
     * @param adapter
     * @param foundationMap Map from subcomponent names to their subfoundations.
     */
    function MDCSelectFoundation(adapter, foundationMap) {
        if (foundationMap === void 0) { foundationMap = {}; }
        var _this = _super.call(this, __assign(__assign({}, MDCSelectFoundation.defaultAdapter), adapter)) || this;
        // Disabled state
        _this.disabled = false;
        // isMenuOpen is used to track the state of the menu by listening to the
        // MDCMenuSurface:closed event For reference, menu.open will return false if
        // the menu is still closing, but isMenuOpen returns false only after the menu
        // has closed
        _this.isMenuOpen = false;
        // By default, select is invalid if it is required but no value is selected.
        _this.useDefaultValidation = true;
        _this.customValidity = true;
        _this.lastSelectedIndex = numbers$1.UNSET_INDEX;
        _this.clickDebounceTimeout = 0;
        _this.recentlyClicked = false;
        _this.leadingIcon = foundationMap.leadingIcon;
        _this.helperText = foundationMap.helperText;
        return _this;
    }
    Object.defineProperty(MDCSelectFoundation, "cssClasses", {
        get: function () {
            return cssClasses$1;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MDCSelectFoundation, "numbers", {
        get: function () {
            return numbers$1;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MDCSelectFoundation, "strings", {
        get: function () {
            return strings$1;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MDCSelectFoundation, "defaultAdapter", {
        /**
         * See {@link MDCSelectAdapter} for typing information on parameters and return types.
         */
        get: function () {
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            return {
                addClass: function () { return undefined; },
                removeClass: function () { return undefined; },
                hasClass: function () { return false; },
                activateBottomLine: function () { return undefined; },
                deactivateBottomLine: function () { return undefined; },
                getSelectedIndex: function () { return -1; },
                setSelectedIndex: function () { return undefined; },
                hasLabel: function () { return false; },
                floatLabel: function () { return undefined; },
                getLabelWidth: function () { return 0; },
                setLabelRequired: function () { return undefined; },
                hasOutline: function () { return false; },
                notchOutline: function () { return undefined; },
                closeOutline: function () { return undefined; },
                setRippleCenter: function () { return undefined; },
                notifyChange: function () { return undefined; },
                setSelectedText: function () { return undefined; },
                isSelectAnchorFocused: function () { return false; },
                getSelectAnchorAttr: function () { return ''; },
                setSelectAnchorAttr: function () { return undefined; },
                removeSelectAnchorAttr: function () { return undefined; },
                addMenuClass: function () { return undefined; },
                removeMenuClass: function () { return undefined; },
                openMenu: function () { return undefined; },
                closeMenu: function () { return undefined; },
                getAnchorElement: function () { return null; },
                setMenuAnchorElement: function () { return undefined; },
                setMenuAnchorCorner: function () { return undefined; },
                setMenuWrapFocus: function () { return undefined; },
                focusMenuItemAtIndex: function () { return undefined; },
                getMenuItemCount: function () { return 0; },
                getMenuItemValues: function () { return []; },
                getMenuItemTextAtIndex: function () { return ''; },
                isTypeaheadInProgress: function () { return false; },
                typeaheadMatchItem: function () { return -1; },
            };
            // tslint:enable:object-literal-sort-keys
        },
        enumerable: false,
        configurable: true
    });
    /** Returns the index of the currently selected menu item, or -1 if none. */
    MDCSelectFoundation.prototype.getSelectedIndex = function () {
        return this.adapter.getSelectedIndex();
    };
    MDCSelectFoundation.prototype.setSelectedIndex = function (index, closeMenu, skipNotify) {
        if (closeMenu === void 0) { closeMenu = false; }
        if (skipNotify === void 0) { skipNotify = false; }
        if (index >= this.adapter.getMenuItemCount()) {
            return;
        }
        if (index === numbers$1.UNSET_INDEX) {
            this.adapter.setSelectedText('');
        }
        else {
            this.adapter.setSelectedText(this.adapter.getMenuItemTextAtIndex(index).trim());
        }
        this.adapter.setSelectedIndex(index);
        if (closeMenu) {
            this.adapter.closeMenu();
        }
        if (!skipNotify && this.lastSelectedIndex !== index) {
            this.handleChange();
        }
        this.lastSelectedIndex = index;
    };
    MDCSelectFoundation.prototype.setValue = function (value, skipNotify) {
        if (skipNotify === void 0) { skipNotify = false; }
        var index = this.adapter.getMenuItemValues().indexOf(value);
        this.setSelectedIndex(index, /** closeMenu */ false, skipNotify);
    };
    MDCSelectFoundation.prototype.getValue = function () {
        var index = this.adapter.getSelectedIndex();
        var menuItemValues = this.adapter.getMenuItemValues();
        return index !== numbers$1.UNSET_INDEX ? menuItemValues[index] : '';
    };
    MDCSelectFoundation.prototype.getDisabled = function () {
        return this.disabled;
    };
    MDCSelectFoundation.prototype.setDisabled = function (isDisabled) {
        this.disabled = isDisabled;
        if (this.disabled) {
            this.adapter.addClass(cssClasses$1.DISABLED);
            this.adapter.closeMenu();
        }
        else {
            this.adapter.removeClass(cssClasses$1.DISABLED);
        }
        if (this.leadingIcon) {
            this.leadingIcon.setDisabled(this.disabled);
        }
        if (this.disabled) {
            // Prevent click events from focusing select. Simply pointer-events: none
            // is not enough since screenreader clicks may bypass this.
            this.adapter.removeSelectAnchorAttr('tabindex');
        }
        else {
            this.adapter.setSelectAnchorAttr('tabindex', '0');
        }
        this.adapter.setSelectAnchorAttr('aria-disabled', this.disabled.toString());
    };
    /** Opens the menu. */
    MDCSelectFoundation.prototype.openMenu = function () {
        this.adapter.addClass(cssClasses$1.ACTIVATED);
        this.adapter.openMenu();
        this.isMenuOpen = true;
        this.adapter.setSelectAnchorAttr('aria-expanded', 'true');
    };
    /**
     * @param content Sets the content of the helper text.
     */
    MDCSelectFoundation.prototype.setHelperTextContent = function (content) {
        if (this.helperText) {
            this.helperText.setContent(content);
        }
    };
    /**
     * Re-calculates if the notched outline should be notched and if the label
     * should float.
     */
    MDCSelectFoundation.prototype.layout = function () {
        if (this.adapter.hasLabel()) {
            var optionHasValue = this.getValue().length > 0;
            var isFocused = this.adapter.hasClass(cssClasses$1.FOCUSED);
            var shouldFloatAndNotch = optionHasValue || isFocused;
            var isRequired = this.adapter.hasClass(cssClasses$1.REQUIRED);
            this.notchOutline(shouldFloatAndNotch);
            this.adapter.floatLabel(shouldFloatAndNotch);
            this.adapter.setLabelRequired(isRequired);
        }
    };
    /**
     * Synchronizes the list of options with the state of the foundation. Call
     * this whenever menu options are dynamically updated.
     */
    MDCSelectFoundation.prototype.layoutOptions = function () {
        var menuItemValues = this.adapter.getMenuItemValues();
        var selectedIndex = menuItemValues.indexOf(this.getValue());
        this.setSelectedIndex(selectedIndex, /** closeMenu */ false, /** skipNotify */ true);
    };
    MDCSelectFoundation.prototype.handleMenuOpened = function () {
        if (this.adapter.getMenuItemValues().length === 0) {
            return;
        }
        // Menu should open to the last selected element, should open to first menu item otherwise.
        var selectedIndex = this.getSelectedIndex();
        var focusItemIndex = selectedIndex >= 0 ? selectedIndex : 0;
        this.adapter.focusMenuItemAtIndex(focusItemIndex);
    };
    MDCSelectFoundation.prototype.handleMenuClosing = function () {
        this.adapter.setSelectAnchorAttr('aria-expanded', 'false');
    };
    MDCSelectFoundation.prototype.handleMenuClosed = function () {
        this.adapter.removeClass(cssClasses$1.ACTIVATED);
        this.isMenuOpen = false;
        // Unfocus the select if menu is closed without a selection
        if (!this.adapter.isSelectAnchorFocused()) {
            this.blur();
        }
    };
    /**
     * Handles value changes, via change event or programmatic updates.
     */
    MDCSelectFoundation.prototype.handleChange = function () {
        this.layout();
        this.adapter.notifyChange(this.getValue());
        var isRequired = this.adapter.hasClass(cssClasses$1.REQUIRED);
        if (isRequired && this.useDefaultValidation) {
            this.setValid(this.isValid());
        }
    };
    MDCSelectFoundation.prototype.handleMenuItemAction = function (index) {
        this.setSelectedIndex(index, /** closeMenu */ true);
    };
    /**
     * Handles focus events from select element.
     */
    MDCSelectFoundation.prototype.handleFocus = function () {
        this.adapter.addClass(cssClasses$1.FOCUSED);
        this.layout();
        this.adapter.activateBottomLine();
    };
    /**
     * Handles blur events from select element.
     */
    MDCSelectFoundation.prototype.handleBlur = function () {
        if (this.isMenuOpen) {
            return;
        }
        this.blur();
    };
    MDCSelectFoundation.prototype.handleClick = function (normalizedX) {
        if (this.disabled || this.recentlyClicked) {
            return;
        }
        this.setClickDebounceTimeout();
        if (this.isMenuOpen) {
            this.adapter.closeMenu();
            return;
        }
        this.adapter.setRippleCenter(normalizedX);
        this.openMenu();
    };
    /**
     * Handles keydown events on select element. Depending on the type of
     * character typed, does typeahead matching or opens menu.
     */
    MDCSelectFoundation.prototype.handleKeydown = function (event) {
        if (this.isMenuOpen || !this.adapter.hasClass(cssClasses$1.FOCUSED)) {
            return;
        }
        var isEnter = normalizeKey(event) === KEY.ENTER;
        var isSpace = normalizeKey(event) === KEY.SPACEBAR;
        var arrowUp = normalizeKey(event) === KEY.ARROW_UP;
        var arrowDown = normalizeKey(event) === KEY.ARROW_DOWN;
        var isModifier = event.ctrlKey || event.metaKey;
        // Typeahead
        if (!isModifier &&
            (!isSpace && event.key && event.key.length === 1 ||
                isSpace && this.adapter.isTypeaheadInProgress())) {
            var key = isSpace ? ' ' : event.key;
            var typeaheadNextIndex = this.adapter.typeaheadMatchItem(key, this.getSelectedIndex());
            if (typeaheadNextIndex >= 0) {
                this.setSelectedIndex(typeaheadNextIndex);
            }
            event.preventDefault();
            return;
        }
        if (!isEnter && !isSpace && !arrowUp && !arrowDown) {
            return;
        }
        // Increment/decrement index as necessary and open menu.
        if (arrowUp && this.getSelectedIndex() > 0) {
            this.setSelectedIndex(this.getSelectedIndex() - 1);
        }
        else if (arrowDown &&
            this.getSelectedIndex() < this.adapter.getMenuItemCount() - 1) {
            this.setSelectedIndex(this.getSelectedIndex() + 1);
        }
        this.openMenu();
        event.preventDefault();
    };
    /**
     * Opens/closes the notched outline.
     */
    MDCSelectFoundation.prototype.notchOutline = function (openNotch) {
        if (!this.adapter.hasOutline()) {
            return;
        }
        var isFocused = this.adapter.hasClass(cssClasses$1.FOCUSED);
        if (openNotch) {
            var labelScale = numbers$1.LABEL_SCALE;
            var labelWidth = this.adapter.getLabelWidth() * labelScale;
            this.adapter.notchOutline(labelWidth);
        }
        else if (!isFocused) {
            this.adapter.closeOutline();
        }
    };
    /**
     * Sets the aria label of the leading icon.
     */
    MDCSelectFoundation.prototype.setLeadingIconAriaLabel = function (label) {
        if (this.leadingIcon) {
            this.leadingIcon.setAriaLabel(label);
        }
    };
    /**
     * Sets the text content of the leading icon.
     */
    MDCSelectFoundation.prototype.setLeadingIconContent = function (content) {
        if (this.leadingIcon) {
            this.leadingIcon.setContent(content);
        }
    };
    MDCSelectFoundation.prototype.getUseDefaultValidation = function () {
        return this.useDefaultValidation;
    };
    MDCSelectFoundation.prototype.setUseDefaultValidation = function (useDefaultValidation) {
        this.useDefaultValidation = useDefaultValidation;
    };
    MDCSelectFoundation.prototype.setValid = function (isValid) {
        if (!this.useDefaultValidation) {
            this.customValidity = isValid;
        }
        this.adapter.setSelectAnchorAttr('aria-invalid', (!isValid).toString());
        if (isValid) {
            this.adapter.removeClass(cssClasses$1.INVALID);
            this.adapter.removeMenuClass(cssClasses$1.MENU_INVALID);
        }
        else {
            this.adapter.addClass(cssClasses$1.INVALID);
            this.adapter.addMenuClass(cssClasses$1.MENU_INVALID);
        }
        this.syncHelperTextValidity(isValid);
    };
    MDCSelectFoundation.prototype.isValid = function () {
        if (this.useDefaultValidation &&
            this.adapter.hasClass(cssClasses$1.REQUIRED) &&
            !this.adapter.hasClass(cssClasses$1.DISABLED)) {
            // See notes for required attribute under https://www.w3.org/TR/html52/sec-forms.html#the-select-element
            // TL;DR: Invalid if no index is selected, or if the first index is selected and has an empty value.
            return this.getSelectedIndex() !== numbers$1.UNSET_INDEX &&
                (this.getSelectedIndex() !== 0 || Boolean(this.getValue()));
        }
        return this.customValidity;
    };
    MDCSelectFoundation.prototype.setRequired = function (isRequired) {
        if (isRequired) {
            this.adapter.addClass(cssClasses$1.REQUIRED);
        }
        else {
            this.adapter.removeClass(cssClasses$1.REQUIRED);
        }
        this.adapter.setSelectAnchorAttr('aria-required', isRequired.toString());
        this.adapter.setLabelRequired(isRequired);
    };
    MDCSelectFoundation.prototype.getRequired = function () {
        return this.adapter.getSelectAnchorAttr('aria-required') === 'true';
    };
    MDCSelectFoundation.prototype.init = function () {
        var anchorEl = this.adapter.getAnchorElement();
        if (anchorEl) {
            this.adapter.setMenuAnchorElement(anchorEl);
            this.adapter.setMenuAnchorCorner(Corner.BOTTOM_START);
        }
        this.adapter.setMenuWrapFocus(false);
        this.setDisabled(this.adapter.hasClass(cssClasses$1.DISABLED));
        this.syncHelperTextValidity(!this.adapter.hasClass(cssClasses$1.INVALID));
        this.layout();
        this.layoutOptions();
    };
    /**
     * Unfocuses the select component.
     */
    MDCSelectFoundation.prototype.blur = function () {
        this.adapter.removeClass(cssClasses$1.FOCUSED);
        this.layout();
        this.adapter.deactivateBottomLine();
        var isRequired = this.adapter.hasClass(cssClasses$1.REQUIRED);
        if (isRequired && this.useDefaultValidation) {
            this.setValid(this.isValid());
        }
    };
    MDCSelectFoundation.prototype.syncHelperTextValidity = function (isValid) {
        if (!this.helperText) {
            return;
        }
        this.helperText.setValidity(isValid);
        var helperTextVisible = this.helperText.isVisible();
        var helperTextId = this.helperText.getId();
        if (helperTextVisible && helperTextId) {
            this.adapter.setSelectAnchorAttr(strings$1.ARIA_DESCRIBEDBY, helperTextId);
        }
        else {
            // Needed because screenreaders will read labels pointed to by
            // `aria-describedby` even if they are `aria-hidden`.
            this.adapter.removeSelectAnchorAttr(strings$1.ARIA_DESCRIBEDBY);
        }
    };
    MDCSelectFoundation.prototype.setClickDebounceTimeout = function () {
        var _this = this;
        clearTimeout(this.clickDebounceTimeout);
        this.clickDebounceTimeout = setTimeout(function () {
            _this.recentlyClicked = false;
        }, numbers$1.CLICK_DEBOUNCE_TIMEOUT_MS);
        this.recentlyClicked = true;
    };
    return MDCSelectFoundation;
}(MDCFoundation$1));

/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const o=e$1(class extends i$3{constructor(t$1){var i;if(super(t$1),t$1.type!==t.ATTRIBUTE||"class"!==t$1.name||(null===(i=t$1.strings)||void 0===i?void 0:i.length)>2)throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.")}render(t){return " "+Object.keys(t).filter((i=>t[i])).join(" ")+" "}update(i,[s]){var r,o;if(void 0===this.et){this.et=new Set,void 0!==i.strings&&(this.st=new Set(i.strings.join(" ").split(/\s/).filter((t=>""!==t))));for(const t in s)s[t]&&!(null===(r=this.st)||void 0===r?void 0:r.has(t))&&this.et.add(t);return this.render(s)}const e=i.element.classList;this.et.forEach((t=>{t in s||(e.remove(t),this.et.delete(t));}));for(const t in s){const i=!!s[t];i===this.et.has(t)||(null===(o=this.st)||void 0===o?void 0:o.has(t))||(i?(e.add(t),this.et.add(t)):(e.remove(t),this.et.delete(t)));}return b}});

/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const l$1=l=>null!=l?l:w;

/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const createValidityObj$1 = (customValidity = {}) => {
    /*
     * We need to make ValidityState an object because it is readonly and
     * we cannot use the spread operator. Also, we don't export
     * `CustomValidityState` because it is a leaky implementation and the user
     * already has access to `ValidityState` in lib.dom.ts. Also an interface
     * {a: Type} can be casted to {readonly a: Type} so passing any object
     * should be fine.
     */
    const objectifiedCustomValidity = {};
    // eslint-disable-next-line guard-for-in
    for (const propName in customValidity) {
        /*
         * Casting is needed because ValidityState's props are all readonly and
         * thus cannot be set on `onjectifiedCustomValidity`. In the end, the
         * interface is the same as ValidityState (but not readonly), but the
         * function signature casts the output to ValidityState (thus readonly).
         */
        objectifiedCustomValidity[propName] =
            customValidity[propName];
    }
    return Object.assign({ badInput: false, customError: false, patternMismatch: false, rangeOverflow: false, rangeUnderflow: false, stepMismatch: false, tooLong: false, tooShort: false, typeMismatch: false, valid: true, valueMissing: false }, objectifiedCustomValidity);
};
/**
 * @fires selected {SelectedDetail}
 * @fires action {ActionDetail}
 * @fires opened
 * @fires closed
 * @fires change
 * @fires invalid
 */
class SelectBase extends FormElement {
    constructor() {
        super(...arguments);
        this.mdcFoundationClass = MDCSelectFoundation;
        this.disabled = false;
        this.outlined = false;
        this.label = '';
        this.outlineOpen = false;
        this.outlineWidth = 0;
        this.value = '';
        this.name = '';
        this.selectedText = '';
        this.icon = '';
        this.menuOpen = false;
        this.helper = '';
        this.validateOnInitialRender = false;
        this.validationMessage = '';
        this.required = false;
        this.naturalMenuWidth = false;
        this.isUiValid = true;
        this.fixedMenuPosition = false;
        // Transiently holds current typeahead prefix from user.
        this.typeaheadState = initState();
        this.sortedIndexByFirstChar = new Map();
        this.menuElement_ = null;
        this.listeners = [];
        this.onBodyClickBound = () => undefined;
        this._menuUpdateComplete = null;
        this.valueSetDirectly = false;
        this.validityTransform = null;
        this._validity = createValidityObj$1();
    }
    get items() {
        // memoize menuElement to prevent unnecessary querySelector calls.
        if (!this.menuElement_) {
            this.menuElement_ = this.menuElement;
        }
        if (this.menuElement_) {
            return this.menuElement_.items;
        }
        return [];
    }
    get selected() {
        const menuElement = this.menuElement;
        if (menuElement) {
            return menuElement.selected;
        }
        return null;
    }
    get index() {
        const menuElement = this.menuElement;
        if (menuElement) {
            return menuElement.index;
        }
        return -1;
    }
    get shouldRenderHelperText() {
        return !!this.helper || !!this.validationMessage;
    }
    get validity() {
        this._checkValidity(this.value);
        return this._validity;
    }
    render() {
        const classes = {
            'mdc-select--disabled': this.disabled,
            'mdc-select--no-label': !this.label,
            'mdc-select--filled': !this.outlined,
            'mdc-select--outlined': this.outlined,
            'mdc-select--with-leading-icon': !!this.icon,
            'mdc-select--required': this.required,
            'mdc-select--invalid': !this.isUiValid,
        };
        const menuClasses = {
            'mdc-select__menu--invalid': !this.isUiValid,
        };
        const labelledby = !!this.label ? 'label' : undefined;
        const describedby = this.shouldRenderHelperText ? 'helper-text' : undefined;
        return $ `
      <div
          class="mdc-select ${o(classes)}">
        <input
            class="formElement"
            name="${this.name}"
            .value="${this.value}"
            hidden
            ?disabled="${this.disabled}"
            ?required=${this.required}>
        <!-- @ts-ignore -->
        <div class="mdc-select__anchor"
            aria-autocomplete="none"
            role="combobox"
            aria-expanded=${this.menuOpen}
            aria-invalid=${!this.isUiValid}
            aria-haspopup="listbox"
            aria-labelledby=${l$1(labelledby)}
            aria-required=${this.required}
            aria-describedby=${l$1(describedby)}
            @click=${this.onClick}
            @focus=${this.onFocus}
            @blur=${this.onBlur}
            @keydown=${this.onKeydown}>
          ${this.renderRipple()}
          ${this.outlined ? this.renderOutline() : this.renderLabel()}
          ${this.renderLeadingIcon()}
          <span class="mdc-select__selected-text-container">
            <span class="mdc-select__selected-text">${this.selectedText}</span>
          </span>
          <span class="mdc-select__dropdown-icon">
            <svg
                class="mdc-select__dropdown-icon-graphic"
                viewBox="7 10 10 5"
                focusable="false">
              <polygon
                  class="mdc-select__dropdown-icon-inactive"
                  stroke="none"
                  fill-rule="evenodd"
                  points="7 10 12 15 17 10">
              </polygon>
              <polygon
                  class="mdc-select__dropdown-icon-active"
                  stroke="none"
                  fill-rule="evenodd"
                  points="7 15 12 10 17 15">
              </polygon>
            </svg>
          </span>
          ${this.renderLineRipple()}
        </div>
        <mwc-menu
            innerRole="listbox"
            wrapFocus
            class="mdc-select__menu mdc-menu mdc-menu-surface ${o(menuClasses)}"
            activatable
            .fullwidth=${this.fixedMenuPosition ? false : !this.naturalMenuWidth}
            .open=${this.menuOpen}
            .anchor=${this.anchorElement}
            .fixed=${this.fixedMenuPosition}
            @selected=${this.onSelected}
            @opened=${this.onOpened}
            @closed=${this.onClosed}
            @items-updated=${this.onItemsUpdated}
            @keydown=${this.handleTypeahead}>
          <slot></slot>
        </mwc-menu>
      </div>
      ${this.renderHelperText()}`;
    }
    renderRipple() {
        if (this.outlined) {
            return w;
        }
        return $ `
      <span class="mdc-select__ripple"></span>
    `;
    }
    renderOutline() {
        if (!this.outlined) {
            return w;
        }
        return $ `
      <mwc-notched-outline
          .width=${this.outlineWidth}
          .open=${this.outlineOpen}
          class="mdc-notched-outline">
        ${this.renderLabel()}
      </mwc-notched-outline>`;
    }
    renderLabel() {
        if (!this.label) {
            return w;
        }
        return $ `
      <span
          .floatingLabelFoundation=${floatingLabel(this.label)}
          id="label">${this.label}</span>
    `;
    }
    renderLeadingIcon() {
        if (!this.icon) {
            return w;
        }
        return $ `<mwc-icon class="mdc-select__icon"><div>${this.icon}</div></mwc-icon>`;
    }
    renderLineRipple() {
        if (this.outlined) {
            return w;
        }
        return $ `
      <span .lineRippleFoundation=${lineRipple()}></span>
    `;
    }
    renderHelperText() {
        if (!this.shouldRenderHelperText) {
            return w;
        }
        const showValidationMessage = this.validationMessage && !this.isUiValid;
        const classes = {
            'mdc-select-helper-text--validation-msg': showValidationMessage,
        };
        return $ `
        <p
          class="mdc-select-helper-text ${o(classes)}"
          id="helper-text">${showValidationMessage ? this.validationMessage : this.helper}</p>`;
    }
    createAdapter() {
        return Object.assign(Object.assign({}, addHasRemoveClass(this.mdcRoot)), { activateBottomLine: () => {
                if (this.lineRippleElement) {
                    this.lineRippleElement.lineRippleFoundation.activate();
                }
            }, deactivateBottomLine: () => {
                if (this.lineRippleElement) {
                    this.lineRippleElement.lineRippleFoundation.deactivate();
                }
            }, hasLabel: () => {
                return !!this.label;
            }, floatLabel: (shouldFloat) => {
                if (this.labelElement) {
                    this.labelElement.floatingLabelFoundation.float(shouldFloat);
                }
            }, getLabelWidth: () => {
                if (this.labelElement) {
                    return this.labelElement.floatingLabelFoundation.getWidth();
                }
                return 0;
            }, setLabelRequired: (isRequired) => {
                if (this.labelElement) {
                    this.labelElement.floatingLabelFoundation.setRequired(isRequired);
                }
            }, hasOutline: () => this.outlined, notchOutline: (labelWidth) => {
                const outlineElement = this.outlineElement;
                if (outlineElement && !this.outlineOpen) {
                    this.outlineWidth = labelWidth;
                    this.outlineOpen = true;
                }
            }, closeOutline: () => {
                if (this.outlineElement) {
                    this.outlineOpen = false;
                }
            }, setRippleCenter: (normalizedX) => {
                if (this.lineRippleElement) {
                    const foundation = this.lineRippleElement.lineRippleFoundation;
                    foundation.setRippleCenter(normalizedX);
                }
            }, notifyChange: async (value) => {
                if (!this.valueSetDirectly && value === this.value) {
                    return;
                }
                this.valueSetDirectly = false;
                this.value = value;
                await this.updateComplete;
                const ev = new Event('change', { bubbles: true });
                this.dispatchEvent(ev);
            }, setSelectedText: (value) => this.selectedText = value, isSelectAnchorFocused: () => {
                const selectAnchorElement = this.anchorElement;
                if (!selectAnchorElement) {
                    return false;
                }
                const rootNode = selectAnchorElement.getRootNode();
                return rootNode.activeElement === selectAnchorElement;
            }, getSelectAnchorAttr: (attr) => {
                const selectAnchorElement = this.anchorElement;
                if (!selectAnchorElement) {
                    return null;
                }
                return selectAnchorElement.getAttribute(attr);
            }, setSelectAnchorAttr: (attr, value) => {
                const selectAnchorElement = this.anchorElement;
                if (!selectAnchorElement) {
                    return;
                }
                selectAnchorElement.setAttribute(attr, value);
            }, removeSelectAnchorAttr: (attr) => {
                const selectAnchorElement = this.anchorElement;
                if (!selectAnchorElement) {
                    return;
                }
                selectAnchorElement.removeAttribute(attr);
            }, openMenu: () => {
                this.menuOpen = true;
            }, closeMenu: () => {
                this.menuOpen = false;
            }, addMenuClass: () => undefined, removeMenuClass: () => undefined, getAnchorElement: () => this.anchorElement, setMenuAnchorElement: () => {
                /* Handled by anchor directive */
            }, setMenuAnchorCorner: () => {
                const menuElement = this.menuElement;
                if (menuElement) {
                    menuElement.corner = 'BOTTOM_START';
                }
            }, setMenuWrapFocus: (wrapFocus) => {
                const menuElement = this.menuElement;
                if (menuElement) {
                    menuElement.wrapFocus = wrapFocus;
                }
            }, focusMenuItemAtIndex: (index) => {
                const menuElement = this.menuElement;
                if (!menuElement) {
                    return;
                }
                const element = menuElement.items[index];
                if (!element) {
                    return;
                }
                element.focus();
            }, getMenuItemCount: () => {
                const menuElement = this.menuElement;
                if (menuElement) {
                    return menuElement.items.length;
                }
                return 0;
            }, getMenuItemValues: () => {
                const menuElement = this.menuElement;
                if (!menuElement) {
                    return [];
                }
                const items = menuElement.items;
                return items.map((item) => item.value);
            }, getMenuItemTextAtIndex: (index) => {
                const menuElement = this.menuElement;
                if (!menuElement) {
                    return '';
                }
                const element = menuElement.items[index];
                if (!element) {
                    return '';
                }
                return element.text;
            }, getSelectedIndex: () => this.index, setSelectedIndex: () => undefined, isTypeaheadInProgress: () => isTypingInProgress(this.typeaheadState), typeaheadMatchItem: (nextChar, startingIndex) => {
                if (!this.menuElement) {
                    return -1;
                }
                const opts = {
                    focusItemAtIndex: (index) => {
                        this.menuElement.focusItemAtIndex(index);
                    },
                    focusedItemIndex: startingIndex ?
                        startingIndex :
                        this.menuElement.getFocusedItemIndex(),
                    nextChar,
                    sortedIndexByFirstChar: this.sortedIndexByFirstChar,
                    skipFocus: false,
                    isItemAtIndexDisabled: (index) => this.items[index].disabled,
                };
                const index = matchItem(opts, this.typeaheadState);
                if (index !== -1) {
                    this.select(index);
                }
                return index;
            } });
    }
    checkValidity() {
        const isValid = this._checkValidity(this.value);
        if (!isValid) {
            const invalidEvent = new Event('invalid', { bubbles: false, cancelable: true });
            this.dispatchEvent(invalidEvent);
        }
        return isValid;
    }
    reportValidity() {
        const isValid = this.checkValidity();
        this.isUiValid = isValid;
        return isValid;
    }
    _checkValidity(value) {
        const nativeValidity = this.formElement.validity;
        let validity = createValidityObj$1(nativeValidity);
        if (this.validityTransform) {
            const customValidity = this.validityTransform(value, validity);
            validity = Object.assign(Object.assign({}, validity), customValidity);
        }
        this._validity = validity;
        return this._validity.valid;
    }
    setCustomValidity(message) {
        this.validationMessage = message;
        this.formElement.setCustomValidity(message);
    }
    // tslint:disable:ban-ts-ignore
    async getUpdateComplete() {
        await this._menuUpdateComplete;
        // @ts-ignore
        const result = await super.getUpdateComplete();
        return result;
    }
    // tslint:enable:ban-ts-ignore
    async firstUpdated() {
        const menuElement = this.menuElement;
        if (menuElement) {
            this._menuUpdateComplete = menuElement.updateComplete;
            await this._menuUpdateComplete;
        }
        super.firstUpdated();
        this.mdcFoundation.isValid = () => true;
        this.mdcFoundation.setValid = () => undefined;
        this.mdcFoundation.setDisabled(this.disabled);
        if (this.validateOnInitialRender) {
            this.reportValidity();
        }
        // Select an option based on init value
        if (!this.selected) {
            if (!this.items.length && this.slotElement &&
                this.slotElement.assignedNodes({ flatten: true }).length) {
                // Shady DOM initial render fix
                await new Promise((res) => requestAnimationFrame(res));
                await this.layout();
            }
            const hasEmptyFirstOption = this.items.length && this.items[0].value === '';
            if (!this.value && hasEmptyFirstOption) {
                this.select(0);
                return;
            }
            this.selectByValue(this.value);
        }
        this.sortedIndexByFirstChar = initSortedIndex(this.items.length, (index) => this.items[index].text);
    }
    onItemsUpdated() {
        this.sortedIndexByFirstChar = initSortedIndex(this.items.length, (index) => this.items[index].text);
    }
    select(index) {
        const menuElement = this.menuElement;
        if (menuElement) {
            menuElement.select(index);
        }
    }
    selectByValue(value) {
        let indexToSelect = -1;
        for (let i = 0; i < this.items.length; i++) {
            const item = this.items[i];
            if (item.value === value) {
                indexToSelect = i;
                break;
            }
        }
        this.valueSetDirectly = true;
        this.select(indexToSelect);
        this.mdcFoundation.handleChange();
    }
    disconnectedCallback() {
        super.disconnectedCallback();
        for (const listener of this.listeners) {
            listener.target.removeEventListener(listener.name, listener.cb);
        }
    }
    focus() {
        const focusEvt = new CustomEvent('focus');
        const selectAnchorElement = this.anchorElement;
        if (selectAnchorElement) {
            selectAnchorElement.dispatchEvent(focusEvt);
            selectAnchorElement.focus();
        }
    }
    blur() {
        const focusEvt = new CustomEvent('blur');
        const selectAnchorElement = this.anchorElement;
        if (selectAnchorElement) {
            selectAnchorElement.dispatchEvent(focusEvt);
            selectAnchorElement.blur();
        }
    }
    onFocus() {
        if (this.mdcFoundation) {
            this.mdcFoundation.handleFocus();
        }
    }
    onBlur() {
        if (this.mdcFoundation) {
            this.mdcFoundation.handleBlur();
        }
        const menuElement = this.menuElement;
        if (menuElement && !menuElement.open) {
            this.reportValidity();
        }
    }
    onClick(evt) {
        if (this.mdcFoundation) {
            this.focus();
            const targetClientRect = evt.target.getBoundingClientRect();
            let xCoord = 0;
            if ('touches' in evt) {
                xCoord = evt.touches[0].clientX;
            }
            else {
                xCoord = evt.clientX;
            }
            const normalizedX = xCoord - targetClientRect.left;
            this.mdcFoundation.handleClick(normalizedX);
        }
    }
    onKeydown(evt) {
        const arrowUp = normalizeKey$2(evt) === KEY$2.ARROW_UP;
        const arrowDown = normalizeKey$2(evt) === KEY$2.ARROW_DOWN;
        if (arrowDown || arrowUp) {
            const shouldSelectNextItem = arrowUp && this.index > 0;
            const shouldSelectPrevItem = arrowDown && this.index < this.items.length - 1;
            if (shouldSelectNextItem) {
                this.select(this.index - 1);
            }
            else if (shouldSelectPrevItem) {
                this.select(this.index + 1);
            }
            evt.preventDefault();
            this.mdcFoundation.openMenu();
            return;
        }
        this.mdcFoundation.handleKeydown(evt);
    }
    // must capture to run before list foundation captures event
    handleTypeahead(event) {
        if (!this.menuElement) {
            return;
        }
        const focusedItemIndex = this.menuElement.getFocusedItemIndex();
        const target = isNodeElement(event.target) ?
            event.target :
            null;
        const isTargetListItem = target ? target.hasAttribute('mwc-list-item') : false;
        const opts = {
            event,
            focusItemAtIndex: (index) => {
                this.menuElement.focusItemAtIndex(index);
            },
            focusedItemIndex,
            isTargetListItem,
            sortedIndexByFirstChar: this.sortedIndexByFirstChar,
            isItemAtIndexDisabled: (index) => this.items[index].disabled,
        };
        handleKeydown(opts, this.typeaheadState);
    }
    async onSelected(event) {
        if (!this.mdcFoundation) {
            await this.updateComplete;
        }
        this.mdcFoundation.handleMenuItemAction(event.detail.index);
        const item = this.items[event.detail.index];
        if (item) {
            this.value = item.value;
        }
    }
    onOpened() {
        if (this.mdcFoundation) {
            this.menuOpen = true;
            this.mdcFoundation.handleMenuOpened();
        }
    }
    onClosed() {
        if (this.mdcFoundation) {
            this.menuOpen = false;
            this.mdcFoundation.handleMenuClosed();
        }
    }
    setFormData(formData) {
        if (this.name && this.selected !== null) {
            formData.append(this.name, this.value);
        }
    }
    async layout(updateItems = true) {
        if (this.mdcFoundation) {
            this.mdcFoundation.layout();
        }
        await this.updateComplete;
        const menuElement = this.menuElement;
        if (menuElement) {
            menuElement.layout(updateItems);
        }
        const labelElement = this.labelElement;
        if (!labelElement) {
            this.outlineOpen = false;
            return;
        }
        const shouldFloat = !!this.label && !!this.value;
        labelElement.floatingLabelFoundation.float(shouldFloat);
        if (!this.outlined) {
            return;
        }
        this.outlineOpen = shouldFloat;
        await this.updateComplete;
        /* When the textfield automatically notches due to a value and label
         * being defined, the textfield may be set to `display: none` by the user.
         * this means that the notch is of size 0px. We provide this function so
         * that the user may manually resize the notch to the floated label's
         * width.
         */
        const labelWidth = labelElement.floatingLabelFoundation.getWidth();
        if (this.outlineOpen) {
            this.outlineWidth = labelWidth;
        }
    }
    async layoutOptions() {
        if (!this.mdcFoundation) {
            return;
        }
        this.mdcFoundation.layoutOptions();
    }
}
__decorate([
    i$4('.mdc-select')
], SelectBase.prototype, "mdcRoot", void 0);
__decorate([
    i$4('.formElement')
], SelectBase.prototype, "formElement", void 0);
__decorate([
    i$4('slot')
], SelectBase.prototype, "slotElement", void 0);
__decorate([
    i$4('select')
], SelectBase.prototype, "nativeSelectElement", void 0);
__decorate([
    i$4('input')
], SelectBase.prototype, "nativeInputElement", void 0);
__decorate([
    i$4('.mdc-line-ripple')
], SelectBase.prototype, "lineRippleElement", void 0);
__decorate([
    i$4('.mdc-floating-label')
], SelectBase.prototype, "labelElement", void 0);
__decorate([
    i$4('mwc-notched-outline')
], SelectBase.prototype, "outlineElement", void 0);
__decorate([
    i$4('.mdc-menu')
], SelectBase.prototype, "menuElement", void 0);
__decorate([
    i$4('.mdc-select__anchor')
], SelectBase.prototype, "anchorElement", void 0);
__decorate([
    e$3({ type: Boolean, attribute: 'disabled', reflect: true }),
    observer(function (value) {
        if (this.mdcFoundation) {
            this.mdcFoundation.setDisabled(value);
        }
    })
], SelectBase.prototype, "disabled", void 0);
__decorate([
    e$3({ type: Boolean }),
    observer(function (_newVal, oldVal) {
        if (oldVal !== undefined && this.outlined !== oldVal) {
            this.layout(false);
        }
    })
], SelectBase.prototype, "outlined", void 0);
__decorate([
    e$3({ type: String }),
    observer(function (_newVal, oldVal) {
        if (oldVal !== undefined && this.label !== oldVal) {
            this.layout(false);
        }
    })
], SelectBase.prototype, "label", void 0);
__decorate([
    t$1()
], SelectBase.prototype, "outlineOpen", void 0);
__decorate([
    t$1()
], SelectBase.prototype, "outlineWidth", void 0);
__decorate([
    e$3({ type: String }),
    observer(function (value) {
        if (this.mdcFoundation) {
            const initialization = this.selected === null && !!value;
            const valueSetByUser = this.selected && this.selected.value !== value;
            if (initialization || valueSetByUser) {
                this.selectByValue(value);
            }
            this.reportValidity();
        }
    })
], SelectBase.prototype, "value", void 0);
__decorate([
    e$3()
], SelectBase.prototype, "name", void 0);
__decorate([
    t$1()
], SelectBase.prototype, "selectedText", void 0);
__decorate([
    e$3({ type: String })
], SelectBase.prototype, "icon", void 0);
__decorate([
    t$1()
], SelectBase.prototype, "menuOpen", void 0);
__decorate([
    e$3({ type: String })
], SelectBase.prototype, "helper", void 0);
__decorate([
    e$3({ type: Boolean })
], SelectBase.prototype, "validateOnInitialRender", void 0);
__decorate([
    e$3({ type: String })
], SelectBase.prototype, "validationMessage", void 0);
__decorate([
    e$3({ type: Boolean })
], SelectBase.prototype, "required", void 0);
__decorate([
    e$3({ type: Boolean })
], SelectBase.prototype, "naturalMenuWidth", void 0);
__decorate([
    t$1()
], SelectBase.prototype, "isUiValid", void 0);
__decorate([
    e$3({ type: Boolean })
], SelectBase.prototype, "fixedMenuPosition", void 0);
__decorate([
    e$2({ capture: true })
], SelectBase.prototype, "handleTypeahead", null);

/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-LIcense-Identifier: Apache-2.0
 */
const styles$1 = r$3 `.mdc-floating-label{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:Roboto, sans-serif;font-family:var(--mdc-typography-subtitle1-font-family, var(--mdc-typography-font-family, Roboto, sans-serif));font-size:1rem;font-size:var(--mdc-typography-subtitle1-font-size, 1rem);font-weight:400;font-weight:var(--mdc-typography-subtitle1-font-weight, 400);letter-spacing:0.009375em;letter-spacing:var(--mdc-typography-subtitle1-letter-spacing, 0.009375em);text-decoration:inherit;text-decoration:var(--mdc-typography-subtitle1-text-decoration, inherit);text-transform:inherit;text-transform:var(--mdc-typography-subtitle1-text-transform, inherit);position:absolute;left:0;-webkit-transform-origin:left top;transform-origin:left top;line-height:1.15rem;text-align:left;text-overflow:ellipsis;white-space:nowrap;cursor:text;overflow:hidden;will-change:transform;transition:transform 150ms cubic-bezier(0.4, 0, 0.2, 1),color 150ms cubic-bezier(0.4, 0, 0.2, 1)}[dir=rtl] .mdc-floating-label,.mdc-floating-label[dir=rtl]{right:0;left:auto;-webkit-transform-origin:right top;transform-origin:right top;text-align:right}.mdc-floating-label--float-above{cursor:auto}.mdc-floating-label--required::after{margin-left:1px;margin-right:0px;content:"*"}[dir=rtl] .mdc-floating-label--required::after,.mdc-floating-label--required[dir=rtl]::after{margin-left:0;margin-right:1px}.mdc-floating-label--float-above{transform:translateY(-106%) scale(0.75)}.mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-standard 250ms 1}@keyframes mdc-floating-label-shake-float-above-standard{0%{transform:translateX(calc(0 - 0%)) translateY(-106%) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 0%)) translateY(-106%) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 0%)) translateY(-106%) scale(0.75)}100%{transform:translateX(calc(0 - 0%)) translateY(-106%) scale(0.75)}}@keyframes mdc-ripple-fg-radius-in{from{animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transform:translate(var(--mdc-ripple-fg-translate-start, 0)) scale(1)}to{transform:translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1))}}@keyframes mdc-ripple-fg-opacity-in{from{animation-timing-function:linear;opacity:0}to{opacity:var(--mdc-ripple-fg-opacity, 0)}}@keyframes mdc-ripple-fg-opacity-out{from{animation-timing-function:linear;opacity:var(--mdc-ripple-fg-opacity, 0)}to{opacity:0}}.mdc-line-ripple::before,.mdc-line-ripple::after{position:absolute;bottom:0;left:0;width:100%;border-bottom-style:solid;content:""}.mdc-line-ripple::before{border-bottom-width:1px;z-index:1}.mdc-line-ripple::after{transform:scaleX(0);border-bottom-width:2px;opacity:0;z-index:2}.mdc-line-ripple::after{transition:transform 180ms cubic-bezier(0.4, 0, 0.2, 1),opacity 180ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-line-ripple--active::after{transform:scaleX(1);opacity:1}.mdc-line-ripple--deactivating::after{opacity:0}.mdc-notched-outline{display:flex;position:absolute;top:0;right:0;left:0;box-sizing:border-box;width:100%;max-width:100%;height:100%;text-align:left;pointer-events:none}[dir=rtl] .mdc-notched-outline,.mdc-notched-outline[dir=rtl]{text-align:right}.mdc-notched-outline__leading,.mdc-notched-outline__notch,.mdc-notched-outline__trailing{box-sizing:border-box;height:100%;border-top:1px solid;border-bottom:1px solid;pointer-events:none}.mdc-notched-outline__leading{border-left:1px solid;border-right:none;width:12px}[dir=rtl] .mdc-notched-outline__leading,.mdc-notched-outline__leading[dir=rtl]{border-left:none;border-right:1px solid}.mdc-notched-outline__trailing{border-left:none;border-right:1px solid;flex-grow:1}[dir=rtl] .mdc-notched-outline__trailing,.mdc-notched-outline__trailing[dir=rtl]{border-left:1px solid;border-right:none}.mdc-notched-outline__notch{flex:0 0 auto;width:auto;max-width:calc(100% - 12px * 2)}.mdc-notched-outline .mdc-floating-label{display:inline-block;position:relative;max-width:100%}.mdc-notched-outline .mdc-floating-label--float-above{text-overflow:clip}.mdc-notched-outline--upgraded .mdc-floating-label--float-above{max-width:calc(100% / 0.75)}.mdc-notched-outline--notched .mdc-notched-outline__notch{padding-left:0;padding-right:8px;border-top:none}[dir=rtl] .mdc-notched-outline--notched .mdc-notched-outline__notch,.mdc-notched-outline--notched .mdc-notched-outline__notch[dir=rtl]{padding-left:8px;padding-right:0}.mdc-notched-outline--no-label .mdc-notched-outline__notch{display:none}.mdc-select{display:inline-flex;position:relative}.mdc-select:not(.mdc-select--disabled) .mdc-select__selected-text{color:rgba(0, 0, 0, 0.87)}.mdc-select.mdc-select--disabled .mdc-select__selected-text{color:rgba(0, 0, 0, 0.38)}.mdc-select:not(.mdc-select--disabled) .mdc-floating-label{color:rgba(0, 0, 0, 0.6)}.mdc-select:not(.mdc-select--disabled).mdc-select--focused .mdc-floating-label{color:rgba(98, 0, 238, 0.87)}.mdc-select.mdc-select--disabled .mdc-floating-label{color:rgba(0, 0, 0, 0.38)}.mdc-select:not(.mdc-select--disabled) .mdc-select__dropdown-icon{fill:rgba(0, 0, 0, 0.54)}.mdc-select:not(.mdc-select--disabled).mdc-select--focused .mdc-select__dropdown-icon{fill:#6200ee;fill:var(--mdc-theme-primary, #6200ee)}.mdc-select.mdc-select--disabled .mdc-select__dropdown-icon{fill:rgba(0, 0, 0, 0.38)}.mdc-select:not(.mdc-select--disabled)+.mdc-select-helper-text{color:rgba(0, 0, 0, 0.6)}.mdc-select.mdc-select--disabled+.mdc-select-helper-text{color:rgba(0, 0, 0, 0.38)}.mdc-select:not(.mdc-select--disabled) .mdc-select__icon{color:rgba(0, 0, 0, 0.54)}.mdc-select.mdc-select--disabled .mdc-select__icon{color:rgba(0, 0, 0, 0.38)}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mdc-select.mdc-select--disabled .mdc-select__selected-text{color:GrayText}.mdc-select.mdc-select--disabled .mdc-select__dropdown-icon{fill:red}.mdc-select.mdc-select--disabled .mdc-floating-label{color:GrayText}.mdc-select.mdc-select--disabled .mdc-line-ripple::before{border-bottom-color:GrayText}.mdc-select.mdc-select--disabled .mdc-notched-outline__leading,.mdc-select.mdc-select--disabled .mdc-notched-outline__notch,.mdc-select.mdc-select--disabled .mdc-notched-outline__trailing{border-color:GrayText}.mdc-select.mdc-select--disabled .mdc-select__icon{color:GrayText}.mdc-select.mdc-select--disabled+.mdc-select-helper-text{color:GrayText}}.mdc-select .mdc-floating-label{top:50%;transform:translateY(-50%);pointer-events:none}.mdc-select .mdc-select__anchor{padding-left:16px;padding-right:0}[dir=rtl] .mdc-select .mdc-select__anchor,.mdc-select .mdc-select__anchor[dir=rtl]{padding-left:0;padding-right:16px}.mdc-select.mdc-select--with-leading-icon .mdc-select__anchor{padding-left:0;padding-right:0}[dir=rtl] .mdc-select.mdc-select--with-leading-icon .mdc-select__anchor,.mdc-select.mdc-select--with-leading-icon .mdc-select__anchor[dir=rtl]{padding-left:0;padding-right:0}.mdc-select .mdc-select__icon{width:24px;height:24px;font-size:24px}.mdc-select .mdc-select__dropdown-icon{width:24px;height:24px}.mdc-select .mdc-select__menu .mdc-deprecated-list-item{padding-left:16px;padding-right:16px}[dir=rtl] .mdc-select .mdc-select__menu .mdc-deprecated-list-item,.mdc-select .mdc-select__menu .mdc-deprecated-list-item[dir=rtl]{padding-left:16px;padding-right:16px}.mdc-select .mdc-select__menu .mdc-deprecated-list-item__graphic{margin-left:0;margin-right:12px}[dir=rtl] .mdc-select .mdc-select__menu .mdc-deprecated-list-item__graphic,.mdc-select .mdc-select__menu .mdc-deprecated-list-item__graphic[dir=rtl]{margin-left:12px;margin-right:0}.mdc-select__dropdown-icon{margin-left:12px;margin-right:12px;display:inline-flex;position:relative;align-self:center;align-items:center;justify-content:center;flex-shrink:0;pointer-events:none}.mdc-select__dropdown-icon .mdc-select__dropdown-icon-active,.mdc-select__dropdown-icon .mdc-select__dropdown-icon-inactive{position:absolute;top:0;left:0}.mdc-select__dropdown-icon .mdc-select__dropdown-icon-graphic{width:41.6666666667%;height:20.8333333333%}.mdc-select__dropdown-icon .mdc-select__dropdown-icon-inactive{opacity:1;transition:opacity 75ms linear 75ms}.mdc-select__dropdown-icon .mdc-select__dropdown-icon-active{opacity:0;transition:opacity 75ms linear}[dir=rtl] .mdc-select__dropdown-icon,.mdc-select__dropdown-icon[dir=rtl]{margin-left:12px;margin-right:12px}.mdc-select--activated .mdc-select__dropdown-icon .mdc-select__dropdown-icon-inactive{opacity:0;transition:opacity 49.5ms linear}.mdc-select--activated .mdc-select__dropdown-icon .mdc-select__dropdown-icon-active{opacity:1;transition:opacity 100.5ms linear 49.5ms}.mdc-select__anchor{width:200px;min-width:0;flex:1 1 auto;position:relative;box-sizing:border-box;overflow:hidden;outline:none;cursor:pointer}.mdc-select__anchor .mdc-floating-label--float-above{transform:translateY(-106%) scale(0.75)}.mdc-select__selected-text-container{display:flex;appearance:none;pointer-events:none;box-sizing:border-box;width:auto;min-width:0;flex-grow:1;height:28px;border:none;outline:none;padding:0;background-color:transparent;color:inherit}.mdc-select__selected-text{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:Roboto, sans-serif;font-family:var(--mdc-typography-subtitle1-font-family, var(--mdc-typography-font-family, Roboto, sans-serif));font-size:1rem;font-size:var(--mdc-typography-subtitle1-font-size, 1rem);line-height:1.75rem;line-height:var(--mdc-typography-subtitle1-line-height, 1.75rem);font-weight:400;font-weight:var(--mdc-typography-subtitle1-font-weight, 400);letter-spacing:0.009375em;letter-spacing:var(--mdc-typography-subtitle1-letter-spacing, 0.009375em);text-decoration:inherit;text-decoration:var(--mdc-typography-subtitle1-text-decoration, inherit);text-transform:inherit;text-transform:var(--mdc-typography-subtitle1-text-transform, inherit);text-overflow:ellipsis;white-space:nowrap;overflow:hidden;display:block;width:100%;text-align:left}[dir=rtl] .mdc-select__selected-text,.mdc-select__selected-text[dir=rtl]{text-align:right}.mdc-select--invalid:not(.mdc-select--disabled) .mdc-floating-label{color:#b00020;color:var(--mdc-theme-error, #b00020)}.mdc-select--invalid:not(.mdc-select--disabled).mdc-select--focused .mdc-floating-label{color:#b00020;color:var(--mdc-theme-error, #b00020)}.mdc-select--invalid:not(.mdc-select--disabled).mdc-select--invalid+.mdc-select-helper-text--validation-msg{color:#b00020;color:var(--mdc-theme-error, #b00020)}.mdc-select--invalid:not(.mdc-select--disabled) .mdc-select__dropdown-icon{fill:#b00020;fill:var(--mdc-theme-error, #b00020)}.mdc-select--invalid:not(.mdc-select--disabled).mdc-select--focused .mdc-select__dropdown-icon{fill:#b00020;fill:var(--mdc-theme-error, #b00020)}.mdc-select--disabled{cursor:default;pointer-events:none}.mdc-select--with-leading-icon .mdc-select__menu .mdc-deprecated-list-item{padding-left:12px;padding-right:12px}[dir=rtl] .mdc-select--with-leading-icon .mdc-select__menu .mdc-deprecated-list-item,.mdc-select--with-leading-icon .mdc-select__menu .mdc-deprecated-list-item[dir=rtl]{padding-left:12px;padding-right:12px}.mdc-select__menu .mdc-deprecated-list .mdc-select__icon,.mdc-select__menu .mdc-list .mdc-select__icon{margin-left:0;margin-right:0}[dir=rtl] .mdc-select__menu .mdc-deprecated-list .mdc-select__icon,[dir=rtl] .mdc-select__menu .mdc-list .mdc-select__icon,.mdc-select__menu .mdc-deprecated-list .mdc-select__icon[dir=rtl],.mdc-select__menu .mdc-list .mdc-select__icon[dir=rtl]{margin-left:0;margin-right:0}.mdc-select__menu .mdc-deprecated-list .mdc-deprecated-list-item--selected,.mdc-select__menu .mdc-deprecated-list .mdc-deprecated-list-item--activated,.mdc-select__menu .mdc-list .mdc-deprecated-list-item--selected,.mdc-select__menu .mdc-list .mdc-deprecated-list-item--activated{color:#000;color:var(--mdc-theme-on-surface, #000)}.mdc-select__menu .mdc-deprecated-list .mdc-deprecated-list-item--selected .mdc-deprecated-list-item__graphic,.mdc-select__menu .mdc-deprecated-list .mdc-deprecated-list-item--activated .mdc-deprecated-list-item__graphic,.mdc-select__menu .mdc-list .mdc-deprecated-list-item--selected .mdc-deprecated-list-item__graphic,.mdc-select__menu .mdc-list .mdc-deprecated-list-item--activated .mdc-deprecated-list-item__graphic{color:#000;color:var(--mdc-theme-on-surface, #000)}.mdc-select__menu .mdc-list-item__start{display:inline-flex;align-items:center}.mdc-select__option{padding-left:16px;padding-right:16px}[dir=rtl] .mdc-select__option,.mdc-select__option[dir=rtl]{padding-left:16px;padding-right:16px}.mdc-select__one-line-option.mdc-list-item--with-one-line{height:48px}.mdc-select__two-line-option.mdc-list-item--with-two-lines{height:64px}.mdc-select__two-line-option.mdc-list-item--with-two-lines .mdc-list-item__start{margin-top:20px}.mdc-select__two-line-option.mdc-list-item--with-two-lines .mdc-list-item__primary-text{display:block;margin-top:0;line-height:normal;margin-bottom:-20px}.mdc-select__two-line-option.mdc-list-item--with-two-lines .mdc-list-item__primary-text::before{display:inline-block;width:0;height:28px;content:"";vertical-align:0}.mdc-select__two-line-option.mdc-list-item--with-two-lines .mdc-list-item__primary-text::after{display:inline-block;width:0;height:20px;content:"";vertical-align:-20px}.mdc-select__two-line-option.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end{display:block;margin-top:0;line-height:normal}.mdc-select__two-line-option.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end::before{display:inline-block;width:0;height:36px;content:"";vertical-align:0}.mdc-select__option-with-leading-content{padding-left:0;padding-right:12px}.mdc-select__option-with-leading-content.mdc-list-item{padding-left:0;padding-right:auto}[dir=rtl] .mdc-select__option-with-leading-content.mdc-list-item,.mdc-select__option-with-leading-content.mdc-list-item[dir=rtl]{padding-left:auto;padding-right:0}.mdc-select__option-with-leading-content .mdc-list-item__start{margin-left:12px;margin-right:0}[dir=rtl] .mdc-select__option-with-leading-content .mdc-list-item__start,.mdc-select__option-with-leading-content .mdc-list-item__start[dir=rtl]{margin-left:0;margin-right:12px}.mdc-select__option-with-leading-content .mdc-list-item__start{width:36px;height:24px}[dir=rtl] .mdc-select__option-with-leading-content,.mdc-select__option-with-leading-content[dir=rtl]{padding-left:12px;padding-right:0}.mdc-select__option-with-meta.mdc-list-item{padding-left:auto;padding-right:0}[dir=rtl] .mdc-select__option-with-meta.mdc-list-item,.mdc-select__option-with-meta.mdc-list-item[dir=rtl]{padding-left:0;padding-right:auto}.mdc-select__option-with-meta .mdc-list-item__end{margin-left:12px;margin-right:12px}[dir=rtl] .mdc-select__option-with-meta .mdc-list-item__end,.mdc-select__option-with-meta .mdc-list-item__end[dir=rtl]{margin-left:12px;margin-right:12px}.mdc-select--filled .mdc-select__anchor{height:56px;display:flex;align-items:baseline}.mdc-select--filled .mdc-select__anchor::before{display:inline-block;width:0;height:40px;content:"";vertical-align:0}.mdc-select--filled.mdc-select--no-label .mdc-select__anchor .mdc-select__selected-text::before{content:"​"}.mdc-select--filled.mdc-select--no-label .mdc-select__anchor .mdc-select__selected-text-container{height:100%;display:inline-flex;align-items:center}.mdc-select--filled.mdc-select--no-label .mdc-select__anchor::before{display:none}.mdc-select--filled .mdc-select__anchor{border-top-left-radius:4px;border-top-left-radius:var(--mdc-shape-small, 4px);border-top-right-radius:4px;border-top-right-radius:var(--mdc-shape-small, 4px);border-bottom-right-radius:0;border-bottom-left-radius:0}.mdc-select--filled:not(.mdc-select--disabled) .mdc-select__anchor{background-color:whitesmoke}.mdc-select--filled.mdc-select--disabled .mdc-select__anchor{background-color:#fafafa}.mdc-select--filled:not(.mdc-select--disabled) .mdc-line-ripple::before{border-bottom-color:rgba(0, 0, 0, 0.42)}.mdc-select--filled:not(.mdc-select--disabled):hover .mdc-line-ripple::before{border-bottom-color:rgba(0, 0, 0, 0.87)}.mdc-select--filled:not(.mdc-select--disabled) .mdc-line-ripple::after{border-bottom-color:#6200ee;border-bottom-color:var(--mdc-theme-primary, #6200ee)}.mdc-select--filled.mdc-select--disabled .mdc-line-ripple::before{border-bottom-color:rgba(0, 0, 0, 0.06)}.mdc-select--filled .mdc-floating-label{max-width:calc(100% - 64px)}.mdc-select--filled .mdc-floating-label--float-above{max-width:calc(100% / 0.75 - 64px / 0.75)}.mdc-select--filled .mdc-menu-surface--is-open-below{border-top-left-radius:0px;border-top-right-radius:0px}.mdc-select--filled.mdc-select--focused.mdc-line-ripple::after{transform:scale(1, 2);opacity:1}.mdc-select--filled .mdc-floating-label{left:16px;right:initial}[dir=rtl] .mdc-select--filled .mdc-floating-label,.mdc-select--filled .mdc-floating-label[dir=rtl]{left:initial;right:16px}.mdc-select--filled.mdc-select--with-leading-icon .mdc-floating-label{left:48px;right:initial}[dir=rtl] .mdc-select--filled.mdc-select--with-leading-icon .mdc-floating-label,.mdc-select--filled.mdc-select--with-leading-icon .mdc-floating-label[dir=rtl]{left:initial;right:48px}.mdc-select--filled.mdc-select--with-leading-icon .mdc-floating-label{max-width:calc(100% - 96px)}.mdc-select--filled.mdc-select--with-leading-icon .mdc-floating-label--float-above{max-width:calc(100% / 0.75 - 96px / 0.75)}.mdc-select--invalid:not(.mdc-select--disabled) .mdc-line-ripple::before{border-bottom-color:#b00020;border-bottom-color:var(--mdc-theme-error, #b00020)}.mdc-select--invalid:not(.mdc-select--disabled):hover .mdc-line-ripple::before{border-bottom-color:#b00020;border-bottom-color:var(--mdc-theme-error, #b00020)}.mdc-select--invalid:not(.mdc-select--disabled) .mdc-line-ripple::after{border-bottom-color:#b00020;border-bottom-color:var(--mdc-theme-error, #b00020)}.mdc-select--outlined{border:none}.mdc-select--outlined .mdc-select__anchor{height:56px}.mdc-select--outlined .mdc-select__anchor .mdc-floating-label--float-above{transform:translateY(-37.25px) scale(1)}.mdc-select--outlined .mdc-select__anchor .mdc-floating-label--float-above{font-size:.75rem}.mdc-select--outlined .mdc-select__anchor.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-select--outlined .mdc-select__anchor .mdc-notched-outline--upgraded .mdc-floating-label--float-above{transform:translateY(-34.75px) scale(0.75)}.mdc-select--outlined .mdc-select__anchor.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-select--outlined .mdc-select__anchor .mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:1rem}.mdc-select--outlined .mdc-select__anchor .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-select-outlined-56px 250ms 1}@keyframes mdc-floating-label-shake-float-above-select-outlined-56px{0%{transform:translateX(calc(0 - 0%)) translateY(-34.75px) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 0%)) translateY(-34.75px) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 0%)) translateY(-34.75px) scale(0.75)}100%{transform:translateX(calc(0 - 0%)) translateY(-34.75px) scale(0.75)}}.mdc-select--outlined .mdc-notched-outline .mdc-notched-outline__leading{border-top-left-radius:4px;border-top-left-radius:var(--mdc-shape-small, 4px);border-top-right-radius:0;border-bottom-right-radius:0;border-bottom-left-radius:4px;border-bottom-left-radius:var(--mdc-shape-small, 4px)}[dir=rtl] .mdc-select--outlined .mdc-notched-outline .mdc-notched-outline__leading,.mdc-select--outlined .mdc-notched-outline .mdc-notched-outline__leading[dir=rtl]{border-top-left-radius:0;border-top-right-radius:4px;border-top-right-radius:var(--mdc-shape-small, 4px);border-bottom-right-radius:4px;border-bottom-right-radius:var(--mdc-shape-small, 4px);border-bottom-left-radius:0}@supports(top: max(0%)){.mdc-select--outlined .mdc-notched-outline .mdc-notched-outline__leading{width:max(12px, var(--mdc-shape-small, 4px))}}@supports(top: max(0%)){.mdc-select--outlined .mdc-notched-outline .mdc-notched-outline__notch{max-width:calc(100% - max(12px, var(--mdc-shape-small, 4px)) * 2)}}.mdc-select--outlined .mdc-notched-outline .mdc-notched-outline__trailing{border-top-left-radius:0;border-top-right-radius:4px;border-top-right-radius:var(--mdc-shape-small, 4px);border-bottom-right-radius:4px;border-bottom-right-radius:var(--mdc-shape-small, 4px);border-bottom-left-radius:0}[dir=rtl] .mdc-select--outlined .mdc-notched-outline .mdc-notched-outline__trailing,.mdc-select--outlined .mdc-notched-outline .mdc-notched-outline__trailing[dir=rtl]{border-top-left-radius:4px;border-top-left-radius:var(--mdc-shape-small, 4px);border-top-right-radius:0;border-bottom-right-radius:0;border-bottom-left-radius:4px;border-bottom-left-radius:var(--mdc-shape-small, 4px)}@supports(top: max(0%)){.mdc-select--outlined .mdc-select__anchor{padding-left:max(16px, calc(var(--mdc-shape-small, 4px) + 4px))}}[dir=rtl] .mdc-select--outlined .mdc-select__anchor,.mdc-select--outlined .mdc-select__anchor[dir=rtl]{padding-left:0}@supports(top: max(0%)){[dir=rtl] .mdc-select--outlined .mdc-select__anchor,.mdc-select--outlined .mdc-select__anchor[dir=rtl]{padding-right:max(16px, calc(var(--mdc-shape-small, 4px) + 4px))}}@supports(top: max(0%)){.mdc-select--outlined+.mdc-select-helper-text{margin-left:max(16px, calc(var(--mdc-shape-small, 4px) + 4px))}}[dir=rtl] .mdc-select--outlined+.mdc-select-helper-text,.mdc-select--outlined+.mdc-select-helper-text[dir=rtl]{margin-left:0}@supports(top: max(0%)){[dir=rtl] .mdc-select--outlined+.mdc-select-helper-text,.mdc-select--outlined+.mdc-select-helper-text[dir=rtl]{margin-right:max(16px, calc(var(--mdc-shape-small, 4px) + 4px))}}.mdc-select--outlined:not(.mdc-select--disabled) .mdc-select__anchor{background-color:transparent}.mdc-select--outlined.mdc-select--disabled .mdc-select__anchor{background-color:transparent}.mdc-select--outlined:not(.mdc-select--disabled) .mdc-notched-outline__leading,.mdc-select--outlined:not(.mdc-select--disabled) .mdc-notched-outline__notch,.mdc-select--outlined:not(.mdc-select--disabled) .mdc-notched-outline__trailing{border-color:rgba(0, 0, 0, 0.38)}.mdc-select--outlined:not(.mdc-select--disabled):not(.mdc-select--focused) .mdc-select__anchor:hover .mdc-notched-outline .mdc-notched-outline__leading,.mdc-select--outlined:not(.mdc-select--disabled):not(.mdc-select--focused) .mdc-select__anchor:hover .mdc-notched-outline .mdc-notched-outline__notch,.mdc-select--outlined:not(.mdc-select--disabled):not(.mdc-select--focused) .mdc-select__anchor:hover .mdc-notched-outline .mdc-notched-outline__trailing{border-color:rgba(0, 0, 0, 0.87)}.mdc-select--outlined:not(.mdc-select--disabled).mdc-select--focused .mdc-notched-outline .mdc-notched-outline__leading,.mdc-select--outlined:not(.mdc-select--disabled).mdc-select--focused .mdc-notched-outline .mdc-notched-outline__notch,.mdc-select--outlined:not(.mdc-select--disabled).mdc-select--focused .mdc-notched-outline .mdc-notched-outline__trailing{border-width:2px}.mdc-select--outlined:not(.mdc-select--disabled).mdc-select--focused .mdc-notched-outline .mdc-notched-outline__leading,.mdc-select--outlined:not(.mdc-select--disabled).mdc-select--focused .mdc-notched-outline .mdc-notched-outline__notch,.mdc-select--outlined:not(.mdc-select--disabled).mdc-select--focused .mdc-notched-outline .mdc-notched-outline__trailing{border-color:#6200ee;border-color:var(--mdc-theme-primary, #6200ee)}.mdc-select--outlined.mdc-select--disabled .mdc-notched-outline__leading,.mdc-select--outlined.mdc-select--disabled .mdc-notched-outline__notch,.mdc-select--outlined.mdc-select--disabled .mdc-notched-outline__trailing{border-color:rgba(0, 0, 0, 0.06)}.mdc-select--outlined .mdc-select__anchor :not(.mdc-notched-outline--notched) .mdc-notched-outline__notch{max-width:calc(100% - 60px)}.mdc-select--outlined .mdc-select__anchor{display:flex;align-items:baseline;overflow:visible}.mdc-select--outlined .mdc-select__anchor .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-select-outlined 250ms 1}.mdc-select--outlined .mdc-select__anchor .mdc-floating-label--float-above{transform:translateY(-37.25px) scale(1)}.mdc-select--outlined .mdc-select__anchor .mdc-floating-label--float-above{font-size:.75rem}.mdc-select--outlined .mdc-select__anchor.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-select--outlined .mdc-select__anchor .mdc-notched-outline--upgraded .mdc-floating-label--float-above{transform:translateY(-34.75px) scale(0.75)}.mdc-select--outlined .mdc-select__anchor.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-select--outlined .mdc-select__anchor .mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:1rem}.mdc-select--outlined .mdc-select__anchor .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-top:1px}.mdc-select--outlined .mdc-select__anchor .mdc-select__selected-text::before{content:"​"}.mdc-select--outlined .mdc-select__anchor .mdc-select__selected-text-container{height:100%;display:inline-flex;align-items:center}.mdc-select--outlined .mdc-select__anchor::before{display:none}.mdc-select--outlined .mdc-select__selected-text-container{display:flex;border:none;z-index:1;background-color:transparent}.mdc-select--outlined .mdc-select__icon{z-index:2}.mdc-select--outlined .mdc-floating-label{line-height:1.15rem;left:4px;right:initial}[dir=rtl] .mdc-select--outlined .mdc-floating-label,.mdc-select--outlined .mdc-floating-label[dir=rtl]{left:initial;right:4px}.mdc-select--outlined.mdc-select--focused .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-top:2px}.mdc-select--outlined.mdc-select--invalid:not(.mdc-select--disabled) .mdc-notched-outline__leading,.mdc-select--outlined.mdc-select--invalid:not(.mdc-select--disabled) .mdc-notched-outline__notch,.mdc-select--outlined.mdc-select--invalid:not(.mdc-select--disabled) .mdc-notched-outline__trailing{border-color:#b00020;border-color:var(--mdc-theme-error, #b00020)}.mdc-select--outlined.mdc-select--invalid:not(.mdc-select--disabled):not(.mdc-select--focused) .mdc-select__anchor:hover .mdc-notched-outline .mdc-notched-outline__leading,.mdc-select--outlined.mdc-select--invalid:not(.mdc-select--disabled):not(.mdc-select--focused) .mdc-select__anchor:hover .mdc-notched-outline .mdc-notched-outline__notch,.mdc-select--outlined.mdc-select--invalid:not(.mdc-select--disabled):not(.mdc-select--focused) .mdc-select__anchor:hover .mdc-notched-outline .mdc-notched-outline__trailing{border-color:#b00020;border-color:var(--mdc-theme-error, #b00020)}.mdc-select--outlined.mdc-select--invalid:not(.mdc-select--disabled).mdc-select--focused .mdc-notched-outline .mdc-notched-outline__leading,.mdc-select--outlined.mdc-select--invalid:not(.mdc-select--disabled).mdc-select--focused .mdc-notched-outline .mdc-notched-outline__notch,.mdc-select--outlined.mdc-select--invalid:not(.mdc-select--disabled).mdc-select--focused .mdc-notched-outline .mdc-notched-outline__trailing{border-width:2px}.mdc-select--outlined.mdc-select--invalid:not(.mdc-select--disabled).mdc-select--focused .mdc-notched-outline .mdc-notched-outline__leading,.mdc-select--outlined.mdc-select--invalid:not(.mdc-select--disabled).mdc-select--focused .mdc-notched-outline .mdc-notched-outline__notch,.mdc-select--outlined.mdc-select--invalid:not(.mdc-select--disabled).mdc-select--focused .mdc-notched-outline .mdc-notched-outline__trailing{border-color:#b00020;border-color:var(--mdc-theme-error, #b00020)}.mdc-select--outlined.mdc-select--with-leading-icon .mdc-floating-label{left:36px;right:initial}[dir=rtl] .mdc-select--outlined.mdc-select--with-leading-icon .mdc-floating-label,.mdc-select--outlined.mdc-select--with-leading-icon .mdc-floating-label[dir=rtl]{left:initial;right:36px}.mdc-select--outlined.mdc-select--with-leading-icon .mdc-floating-label--float-above{transform:translateY(-37.25px) translateX(-32px) scale(1)}[dir=rtl] .mdc-select--outlined.mdc-select--with-leading-icon .mdc-floating-label--float-above,.mdc-select--outlined.mdc-select--with-leading-icon .mdc-floating-label--float-above[dir=rtl]{transform:translateY(-37.25px) translateX(32px) scale(1)}.mdc-select--outlined.mdc-select--with-leading-icon .mdc-floating-label--float-above{font-size:.75rem}.mdc-select--outlined.mdc-select--with-leading-icon.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-select--outlined.mdc-select--with-leading-icon .mdc-notched-outline--upgraded .mdc-floating-label--float-above{transform:translateY(-34.75px) translateX(-32px) scale(0.75)}[dir=rtl] .mdc-select--outlined.mdc-select--with-leading-icon.mdc-notched-outline--upgraded .mdc-floating-label--float-above,[dir=rtl] .mdc-select--outlined.mdc-select--with-leading-icon .mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-select--outlined.mdc-select--with-leading-icon.mdc-notched-outline--upgraded .mdc-floating-label--float-above[dir=rtl],.mdc-select--outlined.mdc-select--with-leading-icon .mdc-notched-outline--upgraded .mdc-floating-label--float-above[dir=rtl]{transform:translateY(-34.75px) translateX(32px) scale(0.75)}.mdc-select--outlined.mdc-select--with-leading-icon.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-select--outlined.mdc-select--with-leading-icon .mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:1rem}.mdc-select--outlined.mdc-select--with-leading-icon .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-select-outlined-leading-icon-56px 250ms 1}@keyframes mdc-floating-label-shake-float-above-select-outlined-leading-icon-56px{0%{transform:translateX(calc(0 - 32px)) translateY(-34.75px) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 32px)) translateY(-34.75px) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 32px)) translateY(-34.75px) scale(0.75)}100%{transform:translateX(calc(0 - 32px)) translateY(-34.75px) scale(0.75)}}[dir=rtl] .mdc-select--outlined.mdc-select--with-leading-icon .mdc-floating-label--shake,.mdc-select--outlined.mdc-select--with-leading-icon[dir=rtl] .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-select-outlined-leading-icon-56px 250ms 1}@keyframes mdc-floating-label-shake-float-above-select-outlined-leading-icon-56px-rtl{0%{transform:translateX(calc(0 - -32px)) translateY(-34.75px) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - -32px)) translateY(-34.75px) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - -32px)) translateY(-34.75px) scale(0.75)}100%{transform:translateX(calc(0 - -32px)) translateY(-34.75px) scale(0.75)}}.mdc-select--outlined.mdc-select--with-leading-icon .mdc-select__anchor :not(.mdc-notched-outline--notched) .mdc-notched-outline__notch{max-width:calc(100% - 96px)}.mdc-select--outlined .mdc-menu-surface{margin-bottom:8px}.mdc-select--outlined.mdc-select--no-label .mdc-menu-surface,.mdc-select--outlined .mdc-menu-surface--is-open-below{margin-bottom:0}.mdc-select__anchor{--mdc-ripple-fg-size: 0;--mdc-ripple-left: 0;--mdc-ripple-top: 0;--mdc-ripple-fg-scale: 1;--mdc-ripple-fg-translate-end: 0;--mdc-ripple-fg-translate-start: 0;-webkit-tap-highlight-color:rgba(0,0,0,0);will-change:transform,opacity}.mdc-select__anchor .mdc-select__ripple::before,.mdc-select__anchor .mdc-select__ripple::after{position:absolute;border-radius:50%;opacity:0;pointer-events:none;content:""}.mdc-select__anchor .mdc-select__ripple::before{transition:opacity 15ms linear,background-color 15ms linear;z-index:1;z-index:var(--mdc-ripple-z-index, 1)}.mdc-select__anchor .mdc-select__ripple::after{z-index:0;z-index:var(--mdc-ripple-z-index, 0)}.mdc-select__anchor.mdc-ripple-upgraded .mdc-select__ripple::before{transform:scale(var(--mdc-ripple-fg-scale, 1))}.mdc-select__anchor.mdc-ripple-upgraded .mdc-select__ripple::after{top:0;left:0;transform:scale(0);transform-origin:center center}.mdc-select__anchor.mdc-ripple-upgraded--unbounded .mdc-select__ripple::after{top:var(--mdc-ripple-top, 0);left:var(--mdc-ripple-left, 0)}.mdc-select__anchor.mdc-ripple-upgraded--foreground-activation .mdc-select__ripple::after{animation:mdc-ripple-fg-radius-in 225ms forwards,mdc-ripple-fg-opacity-in 75ms forwards}.mdc-select__anchor.mdc-ripple-upgraded--foreground-deactivation .mdc-select__ripple::after{animation:mdc-ripple-fg-opacity-out 150ms;transform:translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1))}.mdc-select__anchor .mdc-select__ripple::before,.mdc-select__anchor .mdc-select__ripple::after{top:calc(50% - 100%);left:calc(50% - 100%);width:200%;height:200%}.mdc-select__anchor.mdc-ripple-upgraded .mdc-select__ripple::after{width:var(--mdc-ripple-fg-size, 100%);height:var(--mdc-ripple-fg-size, 100%)}.mdc-select__anchor .mdc-select__ripple::before,.mdc-select__anchor .mdc-select__ripple::after{background-color:rgba(0, 0, 0, 0.87);background-color:var(--mdc-ripple-color, rgba(0, 0, 0, 0.87))}.mdc-select__anchor:hover .mdc-select__ripple::before,.mdc-select__anchor.mdc-ripple-surface--hover .mdc-select__ripple::before{opacity:0.04;opacity:var(--mdc-ripple-hover-opacity, 0.04)}.mdc-select__anchor.mdc-ripple-upgraded--background-focused .mdc-select__ripple::before,.mdc-select__anchor:not(.mdc-ripple-upgraded):focus .mdc-select__ripple::before{transition-duration:75ms;opacity:0.12;opacity:var(--mdc-ripple-focus-opacity, 0.12)}.mdc-select__anchor .mdc-select__ripple{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none}.mdc-select__menu .mdc-deprecated-list .mdc-deprecated-list-item--selected .mdc-deprecated-list-item__ripple::before,.mdc-select__menu .mdc-deprecated-list .mdc-deprecated-list-item--selected .mdc-deprecated-list-item__ripple::after{background-color:#000;background-color:var(--mdc-ripple-color, var(--mdc-theme-on-surface, #000))}.mdc-select__menu .mdc-deprecated-list .mdc-deprecated-list-item--selected:hover .mdc-deprecated-list-item__ripple::before,.mdc-select__menu .mdc-deprecated-list .mdc-deprecated-list-item--selected.mdc-ripple-surface--hover .mdc-deprecated-list-item__ripple::before{opacity:0.04;opacity:var(--mdc-ripple-hover-opacity, 0.04)}.mdc-select__menu .mdc-deprecated-list .mdc-deprecated-list-item--selected.mdc-ripple-upgraded--background-focused .mdc-deprecated-list-item__ripple::before,.mdc-select__menu .mdc-deprecated-list .mdc-deprecated-list-item--selected:not(.mdc-ripple-upgraded):focus .mdc-deprecated-list-item__ripple::before{transition-duration:75ms;opacity:0.12;opacity:var(--mdc-ripple-focus-opacity, 0.12)}.mdc-select__menu .mdc-deprecated-list .mdc-deprecated-list-item--selected:not(.mdc-ripple-upgraded) .mdc-deprecated-list-item__ripple::after{transition:opacity 150ms linear}.mdc-select__menu .mdc-deprecated-list .mdc-deprecated-list-item--selected:not(.mdc-ripple-upgraded):active .mdc-deprecated-list-item__ripple::after{transition-duration:75ms;opacity:0.12;opacity:var(--mdc-ripple-press-opacity, 0.12)}.mdc-select__menu .mdc-deprecated-list .mdc-deprecated-list-item--selected.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity, 0.12)}.mdc-select__menu .mdc-deprecated-list .mdc-deprecated-list-item--selected .mdc-list-item__ripple::before,.mdc-select__menu .mdc-deprecated-list .mdc-deprecated-list-item--selected .mdc-list-item__ripple::after{background-color:#000;background-color:var(--mdc-ripple-color, var(--mdc-theme-on-surface, #000))}.mdc-select__menu .mdc-deprecated-list .mdc-deprecated-list-item--selected:hover .mdc-list-item__ripple::before,.mdc-select__menu .mdc-deprecated-list .mdc-deprecated-list-item--selected.mdc-ripple-surface--hover .mdc-list-item__ripple::before{opacity:0.04;opacity:var(--mdc-ripple-hover-opacity, 0.04)}.mdc-select__menu .mdc-deprecated-list .mdc-deprecated-list-item--selected.mdc-ripple-upgraded--background-focused .mdc-list-item__ripple::before,.mdc-select__menu .mdc-deprecated-list .mdc-deprecated-list-item--selected:not(.mdc-ripple-upgraded):focus .mdc-list-item__ripple::before{transition-duration:75ms;opacity:0.12;opacity:var(--mdc-ripple-focus-opacity, 0.12)}.mdc-select__menu .mdc-deprecated-list .mdc-deprecated-list-item--selected:not(.mdc-ripple-upgraded) .mdc-list-item__ripple::after{transition:opacity 150ms linear}.mdc-select__menu .mdc-deprecated-list .mdc-deprecated-list-item--selected:not(.mdc-ripple-upgraded):active .mdc-list-item__ripple::after{transition-duration:75ms;opacity:0.12;opacity:var(--mdc-ripple-press-opacity, 0.12)}.mdc-select__menu .mdc-deprecated-list .mdc-deprecated-list-item--selected.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity, 0.12)}.mdc-select-helper-text{margin:0;margin-left:16px;margin-right:16px;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:Roboto, sans-serif;font-family:var(--mdc-typography-caption-font-family, var(--mdc-typography-font-family, Roboto, sans-serif));font-size:0.75rem;font-size:var(--mdc-typography-caption-font-size, 0.75rem);line-height:1.25rem;line-height:var(--mdc-typography-caption-line-height, 1.25rem);font-weight:400;font-weight:var(--mdc-typography-caption-font-weight, 400);letter-spacing:0.0333333333em;letter-spacing:var(--mdc-typography-caption-letter-spacing, 0.0333333333em);text-decoration:inherit;text-decoration:var(--mdc-typography-caption-text-decoration, inherit);text-transform:inherit;text-transform:var(--mdc-typography-caption-text-transform, inherit);display:block;margin-top:0;line-height:normal}[dir=rtl] .mdc-select-helper-text,.mdc-select-helper-text[dir=rtl]{margin-left:16px;margin-right:16px}.mdc-select-helper-text::before{display:inline-block;width:0;height:16px;content:"";vertical-align:0}.mdc-select-helper-text--validation-msg{opacity:0;transition:opacity 180ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-select--invalid+.mdc-select-helper-text--validation-msg,.mdc-select-helper-text--validation-msg-persistent{opacity:1}.mdc-select--with-leading-icon .mdc-select__icon{display:inline-block;box-sizing:border-box;border:none;text-decoration:none;cursor:pointer;user-select:none;flex-shrink:0;align-self:center;background-color:transparent;fill:currentColor}.mdc-select--with-leading-icon .mdc-select__icon{margin-left:12px;margin-right:12px}[dir=rtl] .mdc-select--with-leading-icon .mdc-select__icon,.mdc-select--with-leading-icon .mdc-select__icon[dir=rtl]{margin-left:12px;margin-right:12px}.mdc-select__icon:not([tabindex]),.mdc-select__icon[tabindex="-1"]{cursor:default;pointer-events:none}.material-icons{font-family:var(--mdc-icon-font, "Material Icons");font-weight:normal;font-style:normal;font-size:var(--mdc-icon-size, 24px);line-height:1;letter-spacing:normal;text-transform:none;display:inline-block;white-space:nowrap;word-wrap:normal;direction:ltr;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;-moz-osx-font-smoothing:grayscale;font-feature-settings:"liga"}:host{display:inline-block;vertical-align:top;outline:none}.mdc-select{width:100%}[hidden]{display:none}.mdc-select__icon{z-index:2}.mdc-select--with-leading-icon{--mdc-list-item-graphic-margin: calc( 48px - var(--mdc-list-item-graphic-size, 24px) - var(--mdc-list-side-padding, 16px) )}.mdc-select .mdc-select__anchor .mdc-select__selected-text{overflow:hidden}.mdc-select .mdc-select__anchor *{display:inline-flex}.mdc-select .mdc-select__anchor .mdc-floating-label{display:inline-block}mwc-notched-outline{--mdc-notched-outline-border-color: var( --mdc-select-outlined-idle-border-color, rgba(0, 0, 0, 0.38) );--mdc-notched-outline-notch-offset: 1px}:host(:not([disabled]):hover) .mdc-select:not(.mdc-select--invalid):not(.mdc-select--focused) mwc-notched-outline{--mdc-notched-outline-border-color: var( --mdc-select-outlined-hover-border-color, rgba(0, 0, 0, 0.87) )}:host(:not([disabled])) .mdc-select:not(.mdc-select--disabled) .mdc-select__selected-text{color:rgba(0, 0, 0, 0.87);color:var(--mdc-select-ink-color, rgba(0, 0, 0, 0.87))}:host(:not([disabled])) .mdc-select:not(.mdc-select--disabled) .mdc-line-ripple::before{border-bottom-color:rgba(0, 0, 0, 0.42);border-bottom-color:var(--mdc-select-idle-line-color, rgba(0, 0, 0, 0.42))}:host(:not([disabled])) .mdc-select:not(.mdc-select--disabled):hover .mdc-line-ripple::before{border-bottom-color:rgba(0, 0, 0, 0.87);border-bottom-color:var(--mdc-select-hover-line-color, rgba(0, 0, 0, 0.87))}:host(:not([disabled])) .mdc-select:not(.mdc-select--outlined):not(.mdc-select--disabled) .mdc-select__anchor{background-color:whitesmoke;background-color:var(--mdc-select-fill-color, whitesmoke)}:host(:not([disabled])) .mdc-select.mdc-select--invalid .mdc-select__dropdown-icon{fill:var(--mdc-select-error-dropdown-icon-color, var(--mdc-select-error-color, var(--mdc-theme-error, #b00020)))}:host(:not([disabled])) .mdc-select.mdc-select--invalid .mdc-floating-label,:host(:not([disabled])) .mdc-select.mdc-select--invalid .mdc-floating-label::after{color:var(--mdc-select-error-color, var(--mdc-theme-error, #b00020))}:host(:not([disabled])) .mdc-select.mdc-select--invalid mwc-notched-outline{--mdc-notched-outline-border-color: var(--mdc-select-error-color, var(--mdc-theme-error, #b00020))}.mdc-select__menu--invalid{--mdc-theme-primary: var(--mdc-select-error-color, var(--mdc-theme-error, #b00020))}:host(:not([disabled])) .mdc-select:not(.mdc-select--invalid):not(.mdc-select--focused) .mdc-floating-label,:host(:not([disabled])) .mdc-select:not(.mdc-select--invalid):not(.mdc-select--focused) .mdc-floating-label::after{color:rgba(0, 0, 0, 0.6);color:var(--mdc-select-label-ink-color, rgba(0, 0, 0, 0.6))}:host(:not([disabled])) .mdc-select:not(.mdc-select--invalid):not(.mdc-select--focused) .mdc-select__dropdown-icon{fill:rgba(0, 0, 0, 0.54);fill:var(--mdc-select-dropdown-icon-color, rgba(0, 0, 0, 0.54))}:host(:not([disabled])) .mdc-select.mdc-select--focused mwc-notched-outline{--mdc-notched-outline-stroke-width: 2px;--mdc-notched-outline-notch-offset: 2px}:host(:not([disabled])) .mdc-select.mdc-select--focused:not(.mdc-select--invalid) mwc-notched-outline{--mdc-notched-outline-border-color: var( --mdc-select-focused-label-color, var(--mdc-theme-primary, rgba(98, 0, 238, 0.87)) )}:host(:not([disabled])) .mdc-select.mdc-select--focused:not(.mdc-select--invalid) .mdc-select__dropdown-icon{fill:rgba(98,0,238,.87);fill:var(--mdc-select-focused-dropdown-icon-color, var(--mdc-theme-primary, rgba(98, 0, 238, 0.87)))}:host(:not([disabled])) .mdc-select.mdc-select--focused:not(.mdc-select--invalid) .mdc-floating-label{color:#6200ee;color:var(--mdc-theme-primary, #6200ee)}:host(:not([disabled])) .mdc-select.mdc-select--focused:not(.mdc-select--invalid) .mdc-floating-label::after{color:#6200ee;color:var(--mdc-theme-primary, #6200ee)}:host(:not([disabled])) .mdc-select-helper-text:not(.mdc-select-helper-text--validation-msg){color:var(--mdc-select-label-ink-color, rgba(0, 0, 0, 0.6))}:host([disabled]){pointer-events:none}:host([disabled]) .mdc-select:not(.mdc-select--outlined).mdc-select--disabled .mdc-select__anchor{background-color:#fafafa;background-color:var(--mdc-select-disabled-fill-color, #fafafa)}:host([disabled]) .mdc-select.mdc-select--outlined mwc-notched-outline{--mdc-notched-outline-border-color: var( --mdc-select-outlined-disabled-border-color, rgba(0, 0, 0, 0.06) )}:host([disabled]) .mdc-select .mdc-select__dropdown-icon{fill:rgba(0, 0, 0, 0.38);fill:var(--mdc-select-disabled-dropdown-icon-color, rgba(0, 0, 0, 0.38))}:host([disabled]) .mdc-select:not(.mdc-select--invalid):not(.mdc-select--focused) .mdc-floating-label,:host([disabled]) .mdc-select:not(.mdc-select--invalid):not(.mdc-select--focused) .mdc-floating-label::after{color:rgba(0, 0, 0, 0.38);color:var(--mdc-select-disabled-ink-color, rgba(0, 0, 0, 0.38))}:host([disabled]) .mdc-select-helper-text{color:rgba(0, 0, 0, 0.38);color:var(--mdc-select-disabled-ink-color, rgba(0, 0, 0, 0.38))}:host([disabled]) .mdc-select__selected-text{color:rgba(0, 0, 0, 0.38);color:var(--mdc-select-disabled-ink-color, rgba(0, 0, 0, 0.38))}`;

let MushroomSelect = class MushroomSelect extends SelectBase {
    constructor() {
        super(...arguments);
        this._translationsUpdated = debounce(async () => {
            await nextRender();
            this.layoutOptions();
        }, 500);
    }
    renderLeadingIcon() {
        if (!this.icon) {
            return w;
        }
        return $ `<span class="mdc-select__icon"><slot name="icon"></slot></span>`;
    }
    connectedCallback() {
        super.connectedCallback();
        window.addEventListener("translations-updated", this._translationsUpdated);
    }
    disconnectedCallback() {
        super.disconnectedCallback();
        window.removeEventListener("translations-updated", this._translationsUpdated);
    }
};
MushroomSelect.styles = [styles$1];
__decorate([
    e$3({ type: Boolean })
], MushroomSelect.prototype, "icon", void 0);
MushroomSelect = __decorate([
    n$1("mushroom-select")
], MushroomSelect);

const ALIGNMENT = ["default", "start", "center", "end", "justify"];
const ICONS$1 = {
    default: "mdi:format-align-left",
    start: "mdi:format-align-left",
    center: "mdi:format-align-center",
    end: "mdi:format-align-right",
    justify: "mdi:format-align-justify",
};
let AlignmentPicker = class AlignmentPicker extends s$1 {
    constructor() {
        super(...arguments);
        this.label = "";
        this.configValue = "";
    }
    _selectChanged(ev) {
        const value = ev.target.value;
        if (value) {
            this.dispatchEvent(new CustomEvent("value-changed", {
                detail: {
                    value: value !== "default" ? value : "",
                },
            }));
        }
    }
    render() {
        const customLocalize = setupCustomlocalize(this.hass);
        const value = this.value || "default";
        return $ `
            <mushroom-select
                icon
                .label=${this.label}
                .configValue=${this.configValue}
                @selected=${this._selectChanged}
                @closed=${(e) => e.stopPropagation()}
                .value=${this.value || "default"}
                fixedMenuPosition
                naturalMenuWidth
            >
                <ha-icon slot="icon" .icon=${ICONS$1[value]}></ha-icon>
                ${ALIGNMENT.map((alignment) => {
            return $ `
                        <mwc-list-item .value=${alignment} graphic="icon">
                            ${customLocalize(`editor.form.alignment_picker.values.${alignment}`)}
                            <ha-icon slot="graphic" .icon=${ICONS$1[alignment]}></ha-icon>
                        </mwc-list-item>
                    `;
        })}
            </mushroom-select>
        `;
    }
    static get styles() {
        return r$3 `
            mushroom-select {
                width: 100%;
            }
        `;
    }
};
__decorate([
    e$3()
], AlignmentPicker.prototype, "label", void 0);
__decorate([
    e$3()
], AlignmentPicker.prototype, "value", void 0);
__decorate([
    e$3()
], AlignmentPicker.prototype, "configValue", void 0);
__decorate([
    e$3()
], AlignmentPicker.prototype, "hass", void 0);
AlignmentPicker = __decorate([
    n$1("mushroom-alignment-picker")
], AlignmentPicker);

let HaMushAlignmentSelector = class HaMushAlignmentSelector extends s$1 {
    render() {
        return $ `
            <mushroom-alignment-picker
                .hass=${this.hass}
                .label=${this.label}
                .value=${this.value}
                @value-changed=${this._valueChanged}
            ></mushroom-alignment-picker>
        `;
    }
    _valueChanged(ev) {
        fireEvent(this, "value-changed", { value: ev.detail.value || undefined });
    }
};
__decorate([
    e$3()
], HaMushAlignmentSelector.prototype, "hass", void 0);
__decorate([
    e$3()
], HaMushAlignmentSelector.prototype, "selector", void 0);
__decorate([
    e$3()
], HaMushAlignmentSelector.prototype, "value", void 0);
__decorate([
    e$3()
], HaMushAlignmentSelector.prototype, "label", void 0);
HaMushAlignmentSelector = __decorate([
    n$1("ha-selector-mush-alignment")
], HaMushAlignmentSelector);

/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const i$2=e$1(class extends i$3{constructor(t$1){var e;if(super(t$1),t$1.type!==t.ATTRIBUTE||"style"!==t$1.name||(null===(e=t$1.strings)||void 0===e?void 0:e.length)>2)throw Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.")}render(t){return Object.keys(t).reduce(((e,r)=>{const s=t[r];return null==s?e:e+`${r=r.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g,"-$&").toLowerCase()}:${s};`}),"")}update(e,[r]){const{style:s}=e.element;if(void 0===this.ct){this.ct=new Set;for(const t in r)this.ct.add(t);return this.render(r)}this.ct.forEach((t=>{null==r[t]&&(this.ct.delete(t),t.includes("-")?s.removeProperty(t):s[t]="");}));for(const t in r){const e=r[t];null!=e&&(this.ct.add(t),t.includes("-")?s.setProperty(t,e):s[t]=e);}return b}});

var colorString$1 = {exports: {}};

var colorName = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};

var simpleSwizzle = {exports: {}};

var isArrayish$1 = function isArrayish(obj) {
	if (!obj || typeof obj === 'string') {
		return false;
	}

	return obj instanceof Array || Array.isArray(obj) ||
		(obj.length >= 0 && (obj.splice instanceof Function ||
			(Object.getOwnPropertyDescriptor(obj, (obj.length - 1)) && obj.constructor.name !== 'String')));
};

var isArrayish = isArrayish$1;

var concat = Array.prototype.concat;
var slice = Array.prototype.slice;

var swizzle$1 = simpleSwizzle.exports = function swizzle(args) {
	var results = [];

	for (var i = 0, len = args.length; i < len; i++) {
		var arg = args[i];

		if (isArrayish(arg)) {
			// http://jsperf.com/javascript-array-concat-vs-push/98
			results = concat.call(results, slice.call(arg));
		} else {
			results.push(arg);
		}
	}

	return results;
};

swizzle$1.wrap = function (fn) {
	return function () {
		return fn(swizzle$1(arguments));
	};
};

/* MIT license */

var colorNames = colorName;
var swizzle = simpleSwizzle.exports;
var hasOwnProperty = Object.hasOwnProperty;

var reverseNames = {};

// create a list of reverse color names
for (var name in colorNames) {
	if (hasOwnProperty.call(colorNames, name)) {
		reverseNames[colorNames[name]] = name;
	}
}

var cs = colorString$1.exports = {
	to: {},
	get: {}
};

cs.get = function (string) {
	var prefix = string.substring(0, 3).toLowerCase();
	var val;
	var model;
	switch (prefix) {
		case 'hsl':
			val = cs.get.hsl(string);
			model = 'hsl';
			break;
		case 'hwb':
			val = cs.get.hwb(string);
			model = 'hwb';
			break;
		default:
			val = cs.get.rgb(string);
			model = 'rgb';
			break;
	}

	if (!val) {
		return null;
	}

	return {model: model, value: val};
};

cs.get.rgb = function (string) {
	if (!string) {
		return null;
	}

	var abbr = /^#([a-f0-9]{3,4})$/i;
	var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
	var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
	var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
	var keyword = /^(\w+)$/;

	var rgb = [0, 0, 0, 1];
	var match;
	var i;
	var hexAlpha;

	if (match = string.match(hex)) {
		hexAlpha = match[2];
		match = match[1];

		for (i = 0; i < 3; i++) {
			// https://jsperf.com/slice-vs-substr-vs-substring-methods-long-string/19
			var i2 = i * 2;
			rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
		}

		if (hexAlpha) {
			rgb[3] = parseInt(hexAlpha, 16) / 255;
		}
	} else if (match = string.match(abbr)) {
		match = match[1];
		hexAlpha = match[3];

		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i] + match[i], 16);
		}

		if (hexAlpha) {
			rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
		}
	} else if (match = string.match(rgba)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i + 1], 0);
		}

		if (match[4]) {
			if (match[5]) {
				rgb[3] = parseFloat(match[4]) * 0.01;
			} else {
				rgb[3] = parseFloat(match[4]);
			}
		}
	} else if (match = string.match(per)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
		}

		if (match[4]) {
			if (match[5]) {
				rgb[3] = parseFloat(match[4]) * 0.01;
			} else {
				rgb[3] = parseFloat(match[4]);
			}
		}
	} else if (match = string.match(keyword)) {
		if (match[1] === 'transparent') {
			return [0, 0, 0, 0];
		}

		if (!hasOwnProperty.call(colorNames, match[1])) {
			return null;
		}

		rgb = colorNames[match[1]];
		rgb[3] = 1;

		return rgb;
	} else {
		return null;
	}

	for (i = 0; i < 3; i++) {
		rgb[i] = clamp(rgb[i], 0, 255);
	}
	rgb[3] = clamp(rgb[3], 0, 1);

	return rgb;
};

cs.get.hsl = function (string) {
	if (!string) {
		return null;
	}

	var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
	var match = string.match(hsl);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = ((parseFloat(match[1]) % 360) + 360) % 360;
		var s = clamp(parseFloat(match[2]), 0, 100);
		var l = clamp(parseFloat(match[3]), 0, 100);
		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);

		return [h, s, l, a];
	}

	return null;
};

cs.get.hwb = function (string) {
	if (!string) {
		return null;
	}

	var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
	var match = string.match(hwb);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = ((parseFloat(match[1]) % 360) + 360) % 360;
		var w = clamp(parseFloat(match[2]), 0, 100);
		var b = clamp(parseFloat(match[3]), 0, 100);
		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
		return [h, w, b, a];
	}

	return null;
};

cs.to.hex = function () {
	var rgba = swizzle(arguments);

	return (
		'#' +
		hexDouble(rgba[0]) +
		hexDouble(rgba[1]) +
		hexDouble(rgba[2]) +
		(rgba[3] < 1
			? (hexDouble(Math.round(rgba[3] * 255)))
			: '')
	);
};

cs.to.rgb = function () {
	var rgba = swizzle(arguments);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ')'
		: 'rgba(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ', ' + rgba[3] + ')';
};

cs.to.rgb.percent = function () {
	var rgba = swizzle(arguments);

	var r = Math.round(rgba[0] / 255 * 100);
	var g = Math.round(rgba[1] / 255 * 100);
	var b = Math.round(rgba[2] / 255 * 100);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + r + '%, ' + g + '%, ' + b + '%)'
		: 'rgba(' + r + '%, ' + g + '%, ' + b + '%, ' + rgba[3] + ')';
};

cs.to.hsl = function () {
	var hsla = swizzle(arguments);
	return hsla.length < 4 || hsla[3] === 1
		? 'hsl(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%)'
		: 'hsla(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%, ' + hsla[3] + ')';
};

// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
// (hwb have alpha optional & 1 is default value)
cs.to.hwb = function () {
	var hwba = swizzle(arguments);

	var a = '';
	if (hwba.length >= 4 && hwba[3] !== 1) {
		a = ', ' + hwba[3];
	}

	return 'hwb(' + hwba[0] + ', ' + hwba[1] + '%, ' + hwba[2] + '%' + a + ')';
};

cs.to.keyword = function (rgb) {
	return reverseNames[rgb.slice(0, 3)];
};

// helpers
function clamp(num, min, max) {
	return Math.min(Math.max(min, num), max);
}

function hexDouble(num) {
	var str = Math.round(num).toString(16).toUpperCase();
	return (str.length < 2) ? '0' + str : str;
}

/* MIT license */

/* eslint-disable no-mixed-operators */
const cssKeywords = colorName;

// NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)

const reverseKeywords = {};
for (const key of Object.keys(cssKeywords)) {
	reverseKeywords[cssKeywords[key]] = key;
}

const convert$2 = {
	rgb: {channels: 3, labels: 'rgb'},
	hsl: {channels: 3, labels: 'hsl'},
	hsv: {channels: 3, labels: 'hsv'},
	hwb: {channels: 3, labels: 'hwb'},
	cmyk: {channels: 4, labels: 'cmyk'},
	xyz: {channels: 3, labels: 'xyz'},
	lab: {channels: 3, labels: 'lab'},
	lch: {channels: 3, labels: 'lch'},
	hex: {channels: 1, labels: ['hex']},
	keyword: {channels: 1, labels: ['keyword']},
	ansi16: {channels: 1, labels: ['ansi16']},
	ansi256: {channels: 1, labels: ['ansi256']},
	hcg: {channels: 3, labels: ['h', 'c', 'g']},
	apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
	gray: {channels: 1, labels: ['gray']}
};

var conversions$2 = convert$2;

// Hide .channels and .labels properties
for (const model of Object.keys(convert$2)) {
	if (!('channels' in convert$2[model])) {
		throw new Error('missing channels property: ' + model);
	}

	if (!('labels' in convert$2[model])) {
		throw new Error('missing channel labels property: ' + model);
	}

	if (convert$2[model].labels.length !== convert$2[model].channels) {
		throw new Error('channel and label counts mismatch: ' + model);
	}

	const {channels, labels} = convert$2[model];
	delete convert$2[model].channels;
	delete convert$2[model].labels;
	Object.defineProperty(convert$2[model], 'channels', {value: channels});
	Object.defineProperty(convert$2[model], 'labels', {value: labels});
}

convert$2.rgb.hsl = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const min = Math.min(r, g, b);
	const max = Math.max(r, g, b);
	const delta = max - min;
	let h;
	let s;

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	const l = (min + max) / 2;

	if (max === min) {
		s = 0;
	} else if (l <= 0.5) {
		s = delta / (max + min);
	} else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
};

convert$2.rgb.hsv = function (rgb) {
	let rdif;
	let gdif;
	let bdif;
	let h;
	let s;

	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const v = Math.max(r, g, b);
	const diff = v - Math.min(r, g, b);
	const diffc = function (c) {
		return (v - c) / 6 / diff + 1 / 2;
	};

	if (diff === 0) {
		h = 0;
		s = 0;
	} else {
		s = diff / v;
		rdif = diffc(r);
		gdif = diffc(g);
		bdif = diffc(b);

		if (r === v) {
			h = bdif - gdif;
		} else if (g === v) {
			h = (1 / 3) + rdif - bdif;
		} else if (b === v) {
			h = (2 / 3) + gdif - rdif;
		}

		if (h < 0) {
			h += 1;
		} else if (h > 1) {
			h -= 1;
		}
	}

	return [
		h * 360,
		s * 100,
		v * 100
	];
};

convert$2.rgb.hwb = function (rgb) {
	const r = rgb[0];
	const g = rgb[1];
	let b = rgb[2];
	const h = convert$2.rgb.hsl(rgb)[0];
	const w = 1 / 255 * Math.min(r, Math.min(g, b));

	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

	return [h, w * 100, b * 100];
};

convert$2.rgb.cmyk = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;

	const k = Math.min(1 - r, 1 - g, 1 - b);
	const c = (1 - r - k) / (1 - k) || 0;
	const m = (1 - g - k) / (1 - k) || 0;
	const y = (1 - b - k) / (1 - k) || 0;

	return [c * 100, m * 100, y * 100, k * 100];
};

function comparativeDistance(x, y) {
	/*
		See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
	*/
	return (
		((x[0] - y[0]) ** 2) +
		((x[1] - y[1]) ** 2) +
		((x[2] - y[2]) ** 2)
	);
}

convert$2.rgb.keyword = function (rgb) {
	const reversed = reverseKeywords[rgb];
	if (reversed) {
		return reversed;
	}

	let currentClosestDistance = Infinity;
	let currentClosestKeyword;

	for (const keyword of Object.keys(cssKeywords)) {
		const value = cssKeywords[keyword];

		// Compute comparative distance
		const distance = comparativeDistance(rgb, value);

		// Check if its less, if so set as closest
		if (distance < currentClosestDistance) {
			currentClosestDistance = distance;
			currentClosestKeyword = keyword;
		}
	}

	return currentClosestKeyword;
};

convert$2.keyword.rgb = function (keyword) {
	return cssKeywords[keyword];
};

convert$2.rgb.xyz = function (rgb) {
	let r = rgb[0] / 255;
	let g = rgb[1] / 255;
	let b = rgb[2] / 255;

	// Assume sRGB
	r = r > 0.04045 ? (((r + 0.055) / 1.055) ** 2.4) : (r / 12.92);
	g = g > 0.04045 ? (((g + 0.055) / 1.055) ** 2.4) : (g / 12.92);
	b = b > 0.04045 ? (((b + 0.055) / 1.055) ** 2.4) : (b / 12.92);

	const x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	const y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	const z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

	return [x * 100, y * 100, z * 100];
};

convert$2.rgb.lab = function (rgb) {
	const xyz = convert$2.rgb.xyz(rgb);
	let x = xyz[0];
	let y = xyz[1];
	let z = xyz[2];

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);

	const l = (116 * y) - 16;
	const a = 500 * (x - y);
	const b = 200 * (y - z);

	return [l, a, b];
};

convert$2.hsl.rgb = function (hsl) {
	const h = hsl[0] / 360;
	const s = hsl[1] / 100;
	const l = hsl[2] / 100;
	let t2;
	let t3;
	let val;

	if (s === 0) {
		val = l * 255;
		return [val, val, val];
	}

	if (l < 0.5) {
		t2 = l * (1 + s);
	} else {
		t2 = l + s - l * s;
	}

	const t1 = 2 * l - t2;

	const rgb = [0, 0, 0];
	for (let i = 0; i < 3; i++) {
		t3 = h + 1 / 3 * -(i - 1);
		if (t3 < 0) {
			t3++;
		}

		if (t3 > 1) {
			t3--;
		}

		if (6 * t3 < 1) {
			val = t1 + (t2 - t1) * 6 * t3;
		} else if (2 * t3 < 1) {
			val = t2;
		} else if (3 * t3 < 2) {
			val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
		} else {
			val = t1;
		}

		rgb[i] = val * 255;
	}

	return rgb;
};

convert$2.hsl.hsv = function (hsl) {
	const h = hsl[0];
	let s = hsl[1] / 100;
	let l = hsl[2] / 100;
	let smin = s;
	const lmin = Math.max(l, 0.01);

	l *= 2;
	s *= (l <= 1) ? l : 2 - l;
	smin *= lmin <= 1 ? lmin : 2 - lmin;
	const v = (l + s) / 2;
	const sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

	return [h, sv * 100, v * 100];
};

convert$2.hsv.rgb = function (hsv) {
	const h = hsv[0] / 60;
	const s = hsv[1] / 100;
	let v = hsv[2] / 100;
	const hi = Math.floor(h) % 6;

	const f = h - Math.floor(h);
	const p = 255 * v * (1 - s);
	const q = 255 * v * (1 - (s * f));
	const t = 255 * v * (1 - (s * (1 - f)));
	v *= 255;

	switch (hi) {
		case 0:
			return [v, t, p];
		case 1:
			return [q, v, p];
		case 2:
			return [p, v, t];
		case 3:
			return [p, q, v];
		case 4:
			return [t, p, v];
		case 5:
			return [v, p, q];
	}
};

convert$2.hsv.hsl = function (hsv) {
	const h = hsv[0];
	const s = hsv[1] / 100;
	const v = hsv[2] / 100;
	const vmin = Math.max(v, 0.01);
	let sl;
	let l;

	l = (2 - s) * v;
	const lmin = (2 - s) * vmin;
	sl = s * vmin;
	sl /= (lmin <= 1) ? lmin : 2 - lmin;
	sl = sl || 0;
	l /= 2;

	return [h, sl * 100, l * 100];
};

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
convert$2.hwb.rgb = function (hwb) {
	const h = hwb[0] / 360;
	let wh = hwb[1] / 100;
	let bl = hwb[2] / 100;
	const ratio = wh + bl;
	let f;

	// Wh + bl cant be > 1
	if (ratio > 1) {
		wh /= ratio;
		bl /= ratio;
	}

	const i = Math.floor(6 * h);
	const v = 1 - bl;
	f = 6 * h - i;

	if ((i & 0x01) !== 0) {
		f = 1 - f;
	}

	const n = wh + f * (v - wh); // Linear interpolation

	let r;
	let g;
	let b;
	/* eslint-disable max-statements-per-line,no-multi-spaces */
	switch (i) {
		default:
		case 6:
		case 0: r = v;  g = n;  b = wh; break;
		case 1: r = n;  g = v;  b = wh; break;
		case 2: r = wh; g = v;  b = n; break;
		case 3: r = wh; g = n;  b = v; break;
		case 4: r = n;  g = wh; b = v; break;
		case 5: r = v;  g = wh; b = n; break;
	}
	/* eslint-enable max-statements-per-line,no-multi-spaces */

	return [r * 255, g * 255, b * 255];
};

convert$2.cmyk.rgb = function (cmyk) {
	const c = cmyk[0] / 100;
	const m = cmyk[1] / 100;
	const y = cmyk[2] / 100;
	const k = cmyk[3] / 100;

	const r = 1 - Math.min(1, c * (1 - k) + k);
	const g = 1 - Math.min(1, m * (1 - k) + k);
	const b = 1 - Math.min(1, y * (1 - k) + k);

	return [r * 255, g * 255, b * 255];
};

convert$2.xyz.rgb = function (xyz) {
	const x = xyz[0] / 100;
	const y = xyz[1] / 100;
	const z = xyz[2] / 100;
	let r;
	let g;
	let b;

	r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
	g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
	b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

	// Assume sRGB
	r = r > 0.0031308
		? ((1.055 * (r ** (1.0 / 2.4))) - 0.055)
		: r * 12.92;

	g = g > 0.0031308
		? ((1.055 * (g ** (1.0 / 2.4))) - 0.055)
		: g * 12.92;

	b = b > 0.0031308
		? ((1.055 * (b ** (1.0 / 2.4))) - 0.055)
		: b * 12.92;

	r = Math.min(Math.max(0, r), 1);
	g = Math.min(Math.max(0, g), 1);
	b = Math.min(Math.max(0, b), 1);

	return [r * 255, g * 255, b * 255];
};

convert$2.xyz.lab = function (xyz) {
	let x = xyz[0];
	let y = xyz[1];
	let z = xyz[2];

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);

	const l = (116 * y) - 16;
	const a = 500 * (x - y);
	const b = 200 * (y - z);

	return [l, a, b];
};

convert$2.lab.xyz = function (lab) {
	const l = lab[0];
	const a = lab[1];
	const b = lab[2];
	let x;
	let y;
	let z;

	y = (l + 16) / 116;
	x = a / 500 + y;
	z = y - b / 200;

	const y2 = y ** 3;
	const x2 = x ** 3;
	const z2 = z ** 3;
	y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
	x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
	z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

	x *= 95.047;
	y *= 100;
	z *= 108.883;

	return [x, y, z];
};

convert$2.lab.lch = function (lab) {
	const l = lab[0];
	const a = lab[1];
	const b = lab[2];
	let h;

	const hr = Math.atan2(b, a);
	h = hr * 360 / 2 / Math.PI;

	if (h < 0) {
		h += 360;
	}

	const c = Math.sqrt(a * a + b * b);

	return [l, c, h];
};

convert$2.lch.lab = function (lch) {
	const l = lch[0];
	const c = lch[1];
	const h = lch[2];

	const hr = h / 360 * 2 * Math.PI;
	const a = c * Math.cos(hr);
	const b = c * Math.sin(hr);

	return [l, a, b];
};

convert$2.rgb.ansi16 = function (args, saturation = null) {
	const [r, g, b] = args;
	let value = saturation === null ? convert$2.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization

	value = Math.round(value / 50);

	if (value === 0) {
		return 30;
	}

	let ansi = 30
		+ ((Math.round(b / 255) << 2)
		| (Math.round(g / 255) << 1)
		| Math.round(r / 255));

	if (value === 2) {
		ansi += 60;
	}

	return ansi;
};

convert$2.hsv.ansi16 = function (args) {
	// Optimization here; we already know the value and don't need to get
	// it converted for us.
	return convert$2.rgb.ansi16(convert$2.hsv.rgb(args), args[2]);
};

convert$2.rgb.ansi256 = function (args) {
	const r = args[0];
	const g = args[1];
	const b = args[2];

	// We use the extended greyscale palette here, with the exception of
	// black and white. normal palette only has 4 greyscale shades.
	if (r === g && g === b) {
		if (r < 8) {
			return 16;
		}

		if (r > 248) {
			return 231;
		}

		return Math.round(((r - 8) / 247) * 24) + 232;
	}

	const ansi = 16
		+ (36 * Math.round(r / 255 * 5))
		+ (6 * Math.round(g / 255 * 5))
		+ Math.round(b / 255 * 5);

	return ansi;
};

convert$2.ansi16.rgb = function (args) {
	let color = args % 10;

	// Handle greyscale
	if (color === 0 || color === 7) {
		if (args > 50) {
			color += 3.5;
		}

		color = color / 10.5 * 255;

		return [color, color, color];
	}

	const mult = (~~(args > 50) + 1) * 0.5;
	const r = ((color & 1) * mult) * 255;
	const g = (((color >> 1) & 1) * mult) * 255;
	const b = (((color >> 2) & 1) * mult) * 255;

	return [r, g, b];
};

convert$2.ansi256.rgb = function (args) {
	// Handle greyscale
	if (args >= 232) {
		const c = (args - 232) * 10 + 8;
		return [c, c, c];
	}

	args -= 16;

	let rem;
	const r = Math.floor(args / 36) / 5 * 255;
	const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	const b = (rem % 6) / 5 * 255;

	return [r, g, b];
};

convert$2.rgb.hex = function (args) {
	const integer = ((Math.round(args[0]) & 0xFF) << 16)
		+ ((Math.round(args[1]) & 0xFF) << 8)
		+ (Math.round(args[2]) & 0xFF);

	const string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert$2.hex.rgb = function (args) {
	const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
	if (!match) {
		return [0, 0, 0];
	}

	let colorString = match[0];

	if (match[0].length === 3) {
		colorString = colorString.split('').map(char => {
			return char + char;
		}).join('');
	}

	const integer = parseInt(colorString, 16);
	const r = (integer >> 16) & 0xFF;
	const g = (integer >> 8) & 0xFF;
	const b = integer & 0xFF;

	return [r, g, b];
};

convert$2.rgb.hcg = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const max = Math.max(Math.max(r, g), b);
	const min = Math.min(Math.min(r, g), b);
	const chroma = (max - min);
	let grayscale;
	let hue;

	if (chroma < 1) {
		grayscale = min / (1 - chroma);
	} else {
		grayscale = 0;
	}

	if (chroma <= 0) {
		hue = 0;
	} else
	if (max === r) {
		hue = ((g - b) / chroma) % 6;
	} else
	if (max === g) {
		hue = 2 + (b - r) / chroma;
	} else {
		hue = 4 + (r - g) / chroma;
	}

	hue /= 6;
	hue %= 1;

	return [hue * 360, chroma * 100, grayscale * 100];
};

convert$2.hsl.hcg = function (hsl) {
	const s = hsl[1] / 100;
	const l = hsl[2] / 100;

	const c = l < 0.5 ? (2.0 * s * l) : (2.0 * s * (1.0 - l));

	let f = 0;
	if (c < 1.0) {
		f = (l - 0.5 * c) / (1.0 - c);
	}

	return [hsl[0], c * 100, f * 100];
};

convert$2.hsv.hcg = function (hsv) {
	const s = hsv[1] / 100;
	const v = hsv[2] / 100;

	const c = s * v;
	let f = 0;

	if (c < 1.0) {
		f = (v - c) / (1 - c);
	}

	return [hsv[0], c * 100, f * 100];
};

convert$2.hcg.rgb = function (hcg) {
	const h = hcg[0] / 360;
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	if (c === 0.0) {
		return [g * 255, g * 255, g * 255];
	}

	const pure = [0, 0, 0];
	const hi = (h % 1) * 6;
	const v = hi % 1;
	const w = 1 - v;
	let mg = 0;

	/* eslint-disable max-statements-per-line */
	switch (Math.floor(hi)) {
		case 0:
			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
		case 1:
			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
		case 2:
			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
		case 3:
			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
		case 4:
			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
		default:
			pure[0] = 1; pure[1] = 0; pure[2] = w;
	}
	/* eslint-enable max-statements-per-line */

	mg = (1.0 - c) * g;

	return [
		(c * pure[0] + mg) * 255,
		(c * pure[1] + mg) * 255,
		(c * pure[2] + mg) * 255
	];
};

convert$2.hcg.hsv = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	const v = c + g * (1.0 - c);
	let f = 0;

	if (v > 0.0) {
		f = c / v;
	}

	return [hcg[0], f * 100, v * 100];
};

convert$2.hcg.hsl = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	const l = g * (1.0 - c) + 0.5 * c;
	let s = 0;

	if (l > 0.0 && l < 0.5) {
		s = c / (2 * l);
	} else
	if (l >= 0.5 && l < 1.0) {
		s = c / (2 * (1 - l));
	}

	return [hcg[0], s * 100, l * 100];
};

convert$2.hcg.hwb = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;
	const v = c + g * (1.0 - c);
	return [hcg[0], (v - c) * 100, (1 - v) * 100];
};

convert$2.hwb.hcg = function (hwb) {
	const w = hwb[1] / 100;
	const b = hwb[2] / 100;
	const v = 1 - b;
	const c = v - w;
	let g = 0;

	if (c < 1) {
		g = (v - c) / (1 - c);
	}

	return [hwb[0], c * 100, g * 100];
};

convert$2.apple.rgb = function (apple) {
	return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
};

convert$2.rgb.apple = function (rgb) {
	return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
};

convert$2.gray.rgb = function (args) {
	return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};

convert$2.gray.hsl = function (args) {
	return [0, 0, args[0]];
};

convert$2.gray.hsv = convert$2.gray.hsl;

convert$2.gray.hwb = function (gray) {
	return [0, 100, gray[0]];
};

convert$2.gray.cmyk = function (gray) {
	return [0, 0, 0, gray[0]];
};

convert$2.gray.lab = function (gray) {
	return [gray[0], 0, 0];
};

convert$2.gray.hex = function (gray) {
	const val = Math.round(gray[0] / 100 * 255) & 0xFF;
	const integer = (val << 16) + (val << 8) + val;

	const string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert$2.rgb.gray = function (rgb) {
	const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
	return [val / 255 * 100];
};

const conversions$1 = conversions$2;

/*
	This function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

function buildGraph() {
	const graph = {};
	// https://jsperf.com/object-keys-vs-for-in-with-closure/3
	const models = Object.keys(conversions$1);

	for (let len = models.length, i = 0; i < len; i++) {
		graph[models[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null
		};
	}

	return graph;
}

// https://en.wikipedia.org/wiki/Breadth-first_search
function deriveBFS(fromModel) {
	const graph = buildGraph();
	const queue = [fromModel]; // Unshift -> queue -> pop

	graph[fromModel].distance = 0;

	while (queue.length) {
		const current = queue.pop();
		const adjacents = Object.keys(conversions$1[current]);

		for (let len = adjacents.length, i = 0; i < len; i++) {
			const adjacent = adjacents[i];
			const node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}

	return graph;
}

function link(from, to) {
	return function (args) {
		return to(from(args));
	};
}

function wrapConversion(toModel, graph) {
	const path = [graph[toModel].parent, toModel];
	let fn = conversions$1[graph[toModel].parent][toModel];

	let cur = graph[toModel].parent;
	while (graph[cur].parent) {
		path.unshift(graph[cur].parent);
		fn = link(conversions$1[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}

	fn.conversion = path;
	return fn;
}

var route$1 = function (fromModel) {
	const graph = deriveBFS(fromModel);
	const conversion = {};

	const models = Object.keys(graph);
	for (let len = models.length, i = 0; i < len; i++) {
		const toModel = models[i];
		const node = graph[toModel];

		if (node.parent === null) {
			// No possible conversion, or this node is the source model.
			continue;
		}

		conversion[toModel] = wrapConversion(toModel, graph);
	}

	return conversion;
};

const conversions = conversions$2;
const route = route$1;

const convert$1 = {};

const models = Object.keys(conversions);

function wrapRaw(fn) {
	const wrappedFn = function (...args) {
		const arg0 = args[0];
		if (arg0 === undefined || arg0 === null) {
			return arg0;
		}

		if (arg0.length > 1) {
			args = arg0;
		}

		return fn(args);
	};

	// Preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

function wrapRounded(fn) {
	const wrappedFn = function (...args) {
		const arg0 = args[0];

		if (arg0 === undefined || arg0 === null) {
			return arg0;
		}

		if (arg0.length > 1) {
			args = arg0;
		}

		const result = fn(args);

		// We're assuming the result is an array here.
		// see notice in conversions.js; don't use box types
		// in conversion functions.
		if (typeof result === 'object') {
			for (let len = result.length, i = 0; i < len; i++) {
				result[i] = Math.round(result[i]);
			}
		}

		return result;
	};

	// Preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

models.forEach(fromModel => {
	convert$1[fromModel] = {};

	Object.defineProperty(convert$1[fromModel], 'channels', {value: conversions[fromModel].channels});
	Object.defineProperty(convert$1[fromModel], 'labels', {value: conversions[fromModel].labels});

	const routes = route(fromModel);
	const routeModels = Object.keys(routes);

	routeModels.forEach(toModel => {
		const fn = routes[toModel];

		convert$1[fromModel][toModel] = wrapRounded(fn);
		convert$1[fromModel][toModel].raw = wrapRaw(fn);
	});
});

var colorConvert = convert$1;

const colorString = colorString$1.exports;
const convert = colorConvert;

const skippedModels = [
	// To be honest, I don't really feel like keyword belongs in color convert, but eh.
	'keyword',

	// Gray conflicts with some method names, and has its own method defined.
	'gray',

	// Shouldn't really be in color-convert either...
	'hex',
];

const hashedModelKeys = {};
for (const model of Object.keys(convert)) {
	hashedModelKeys[[...convert[model].labels].sort().join('')] = model;
}

const limiters = {};

function Color(object, model) {
	if (!(this instanceof Color)) {
		return new Color(object, model);
	}

	if (model && model in skippedModels) {
		model = null;
	}

	if (model && !(model in convert)) {
		throw new Error('Unknown model: ' + model);
	}

	let i;
	let channels;

	if (object == null) { // eslint-disable-line no-eq-null,eqeqeq
		this.model = 'rgb';
		this.color = [0, 0, 0];
		this.valpha = 1;
	} else if (object instanceof Color) {
		this.model = object.model;
		this.color = [...object.color];
		this.valpha = object.valpha;
	} else if (typeof object === 'string') {
		const result = colorString.get(object);
		if (result === null) {
			throw new Error('Unable to parse color from string: ' + object);
		}

		this.model = result.model;
		channels = convert[this.model].channels;
		this.color = result.value.slice(0, channels);
		this.valpha = typeof result.value[channels] === 'number' ? result.value[channels] : 1;
	} else if (object.length > 0) {
		this.model = model || 'rgb';
		channels = convert[this.model].channels;
		const newArray = Array.prototype.slice.call(object, 0, channels);
		this.color = zeroArray(newArray, channels);
		this.valpha = typeof object[channels] === 'number' ? object[channels] : 1;
	} else if (typeof object === 'number') {
		// This is always RGB - can be converted later on.
		this.model = 'rgb';
		this.color = [
			(object >> 16) & 0xFF,
			(object >> 8) & 0xFF,
			object & 0xFF,
		];
		this.valpha = 1;
	} else {
		this.valpha = 1;

		const keys = Object.keys(object);
		if ('alpha' in object) {
			keys.splice(keys.indexOf('alpha'), 1);
			this.valpha = typeof object.alpha === 'number' ? object.alpha : 0;
		}

		const hashedKeys = keys.sort().join('');
		if (!(hashedKeys in hashedModelKeys)) {
			throw new Error('Unable to parse color from object: ' + JSON.stringify(object));
		}

		this.model = hashedModelKeys[hashedKeys];

		const {labels} = convert[this.model];
		const color = [];
		for (i = 0; i < labels.length; i++) {
			color.push(object[labels[i]]);
		}

		this.color = zeroArray(color);
	}

	// Perform limitations (clamping, etc.)
	if (limiters[this.model]) {
		channels = convert[this.model].channels;
		for (i = 0; i < channels; i++) {
			const limit = limiters[this.model][i];
			if (limit) {
				this.color[i] = limit(this.color[i]);
			}
		}
	}

	this.valpha = Math.max(0, Math.min(1, this.valpha));

	if (Object.freeze) {
		Object.freeze(this);
	}
}

Color.prototype = {
	toString() {
		return this.string();
	},

	toJSON() {
		return this[this.model]();
	},

	string(places) {
		let self = this.model in colorString.to ? this : this.rgb();
		self = self.round(typeof places === 'number' ? places : 1);
		const args = self.valpha === 1 ? self.color : [...self.color, this.valpha];
		return colorString.to[self.model](args);
	},

	percentString(places) {
		const self = this.rgb().round(typeof places === 'number' ? places : 1);
		const args = self.valpha === 1 ? self.color : [...self.color, this.valpha];
		return colorString.to.rgb.percent(args);
	},

	array() {
		return this.valpha === 1 ? [...this.color] : [...this.color, this.valpha];
	},

	object() {
		const result = {};
		const {channels} = convert[this.model];
		const {labels} = convert[this.model];

		for (let i = 0; i < channels; i++) {
			result[labels[i]] = this.color[i];
		}

		if (this.valpha !== 1) {
			result.alpha = this.valpha;
		}

		return result;
	},

	unitArray() {
		const rgb = this.rgb().color;
		rgb[0] /= 255;
		rgb[1] /= 255;
		rgb[2] /= 255;

		if (this.valpha !== 1) {
			rgb.push(this.valpha);
		}

		return rgb;
	},

	unitObject() {
		const rgb = this.rgb().object();
		rgb.r /= 255;
		rgb.g /= 255;
		rgb.b /= 255;

		if (this.valpha !== 1) {
			rgb.alpha = this.valpha;
		}

		return rgb;
	},

	round(places) {
		places = Math.max(places || 0, 0);
		return new Color([...this.color.map(roundToPlace(places)), this.valpha], this.model);
	},

	alpha(value) {
		if (value !== undefined) {
			return new Color([...this.color, Math.max(0, Math.min(1, value))], this.model);
		}

		return this.valpha;
	},

	// Rgb
	red: getset('rgb', 0, maxfn(255)),
	green: getset('rgb', 1, maxfn(255)),
	blue: getset('rgb', 2, maxfn(255)),

	hue: getset(['hsl', 'hsv', 'hsl', 'hwb', 'hcg'], 0, value => ((value % 360) + 360) % 360),

	saturationl: getset('hsl', 1, maxfn(100)),
	lightness: getset('hsl', 2, maxfn(100)),

	saturationv: getset('hsv', 1, maxfn(100)),
	value: getset('hsv', 2, maxfn(100)),

	chroma: getset('hcg', 1, maxfn(100)),
	gray: getset('hcg', 2, maxfn(100)),

	white: getset('hwb', 1, maxfn(100)),
	wblack: getset('hwb', 2, maxfn(100)),

	cyan: getset('cmyk', 0, maxfn(100)),
	magenta: getset('cmyk', 1, maxfn(100)),
	yellow: getset('cmyk', 2, maxfn(100)),
	black: getset('cmyk', 3, maxfn(100)),

	x: getset('xyz', 0, maxfn(95.047)),
	y: getset('xyz', 1, maxfn(100)),
	z: getset('xyz', 2, maxfn(108.833)),

	l: getset('lab', 0, maxfn(100)),
	a: getset('lab', 1),
	b: getset('lab', 2),

	keyword(value) {
		if (value !== undefined) {
			return new Color(value);
		}

		return convert[this.model].keyword(this.color);
	},

	hex(value) {
		if (value !== undefined) {
			return new Color(value);
		}

		return colorString.to.hex(this.rgb().round().color);
	},

	hexa(value) {
		if (value !== undefined) {
			return new Color(value);
		}

		const rgbArray = this.rgb().round().color;

		let alphaHex = Math.round(this.valpha * 255).toString(16).toUpperCase();
		if (alphaHex.length === 1) {
			alphaHex = '0' + alphaHex;
		}

		return colorString.to.hex(rgbArray) + alphaHex;
	},

	rgbNumber() {
		const rgb = this.rgb().color;
		return ((rgb[0] & 0xFF) << 16) | ((rgb[1] & 0xFF) << 8) | (rgb[2] & 0xFF);
	},

	luminosity() {
		// http://www.w3.org/TR/WCAG20/#relativeluminancedef
		const rgb = this.rgb().color;

		const lum = [];
		for (const [i, element] of rgb.entries()) {
			const chan = element / 255;
			lum[i] = (chan <= 0.04045) ? chan / 12.92 : ((chan + 0.055) / 1.055) ** 2.4;
		}

		return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
	},

	contrast(color2) {
		// http://www.w3.org/TR/WCAG20/#contrast-ratiodef
		const lum1 = this.luminosity();
		const lum2 = color2.luminosity();

		if (lum1 > lum2) {
			return (lum1 + 0.05) / (lum2 + 0.05);
		}

		return (lum2 + 0.05) / (lum1 + 0.05);
	},

	level(color2) {
		// https://www.w3.org/TR/WCAG/#contrast-enhanced
		const contrastRatio = this.contrast(color2);
		if (contrastRatio >= 7) {
			return 'AAA';
		}

		return (contrastRatio >= 4.5) ? 'AA' : '';
	},

	isDark() {
		// YIQ equation from http://24ways.org/2010/calculating-color-contrast
		const rgb = this.rgb().color;
		const yiq = (rgb[0] * 2126 + rgb[1] * 7152 + rgb[2] * 722) / 10000;
		return yiq < 128;
	},

	isLight() {
		return !this.isDark();
	},

	negate() {
		const rgb = this.rgb();
		for (let i = 0; i < 3; i++) {
			rgb.color[i] = 255 - rgb.color[i];
		}

		return rgb;
	},

	lighten(ratio) {
		const hsl = this.hsl();
		hsl.color[2] += hsl.color[2] * ratio;
		return hsl;
	},

	darken(ratio) {
		const hsl = this.hsl();
		hsl.color[2] -= hsl.color[2] * ratio;
		return hsl;
	},

	saturate(ratio) {
		const hsl = this.hsl();
		hsl.color[1] += hsl.color[1] * ratio;
		return hsl;
	},

	desaturate(ratio) {
		const hsl = this.hsl();
		hsl.color[1] -= hsl.color[1] * ratio;
		return hsl;
	},

	whiten(ratio) {
		const hwb = this.hwb();
		hwb.color[1] += hwb.color[1] * ratio;
		return hwb;
	},

	blacken(ratio) {
		const hwb = this.hwb();
		hwb.color[2] += hwb.color[2] * ratio;
		return hwb;
	},

	grayscale() {
		// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
		const rgb = this.rgb().color;
		const value = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
		return Color.rgb(value, value, value);
	},

	fade(ratio) {
		return this.alpha(this.valpha - (this.valpha * ratio));
	},

	opaquer(ratio) {
		return this.alpha(this.valpha + (this.valpha * ratio));
	},

	rotate(degrees) {
		const hsl = this.hsl();
		let hue = hsl.color[0];
		hue = (hue + degrees) % 360;
		hue = hue < 0 ? 360 + hue : hue;
		hsl.color[0] = hue;
		return hsl;
	},

	mix(mixinColor, weight) {
		// Ported from sass implementation in C
		// https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
		if (!mixinColor || !mixinColor.rgb) {
			throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
		}

		const color1 = mixinColor.rgb();
		const color2 = this.rgb();
		const p = weight === undefined ? 0.5 : weight;

		const w = 2 * p - 1;
		const a = color1.alpha() - color2.alpha();

		const w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2;
		const w2 = 1 - w1;

		return Color.rgb(
			w1 * color1.red() + w2 * color2.red(),
			w1 * color1.green() + w2 * color2.green(),
			w1 * color1.blue() + w2 * color2.blue(),
			color1.alpha() * p + color2.alpha() * (1 - p));
	},
};

// Model conversion methods and static constructors
for (const model of Object.keys(convert)) {
	if (skippedModels.includes(model)) {
		continue;
	}

	const {channels} = convert[model];

	// Conversion methods
	Color.prototype[model] = function (...args) {
		if (this.model === model) {
			return new Color(this);
		}

		if (args.length > 0) {
			return new Color(args, model);
		}

		return new Color([...assertArray(convert[this.model][model].raw(this.color)), this.valpha], model);
	};

	// 'static' construction methods
	Color[model] = function (...args) {
		let color = args[0];
		if (typeof color === 'number') {
			color = zeroArray(args, channels);
		}

		return new Color(color, model);
	};
}

function roundTo(number, places) {
	return Number(number.toFixed(places));
}

function roundToPlace(places) {
	return function (number) {
		return roundTo(number, places);
	};
}

function getset(model, channel, modifier) {
	model = Array.isArray(model) ? model : [model];

	for (const m of model) {
		(limiters[m] || (limiters[m] = []))[channel] = modifier;
	}

	model = model[0];

	return function (value) {
		let result;

		if (value !== undefined) {
			if (modifier) {
				value = modifier(value);
			}

			result = this[model]();
			result.color[channel] = value;
			return result;
		}

		result = this[model]().color[channel];
		if (modifier) {
			result = modifier(result);
		}

		return result;
	};
}

function maxfn(max) {
	return function (v) {
		return Math.max(0, Math.min(max, v));
	};
}

function assertArray(value) {
	return Array.isArray(value) ? value : [value];
}

function zeroArray(array, length) {
	for (let i = 0; i < length; i++) {
		if (typeof array[i] !== 'number') {
			array[i] = 0;
		}
	}

	return array;
}

var color = Color;

const COLORS = [
    "red",
    "pink",
    "purple",
    "deep-purple",
    "indigo",
    "blue",
    "light-blue",
    "cyan",
    "teal",
    "green",
    "light-green",
    "lime",
    "yellow",
    "amber",
    "orange",
    "deep-orange",
    "brown",
    "grey",
    "blue-grey",
    "black",
    "white",
    "disabled",
];
function computeRgbColor(color$1) {
    if (COLORS.includes(color$1)) {
        return `var(--rgb-${color$1})`;
    }
    else if (color$1.startsWith("#")) {
        try {
            return color.rgb(color$1).rgb().array().join(", ");
        }
        catch (err) {
            return "";
        }
    }
    return color$1;
}
function computeColorName(color) {
    return color
        .split("-")
        .map((s) => capitalizeFirstLetter$2(s))
        .join(" ");
}
function capitalizeFirstLetter$2(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
}
const defaultColorCss = r$3 `
    --default-red: 244, 67, 54;
    --default-pink: 233, 30, 99;
    --default-purple: 156, 39, 176;
    --default-deep-purple: 103, 58, 183;
    --default-indigo: 63, 81, 181;
    --default-blue: 33, 150, 243;
    --default-light-blue: 3, 169, 244;
    --default-cyan: 0, 188, 212;
    --default-teal: 0, 150, 136;
    --default-green: 76, 175, 80;
    --default-light-green: 139, 195, 74;
    --default-lime: 205, 220, 57;
    --default-yellow: 255, 235, 59;
    --default-amber: 255, 193, 7;
    --default-orange: 255, 152, 0;
    --default-deep-orange: 255, 87, 34;
    --default-brown: 121, 85, 72;
    --default-grey: 158, 158, 158;
    --default-blue-grey: 96, 125, 139;
    --default-black: 0, 0, 0;
    --default-white: 255, 255, 255;
    --default-disabled: 189, 189, 189;
`;
const defaultDarkColorCss = r$3 `
    --default-disabled: 111, 111, 111;
`;

let ColorPicker = class ColorPicker extends s$1 {
    constructor() {
        super(...arguments);
        this.label = "";
        this.configValue = "";
    }
    _selectChanged(ev) {
        const value = ev.target.value;
        if (value) {
            this.dispatchEvent(new CustomEvent("value-changed", {
                detail: {
                    value: value !== "default" ? value : "",
                },
            }));
        }
    }
    render() {
        const customLocalize = setupCustomlocalize(this.hass);
        return $ `
            <mushroom-select
                .icon=${Boolean(this.value)}
                .label=${this.label}
                .configValue=${this.configValue}
                @selected=${this._selectChanged}
                @closed=${(e) => e.stopPropagation()}
                .value=${this.value || "default"}
                fixedMenuPosition
                naturalMenuWidth
            >
                <mwc-icon slot="icon">${this.renderColorCircle(this.value || "grey")}</mwc-icon>
                <mwc-list-item value="default">
                    ${customLocalize("editor.form.color_picker.values.default")}
                </mwc-list-item>
                ${COLORS.map((color) => $ `
                        <mwc-list-item .value=${color} graphic="icon">
                            ${computeColorName(color)}
                            <mwc-icon slot="graphic">${this.renderColorCircle(color)}</mwc-icon>
                        </mwc-list-item>
                    `)}
            </mushroom-select>
        `;
    }
    renderColorCircle(color) {
        return $ `
            <span
                class="circle-color"
                style=${i$2({
            "--main-color": computeRgbColor(color),
        })}
            ></span>
        `;
    }
    static get styles() {
        return r$3 `
            mushroom-select {
                width: 100%;
            }
            .circle-color {
                display: block;
                background-color: rgb(var(--main-color));
                border-radius: 10px;
                width: 20px;
                height: 20px;
            }
        `;
    }
};
__decorate([
    e$3()
], ColorPicker.prototype, "label", void 0);
__decorate([
    e$3()
], ColorPicker.prototype, "value", void 0);
__decorate([
    e$3()
], ColorPicker.prototype, "configValue", void 0);
__decorate([
    e$3()
], ColorPicker.prototype, "hass", void 0);
ColorPicker = __decorate([
    n$1("mushroom-color-picker")
], ColorPicker);

let HaMushColorSelector = class HaMushColorSelector extends s$1 {
    render() {
        return $ `
            <mushroom-color-picker
                .hass=${this.hass}
                .label=${this.label}
                .value=${this.value}
                @value-changed=${this._valueChanged}
            ></mushroom-color-picker>
        `;
    }
    _valueChanged(ev) {
        fireEvent(this, "value-changed", { value: ev.detail.value || undefined });
    }
};
__decorate([
    e$3()
], HaMushColorSelector.prototype, "hass", void 0);
__decorate([
    e$3()
], HaMushColorSelector.prototype, "selector", void 0);
__decorate([
    e$3()
], HaMushColorSelector.prototype, "value", void 0);
__decorate([
    e$3()
], HaMushColorSelector.prototype, "label", void 0);
HaMushColorSelector = __decorate([
    n$1("ha-selector-mush-color")
], HaMushColorSelector);

const TIMESTAMP_STATE_DOMAINS = ["button", "input_button", "scene"];
const INFOS = ["name", "state", "last-changed", "last-updated", "none"];
const ICON_TYPES = ["icon", "entity-picture", "none"];
function computeInfoDisplay(info, name, state, entity, hass) {
    switch (info) {
        case "name":
            return name;
        case "state":
            const domain = entity.entity_id.split(".")[0];
            if ((entity.attributes.device_class === "timestamp" ||
                TIMESTAMP_STATE_DOMAINS.includes(domain)) &&
                isAvailable(entity) &&
                !isUnknown(entity)) {
                return $ `
                    <ha-relative-time
                        .hass=${hass}
                        .datetime=${entity.state}
                        capitalize
                    ></ha-relative-time>
                `;
            }
            else {
                return state;
            }
        case "last-changed":
            return $ `
                <ha-relative-time
                    .hass=${hass}
                    .datetime=${entity.last_changed}
                    capitalize
                ></ha-relative-time>
            `;
        case "last-updated":
            return $ `
                <ha-relative-time
                    .hass=${hass}
                    .datetime=${entity.last_updated}
                    capitalize
                ></ha-relative-time>
            `;
        case "none":
            return undefined;
    }
}
function computeEntityPicture(entity, iconType) {
    return iconType === "entity-picture" ? getEntityPicture(entity) : undefined;
}

let IconTypePicker = class IconTypePicker extends s$1 {
    constructor() {
        super(...arguments);
        this.label = "";
        this.configValue = "";
    }
    _selectChanged(ev) {
        const value = ev.target.value;
        if (value) {
            this.dispatchEvent(new CustomEvent("value-changed", {
                detail: {
                    value: value !== "default" ? value : "",
                },
            }));
        }
    }
    render() {
        const customLocalize = setupCustomlocalize(this.hass);
        return $ `
            <mushroom-select
                .label=${this.label}
                .configValue=${this.configValue}
                @selected=${this._selectChanged}
                @closed=${(e) => e.stopPropagation()}
                .value=${this.value || "default"}
                fixedMenuPosition
                naturalMenuWidth
            >
                <mwc-list-item value="default">
                    ${customLocalize("editor.form.icon_type_picker.values.default")}
                </mwc-list-item>
                ${ICON_TYPES.map((iconType) => {
            return $ `
                        <mwc-list-item .value=${iconType}>
                            ${customLocalize(`editor.form.icon_type_picker.values.${iconType}`) ||
                capitalizeFirstLetter$1(iconType)}
                        </mwc-list-item>
                    `;
        })}
            </mushroom-select>
        `;
    }
    static get styles() {
        return r$3 `
            mushroom-select {
                width: 100%;
            }
        `;
    }
};
__decorate([
    e$3()
], IconTypePicker.prototype, "label", void 0);
__decorate([
    e$3()
], IconTypePicker.prototype, "value", void 0);
__decorate([
    e$3()
], IconTypePicker.prototype, "configValue", void 0);
__decorate([
    e$3()
], IconTypePicker.prototype, "hass", void 0);
IconTypePicker = __decorate([
    n$1("mushroom-icon-type-picker")
], IconTypePicker);
function capitalizeFirstLetter$1(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
}

let HaMushIconTypeSelector = class HaMushIconTypeSelector extends s$1 {
    render() {
        return $ `
            <mushroom-icon-type-picker
                .hass=${this.hass}
                .label=${this.label}
                .value=${this.value}
                @value-changed=${this._valueChanged}
            ></mushroom-icon-type-picker>
        `;
    }
    _valueChanged(ev) {
        fireEvent(this, "value-changed", { value: ev.detail.value || undefined });
    }
};
__decorate([
    e$3()
], HaMushIconTypeSelector.prototype, "hass", void 0);
__decorate([
    e$3()
], HaMushIconTypeSelector.prototype, "selector", void 0);
__decorate([
    e$3()
], HaMushIconTypeSelector.prototype, "value", void 0);
__decorate([
    e$3()
], HaMushIconTypeSelector.prototype, "label", void 0);
HaMushIconTypeSelector = __decorate([
    n$1("ha-selector-mush-icon-type")
], HaMushIconTypeSelector);

let InfoPicker = class InfoPicker extends s$1 {
    constructor() {
        super(...arguments);
        this.label = "";
        this.configValue = "";
    }
    _selectChanged(ev) {
        const value = ev.target.value;
        if (value) {
            this.dispatchEvent(new CustomEvent("value-changed", {
                detail: {
                    value: value !== "default" ? value : "",
                },
            }));
        }
    }
    render() {
        var _a;
        const customLocalize = setupCustomlocalize(this.hass);
        return $ `
            <mushroom-select
                .label=${this.label}
                .configValue=${this.configValue}
                @selected=${this._selectChanged}
                @closed=${(e) => e.stopPropagation()}
                .value=${this.value || "default"}
                fixedMenuPosition
                naturalMenuWidth
            >
                <mwc-list-item value="default">
                    ${customLocalize("editor.form.info_picker.values.default")}
                </mwc-list-item>
                ${((_a = this.infos) !== null && _a !== void 0 ? _a : INFOS).map((info) => {
            return $ `
                        <mwc-list-item .value=${info}>
                            ${customLocalize(`editor.form.info_picker.values.${info}`) ||
                capitalizeFirstLetter(info)}
                        </mwc-list-item>
                    `;
        })}
            </mushroom-select>
        `;
    }
    static get styles() {
        return r$3 `
            mushroom-select {
                width: 100%;
            }
        `;
    }
};
__decorate([
    e$3()
], InfoPicker.prototype, "label", void 0);
__decorate([
    e$3()
], InfoPicker.prototype, "value", void 0);
__decorate([
    e$3()
], InfoPicker.prototype, "configValue", void 0);
__decorate([
    e$3()
], InfoPicker.prototype, "infos", void 0);
__decorate([
    e$3()
], InfoPicker.prototype, "hass", void 0);
InfoPicker = __decorate([
    n$1("mushroom-info-picker")
], InfoPicker);
function capitalizeFirstLetter(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
}

let HaMushInfoSelector = class HaMushInfoSelector extends s$1 {
    render() {
        return $ `
            <mushroom-info-picker
                .hass=${this.hass}
                .infos=${this.selector["mush-info"].infos}
                .label=${this.label}
                .value=${this.value}
                @value-changed=${this._valueChanged}
            ></mushroom-info-picker>
        `;
    }
    _valueChanged(ev) {
        fireEvent(this, "value-changed", { value: ev.detail.value || undefined });
    }
};
__decorate([
    e$3()
], HaMushInfoSelector.prototype, "hass", void 0);
__decorate([
    e$3()
], HaMushInfoSelector.prototype, "selector", void 0);
__decorate([
    e$3()
], HaMushInfoSelector.prototype, "value", void 0);
__decorate([
    e$3()
], HaMushInfoSelector.prototype, "label", void 0);
HaMushInfoSelector = __decorate([
    n$1("ha-selector-mush-info")
], HaMushInfoSelector);

const LAYOUTS = ["default", "horizontal", "vertical"];
const ICONS = {
    default: "mdi:card-text-outline",
    vertical: "mdi:focus-field-vertical",
    horizontal: "mdi:focus-field-horizontal",
};
let LayoutPicker = class LayoutPicker extends s$1 {
    constructor() {
        super(...arguments);
        this.label = "";
        this.configValue = "";
    }
    _selectChanged(ev) {
        const value = ev.target.value;
        if (value) {
            this.dispatchEvent(new CustomEvent("value-changed", {
                detail: {
                    value: value !== "default" ? value : "",
                },
            }));
        }
    }
    render() {
        const customLocalize = setupCustomlocalize(this.hass);
        const value = this.value || "default";
        return $ `
            <mushroom-select
                icon
                .label=${this.label}
                .configValue=${this.configValue}
                @selected=${this._selectChanged}
                @closed=${(e) => e.stopPropagation()}
                .value=${value}
                fixedMenuPosition
                naturalMenuWidth
            >
                <ha-icon slot="icon" .icon=${ICONS[value]}></ha-icon>
                ${LAYOUTS.map((layout) => $ `
                            <mwc-list-item .value=${layout} graphic="icon">
                                ${customLocalize(`editor.form.layout_picker.values.${layout}`)}
                                <ha-icon slot="graphic" .icon=${ICONS[layout]}></ha-icon>
                            </mwc-list-item>
                        `)}
            </mushroom-select>
        `;
    }
    static get styles() {
        return r$3 `
            mushroom-select {
                width: 100%;
            }
        `;
    }
};
__decorate([
    e$3()
], LayoutPicker.prototype, "label", void 0);
__decorate([
    e$3()
], LayoutPicker.prototype, "value", void 0);
__decorate([
    e$3()
], LayoutPicker.prototype, "configValue", void 0);
__decorate([
    e$3()
], LayoutPicker.prototype, "hass", void 0);
LayoutPicker = __decorate([
    n$1("mushroom-layout-picker")
], LayoutPicker);

let HaMushLayoutSelector = class HaMushLayoutSelector extends s$1 {
    render() {
        return $ `
            <mushroom-layout-picker
                .hass=${this.hass}
                .label=${this.label}
                .value=${this.value}
                @value-changed=${this._valueChanged}
            ></mushroom-layout-picker>
        `;
    }
    _valueChanged(ev) {
        fireEvent(this, "value-changed", { value: ev.detail.value || undefined });
    }
};
__decorate([
    e$3()
], HaMushLayoutSelector.prototype, "hass", void 0);
__decorate([
    e$3()
], HaMushLayoutSelector.prototype, "selector", void 0);
__decorate([
    e$3()
], HaMushLayoutSelector.prototype, "value", void 0);
__decorate([
    e$3()
], HaMushLayoutSelector.prototype, "label", void 0);
HaMushLayoutSelector = __decorate([
    n$1("ha-selector-mush-layout")
], HaMushLayoutSelector);

let BadgeIcon = class BadgeIcon extends s$1 {
    constructor() {
        super(...arguments);
        this.icon = "";
    }
    render() {
        return $ `
            <div class="badge">
                <ha-icon .icon=${this.icon} />
            </div>
        `;
    }
    static get styles() {
        return r$3 `
            :host {
                --main-color: rgb(var(--rgb-grey));
                --icon-color: rgb(var(--rgb-white));
            }
            .badge {
                display: flex;
                align-items: center;
                justify-content: center;
                line-height: 0;
                width: var(--badge-size);
                height: var(--badge-size);
                font-size: var(--badge-size);
                border-radius: var(--badge-border-radius);
                background-color: var(--main-color);
                transition: background-color 280ms ease-in-out;
            }
            .badge ha-icon {
                --mdc-icon-size: var(--badge-icon-size);
                color: var(--icon-color);
            }
        `;
    }
};
__decorate([
    e$3()
], BadgeIcon.prototype, "icon", void 0);
BadgeIcon = __decorate([
    n$1("mushroom-badge-icon")
], BadgeIcon);

let Button = class Button extends s$1 {
    constructor() {
        super(...arguments);
        this.icon = "";
        this.title = "";
        this.disabled = false;
    }
    render() {
        return $ `
            <button type="button" class="button" .title=${this.title} .disabled=${this.disabled}>
                <ha-icon .icon=${this.icon} />
            </button>
        `;
    }
    static get styles() {
        return r$3 `
            :host {
                --icon-color: var(--primary-text-color);
                --icon-color-disabled: rgb(var(--rgb-disabled));
                --bg-color: rgba(var(--rgb-primary-text-color), 0.05);
                --bg-color-disabled: rgba(var(--rgb-disabled), 0.2);
                height: var(--control-height);
                width: calc(var(--control-height) * var(--control-button-ratio));
                flex: none;
            }
            .button {
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                width: 100%;
                height: 100%;
                border-radius: var(--control-border-radius);
                border: none;
                background-color: var(--bg-color);
                transition: background-color 280ms ease-in-out;
                font-size: var(--control-height);
                margin: 0;
                padding: 0;
                box-sizing: border-box;
                line-height: 0;
            }
            .button:disabled {
                cursor: not-allowed;
                background-color: var(--bg-color-disabled);
            }
            .button ha-icon {
                --mdc-icon-size: var(--control-icon-size);
                color: var(--icon-color);
                pointer-events: none;
            }
            .button:disabled ha-icon {
                color: var(--icon-color-disabled);
            }
        `;
    }
};
__decorate([
    e$3()
], Button.prototype, "icon", void 0);
__decorate([
    e$3()
], Button.prototype, "title", void 0);
__decorate([
    e$3({ type: Boolean })
], Button.prototype, "disabled", void 0);
Button = __decorate([
    n$1("mushroom-button")
], Button);

let MushroomButtonGroup = class MushroomButtonGroup extends s$1 {
    constructor() {
        super(...arguments);
        this.fill = false;
        this.rtl = false;
    }
    render() {
        return $ `
            <div
                class=${o({
            container: true,
            fill: this.fill,
        })}
            >
                <slot></slot>
            </div>
        `;
    }
    static get styles() {
        return r$3 `
            :host {
                display: flex;
                flex-direction: row;
                width: 100%;
            }
            .container {
                width: 100%;
                display: flex;
                flex-direction: row;
                justify-content: flex-end;
            }
            .container ::slotted(*:not(:last-child)) {
                margin-right: var(--spacing);
            }
            :host([rtl]) .container ::slotted(*:not(:last-child)) {
                margin-right: initial;
                margin-left: var(--spacing);
            }
            .container.fill > ::slotted(*) {
                flex: 1;
                width: 0;
            }
        `;
    }
};
__decorate([
    e$3()
], MushroomButtonGroup.prototype, "fill", void 0);
__decorate([
    e$3()
], MushroomButtonGroup.prototype, "rtl", void 0);
MushroomButtonGroup = __decorate([
    n$1("mushroom-button-group")
], MushroomButtonGroup);

let Card = class Card extends s$1 {
    render() {
        var _a, _b, _c, _d;
        return $ `
            <div
                class=${o({
            container: true,
            horizontal: ((_a = this.appearance) === null || _a === void 0 ? void 0 : _a.layout) === "horizontal",
            "no-info": ((_b = this.appearance) === null || _b === void 0 ? void 0 : _b.primary_info) === "none" &&
                ((_c = this.appearance) === null || _c === void 0 ? void 0 : _c.secondary_info) === "none",
            "no-icon": ((_d = this.appearance) === null || _d === void 0 ? void 0 : _d.icon_type) === "none",
        })}
            >
                <slot></slot>
            </div>
        `;
    }
    static get styles() {
        return r$3 `
            .container {
                display: flex;
                flex-direction: column;
                flex-shrink: 0;
                flex-grow: 0;
                box-sizing: border-box;
                justify-content: center;
            }
            .container > ::slotted(*:not(:last-child)) {
                margin-bottom: var(--spacing);
            }
            .container.horizontal {
                flex-direction: row;
            }
            .container.horizontal > ::slotted(*) {
                flex: 1;
                min-width: 0;
            }
            .container.no-info > ::slotted(mushroom-state-item) {
                flex: none;
            }
            .container.no-info.no-icon > ::slotted(mushroom-state-item) {
                margin-right: 0;
                margin-left: 0;
                margin-bottom: 0;
            }
            .container.horizontal > ::slotted(*:not(:last-child)) {
                margin-right: var(--spacing);
                margin-bottom: 0;
            }
            :host([rtl]) .container.horizontal > ::slotted(*:not(:last-child)) {
                margin-right: initial;
                margin-left: var(--spacing);
                margin-bottom: 0;
            }
        `;
    }
};
__decorate([
    e$3()
], Card.prototype, "appearance", void 0);
Card = __decorate([
    n$1("mushroom-card")
], Card);

const strAnimations = {
    pulse: `@keyframes pulse {
        0% {
            opacity: 1;
        }
        50% {
            opacity: 0;
        }
        100% {
            opacity: 1;
        }
    }`,
    spin: `@keyframes spin {
        from {
            transform: rotate(0deg);
        }
        to {
            transform: rotate(360deg);
        }
    }`,
    cleaning: `@keyframes cleaning {
        0% {
            transform: rotate(0) translate(0);
        }
        5% {
            transform: rotate(0) translate(0, -3px);
        }
        10% {
            transform: rotate(0) translate(0, 1px);
        }
        15% {
            transform: rotate(0) translate(0);
        }

        20% {
            transform: rotate(30deg) translate(0);
        }
        25% {
            transform: rotate(30deg) translate(0, -3px);
        }
        30% {
            transform: rotate(30deg) translate(0, 1px);
        }
        35% {
            transform: rotate(30deg) translate(0);
        }
        40% {
            transform: rotate(0) translate(0);
        }

        45% {
            transform: rotate(-30deg) translate(0);
        }
        50% {
            transform: rotate(-30deg) translate(0, -3px);
        }
        55% {
            transform: rotate(-30deg) translate(0, 1px);
        }
        60% {
            transform: rotate(-30deg) translate(0);
        }
        70% {
            transform: rotate(0deg) translate(0);
        }
        100% {
            transform: rotate(0deg);
        }
    }`,
    returning: `@keyframes returning {
        0% {
            transform: rotate(0);
        }
        25% {
            transform: rotate(20deg);
        }
        50% {
            transform: rotate(0);
        }
        75% {
            transform: rotate(-20deg);
        }
        100% {
            transform: rotate(0);
        }
    }`,
};
const animation = {
    pulse: r$3 `
        ${o$5(strAnimations.pulse)}
    `,
    spin: r$3 `
        ${o$5(strAnimations.spin)}
    `,
    cleaning: r$3 `
        ${o$5(strAnimations.cleaning)}
    `,
    returning: r$3 `
        ${o$5(strAnimations.returning)}
    `,
};
const animations = r$3 `
    ${o$5(Object.values(strAnimations).join("\n"))}
`;

let ShapeIcon = class ShapeIcon extends s$1 {
    constructor() {
        super(...arguments);
        this.icon = "";
        this.disabled = false;
    }
    render() {
        return $ `
            <div
                class=${o({
            shape: true,
            disabled: this.disabled,
        })}
            >
                <ha-icon .icon=${this.icon} />
            </div>
        `;
    }
    static get styles() {
        return r$3 `
            :host {
                --icon-color: var(--primary-text-color);
                --icon-color-disabled: rgb(var(--rgb-disabled));
                --icon-animation: none;
                --shape-color: rgba(var(--rgb-primary-text-color), 0.05);
                --shape-color-disabled: rgba(var(--rgb-disabled), 0.2);
                --shape-animation: none;
                --shape-outline-color: transparent;
                flex: none;
            }
            .shape {
                position: relative;
                width: var(--icon-size);
                height: var(--icon-size);
                font-size: var(--icon-size);
                border-radius: var(--icon-border-radius);
                display: flex;
                align-items: center;
                justify-content: center;
                background-color: var(--shape-color);
                transition-property: background-color, box-shadow;
                transition-duration: 280ms;
                transition-timing-function: ease-out;
                animation: var(--shape-animation);
                box-shadow: 0 0 0 1px var(--shape-outline-color);
            }
            .shape ha-icon {
                display: flex;
                --mdc-icon-size: var(--icon-symbol-size);
                color: var(--icon-color);
                transition: color 280ms ease-in-out;
                animation: var(--icon-animation);
            }
            .shape.disabled {
                background-color: var(--shape-color-disabled);
            }
            .shape.disabled ha-icon {
                color: var(--icon-color-disabled);
            }
            ${animations}
        `;
    }
};
__decorate([
    e$3()
], ShapeIcon.prototype, "icon", void 0);
__decorate([
    e$3()
], ShapeIcon.prototype, "disabled", void 0);
ShapeIcon = __decorate([
    n$1("mushroom-shape-icon")
], ShapeIcon);

let StateItem$1 = class StateItem extends s$1 {
    constructor() {
        super(...arguments);
        this.primary = "";
        this.multiline_secondary = false;
    }
    render() {
        return $ `
            <div class="container">
                <span class="primary">${this.primary}</span>
                ${this.secondary
            ? $ `<span
                          class="secondary${this.multiline_secondary ? ` multiline_secondary` : ``}"
                          >${this.secondary}</span
                      >`
            : null}
            </div>
        `;
    }
    static get styles() {
        return r$3 `
            .container {
                min-width: 0;
                flex: 1;
                display: flex;
                flex-direction: column;
            }
            .primary {
                font-weight: var(--card-primary-font-weight);
                font-size: var(--card-primary-font-size);
                line-height: var(--card-primary-line-height);
                color: var(--primary-text-color);
                text-overflow: ellipsis;
                overflow: hidden;
                white-space: nowrap;
            }
            .secondary {
                font-weight: var(--card-secondary-font-weight);
                font-size: var(--card-secondary-font-size);
                line-height: var(--card-secondary-line-height);
                color: var(--secondary-text-color);
                text-overflow: ellipsis;
                overflow: hidden;
                white-space: nowrap;
            }
            .multiline_secondary {
                white-space: pre-wrap;
            }
        `;
    }
};
__decorate([
    e$3()
], StateItem$1.prototype, "primary", void 0);
__decorate([
    e$3()
], StateItem$1.prototype, "secondary", void 0);
__decorate([
    e$3()
], StateItem$1.prototype, "multiline_secondary", void 0);
StateItem$1 = __decorate([
    n$1("mushroom-state-info")
], StateItem$1);

let StateItem = class StateItem extends s$1 {
    render() {
        var _a, _b, _c, _d;
        return $ `
            <div
                class=${o({
            container: true,
            vertical: ((_a = this.appearance) === null || _a === void 0 ? void 0 : _a.layout) === "vertical",
        })}
            >
                ${((_b = this.appearance) === null || _b === void 0 ? void 0 : _b.icon_type) !== "none"
            ? $ `
                          <div class="icon">
                              <slot name="icon"></slot>
                              <slot name="badge"></slot>
                          </div>
                      `
            : null}
                ${((_c = this.appearance) === null || _c === void 0 ? void 0 : _c.primary_info) !== "none" ||
            ((_d = this.appearance) === null || _d === void 0 ? void 0 : _d.secondary_info) !== "none"
            ? $ `
                          <div class="info">
                              <slot name="info"></slot>
                          </div>
                      `
            : null}
            </div>
        `;
    }
    static get styles() {
        return r$3 `
            .container {
                display: flex;
                flex-direction: row;
                align-items: center;
                justify-content: flex-start;
            }
            .container > *:not(:last-child) {
                margin-right: var(--spacing);
            }
            :host([rtl]) .container > *:not(:last-child) {
                margin-right: initial;
                margin-left: var(--spacing);
            }
            .icon {
                position: relative;
            }
            .icon ::slotted(*[slot="badge"]) {
                position: absolute;
                top: -3px;
                right: -3px;
            }
            :host([rtl]) .icon ::slotted(*[slot="badge"]) {
                right: initial;
                left: -3px;
            }
            .info {
                min-width: 0;
                width: 100%;
                display: flex;
                flex-direction: column;
            }
            .container.vertical {
                flex-direction: column;
            }
            .container.vertical > *:not(:last-child) {
                margin-bottom: var(--spacing);
                margin-right: 0;
                margin-left: 0;
            }
            :host([rtl]) .container.vertical > *:not(:last-child) {
                margin-right: initial;
                margin-left: initial;
            }
            .container.vertical .info {
                text-align: center;
            }
        `;
    }
};
__decorate([
    e$3()
], StateItem.prototype, "appearance", void 0);
StateItem = __decorate([
    n$1("mushroom-state-item")
], StateItem);

function computeAppearance(config) {
    var _a, _b, _c, _d, _e;
    return {
        layout: (_a = config.layout) !== null && _a !== void 0 ? _a : getDefaultLayout(config),
        fill_container: (_b = config.fill_container) !== null && _b !== void 0 ? _b : false,
        primary_info: (_c = config.primary_info) !== null && _c !== void 0 ? _c : getDefaultPrimaryInfo(config),
        secondary_info: (_d = config.secondary_info) !== null && _d !== void 0 ? _d : getDefaultSecondaryInfo(config),
        icon_type: (_e = config.icon_type) !== null && _e !== void 0 ? _e : getDefaultIconType(config),
    };
}
function getDefaultLayout(config) {
    if (config.vertical) {
        return "vertical";
    }
    return "default";
}
function getDefaultIconType(config) {
    if (config.hide_icon) {
        return "none";
    }
    if (config.use_entity_picture || config.use_media_artwork) {
        return "entity-picture";
    }
    return "icon";
}
function getDefaultPrimaryInfo(config) {
    if (config.hide_name) {
        return "none";
    }
    return "name";
}
function getDefaultSecondaryInfo(config) {
    if (config.hide_state) {
        return "none";
    }
    return "state";
}

let ShapePicture = class ShapePicture extends s$1 {
    constructor() {
        super(...arguments);
        this.picture_url = "";
    }
    render() {
        return $ `
            <div class=${o({ container: true })}>
                <img class="picture" src=${this.picture_url} />
            </div>
        `;
    }
    static get styles() {
        return r$3 `
            :host {
                --main-color: var(--primary-text-color);
                --icon-color-disabled: rgb(var(--rgb-disabled));
                --shape-color: rgba(var(--rgb-primary-text-color), 0.05);
                --shape-color-disabled: rgba(var(--rgb-disabled), 0.2);
                flex: none;
            }
            .container {
                position: relative;
                width: var(--icon-size);
                height: var(--icon-size);
                flex: none;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            .picture {
                width: 100%;
                height: 100%;
                border-radius: var(--icon-border-radius);
            }
        `;
    }
};
__decorate([
    e$3()
], ShapePicture.prototype, "picture_url", void 0);
ShapePicture = __decorate([
    n$1("mushroom-shape-avatar")
], ShapePicture);

const themeVariables = r$3 `
    --spacing: var(--mush-spacing, 12px);

    /* Title */
    --title-padding: var(--mush-title-padding, 24px 12px 16px);
    --title-spacing: var(--mush-title-spacing, 12px);
    --title-font-size: var(--mush-title-font-size, 24px);
    --title-font-weight: var(--mush-title-font-weight, normal);
    --title-line-height: var(--mush-title-line-height, 1.2);
    --subtitle-font-size: var(--mush-subtitle-font-size, 16px);
    --subtitle-font-weight: var(--mush-subtitle-font-weight, normal);
    --subtitle-line-height: var(--mush-subtitle-line-height, 1.2);

    /* Card */
    --card-primary-font-size: var(--mush-card-primary-font-size, 14px);
    --card-secondary-font-size: var(--mush-card-secondary-font-size, 12px);
    --card-primary-font-weight: var(--mush-card-primary-font-weight, bold);
    --card-secondary-font-weight: var(--mush-card-secondary-font-weight, bolder);
    --card-primary-line-height: var(--mush-card-primary-line-height, 1.5);
    --card-secondary-line-height: var(--mush-card-secondary-line-height, 1.5);

    /* Chips */
    --chip-spacing: var(--mush-chip-spacing, 8px);
    --chip-padding: var(--mush-chip-padding, 0 0.25em);
    --chip-height: var(--mush-chip-height, 36px);
    --chip-border-radius: var(--mush-chip-border-radius, 19px);
    --chip-border-width: var(--mush-chip-border-width, var(--ha-card-border-width, 1px));
    --chip-border-color: var(
        --mush-chip-border-color,
        var(--ha-card-border-color, var(--divider-color))
    );
    --chip-box-shadow: var(--mush-chip-box-shadow, var(--ha-card-box-shadow, "none"));
    --chip-font-size: var(--mush-chip-font-size, 0.3em);
    --chip-font-weight: var(--mush-chip-font-weight, bold);
    --chip-icon-size: var(--mush-chip-icon-size, 0.5em);
    --chip-avatar-padding: var(--mush-chip-avatar-padding, 0.1em);
    --chip-avatar-border-radius: var(--mush-chip-avatar-border-radius, 50%);
    --chip-background: var(
        --mush-chip-background,
        var(--ha-card-background, var(--card-background-color, white))
    );
    /* Controls */
    --control-border-radius: var(--mush-control-border-radius, 12px);
    --control-height: var(--mush-control-height, 42px);
    --control-button-ratio: var(--mush-control-button-ratio, 1);
    --control-icon-size: var(--mush-control-icon-size, 0.5em);

    /* Slider */
    --slider-threshold: var(--mush-slider-threshold);

    /* Input Number */
    --input-number-debounce: var(--mush-input-number-debounce);

    /* Layout */
    --layout-align: var(--mush-layout-align, center);

    /* Badge */
    --badge-size: var(--mush-badge-size, 16px);
    --badge-icon-size: var(--mush-badge-icon-size, 0.75em);
    --badge-border-radius: var(--mush-badge-border-radius, 50%);

    /* Icon */
    --icon-border-radius: var(--mush-icon-border-radius, 50%);
    --icon-size: var(--mush-icon-size, 42px);
    --icon-symbol-size: var(--mush-icon-symbol-size, 0.5em);
`;
const themeColorCss = r$3 `
    /* RGB */
    /* Standard colors */
    --rgb-red: var(--mush-rgb-red, var(--default-red));
    --rgb-pink: var(--mush-rgb-pink, var(--default-pink));
    --rgb-purple: var(--mush-rgb-purple, var(--default-purple));
    --rgb-deep-purple: var(--mush-rgb-deep-purple, var(--default-deep-purple));
    --rgb-indigo: var(--mush-rgb-indigo, var(--default-indigo));
    --rgb-blue: var(--mush-rgb-blue, var(--default-blue));
    --rgb-light-blue: var(--mush-rgb-light-blue, var(--default-light-blue));
    --rgb-cyan: var(--mush-rgb-cyan, var(--default-cyan));
    --rgb-teal: var(--mush-rgb-teal, var(--default-teal));
    --rgb-green: var(--mush-rgb-green, var(--default-green));
    --rgb-light-green: var(--mush-rgb-light-green, var(--default-light-green));
    --rgb-lime: var(--mush-rgb-lime, var(--default-lime));
    --rgb-yellow: var(--mush-rgb-yellow, var(--default-yellow));
    --rgb-amber: var(--mush-rgb-amber, var(--default-amber));
    --rgb-orange: var(--mush-rgb-orange, var(--default-orange));
    --rgb-deep-orange: var(--mush-rgb-deep-orange, var(--default-deep-orange));
    --rgb-brown: var(--mush-rgb-brown, var(--default-brown));
    --rgb-grey: var(--mush-rgb-grey, var(--default-grey));
    --rgb-blue-grey: var(--mush-rgb-blue-grey, var(--default-blue-grey));
    --rgb-black: var(--mush-rgb-black, var(--default-black));
    --rgb-white: var(--mush-rgb-white, var(--default-white));
    --rgb-disabled: var(--mush-rgb-disabled, var(--default-disabled));

    /* Action colors */
    --rgb-info: var(--mush-rgb-info, var(--rgb-blue));
    --rgb-success: var(--mush-rgb-success, var(--rgb-green));
    --rgb-warning: var(--mush-rgb-warning, var(--rgb-orange));
    --rgb-danger: var(--mush-rgb-danger, var(--rgb-red));

    /* State colors */
    --rgb-state-vacuum: var(--mush-rgb-state-vacuum, var(--rgb-teal));
    --rgb-state-fan: var(--mush-rgb-state-fan, var(--rgb-green));
    --rgb-state-light: var(--mush-rgb-state-light, var(--rgb-orange));
    --rgb-state-entity: var(--mush-rgb-state-entity, var(--rgb-blue));
    --rgb-state-media-player: var(--mush-rgb-state-media-player, var(--rgb-indigo));
    --rgb-state-lock: var(--mush-rgb-state-lock, var(--rgb-blue));
    --rgb-state-humidifier: var(--mush-rgb-state-humidifier, var(--rgb-purple));

    /* State alarm colors */
    --rgb-state-alarm-disarmed: var(--mush-rgb-state-alarm-disarmed, var(--rgb-info));
    --rgb-state-alarm-armed: var(--mush-rgb-state-alarm-armed, var(--rgb-success));
    --rgb-state-alarm-triggered: var(--mush-rgb-state-alarm-triggered, var(--rgb-danger));

    /* State person colors */
    --rgb-state-person-home: var(--mush-rgb-state-person-home, var(--rgb-success));
    --rgb-state-person-not-home: var(--mush-rgb-state-person-not-home, var(--rgb-danger));
    --rgb-state-person-zone: var(--mush-rgb-state-person-zone, var(--rgb-info));
    --rgb-state-person-unknown: var(--mush-rgb-state-person-unknown, var(--rgb-grey));

    /* State update colors */
    --rgb-state-update-on: var(--mush-rgb-state-update-on, var(--rgb-orange));
    --rgb-state-update-off: var(--mush-rgb-update-off, var(--rgb-green));
    --rgb-state-update-installing: var(--mush-rgb-update-installing, var(--rgb-blue));

    /* State lock colors */
    --rgb-state-lock-locked: var(--mush-rgb-state-lock-locked, var(--rgb-green));
    --rgb-state-lock-unlocked: var(--mush-rgb-state-lock-unlocked, var(--rgb-red));
    --rgb-state-lock-pending: var(--mush-rgb-state-lock-pending, var(--rgb-orange));

    /* State cover colors */
    --rgb-state-cover-open: var(--mush-rgb-state-cover-open, var(--rgb-blue));
    --rgb-state-cover-closed: var(--mush-rgb-state-cover-closed, var(--rgb-disabled));

    /* State climate colors */
    --rgb-state-climate-auto: var(--mush-rgb-state-climate-auto, var(--rgb-green));
    --rgb-state-climate-cool: var(--mush-rgb-state-climate-cool, var(--rgb-blue));
    --rgb-state-climate-dry: var(--mush-rgb-state-climate-dry, var(--rgb-orange));
    --rgb-state-climate-fan-only: var(--mush-rgb-state-climate-fan-only, var(--rgb-teal));
    --rgb-state-climate-heat: var(--mush-rgb-state-climate-heat, var(--rgb-deep-orange));
    --rgb-state-climate-heat-cool: var(--mush-rgb-state-climate-heat-cool, var(--rgb-green));
    --rgb-state-climate-idle: var(--mush-rgb-state-climate-idle, var(--rgb-disabled));
    --rgb-state-climate-off: var(--mush-rgb-state-climate-off, var(--rgb-disabled));
`;

function computeDarkMode(hass) {
    if (!hass)
        return false;
    return hass.themes.darkMode;
}
class MushroomBaseElement extends s$1 {
    updated(changedProps) {
        super.updated(changedProps);
        if (changedProps.has("hass") && this.hass) {
            const currentDarkMode = computeDarkMode(changedProps.get("hass"));
            const newDarkMode = computeDarkMode(this.hass);
            if (currentDarkMode !== newDarkMode) {
                this.toggleAttribute("dark-mode", newDarkMode);
            }
        }
    }
    static get styles() {
        return r$3 `
            :host {
                ${defaultColorCss}
            }
            :host([dark-mode]) {
                ${defaultDarkColorCss}
            }
            :host {
                ${themeColorCss}
                ${themeVariables}
            }
        `;
    }
}
__decorate([
    e$3({ attribute: false })
], MushroomBaseElement.prototype, "hass", void 0);

class MushroomBaseCard extends MushroomBaseElement {
    renderPicture(picture) {
        return $ `
            <mushroom-shape-avatar
                slot="icon"
                .picture_url=${this.hass.hassUrl(picture)}
            ></mushroom-shape-avatar>
        `;
    }
    renderIcon(entity, icon) {
        const active = isActive(entity);
        return $ `
            <mushroom-shape-icon
                slot="icon"
                .disabled=${!active}
                .icon=${icon}
            ></mushroom-shape-icon>
        `;
    }
    renderBadge(entity) {
        const unavailable = !isAvailable(entity);
        return unavailable
            ? $ `
                  <mushroom-badge-icon
                      class="unavailable"
                      slot="badge"
                      icon="mdi:help"
                  ></mushroom-badge-icon>
              `
            : null;
    }
    renderStateInfo(entity, appearance, name, state) {
        const defaultState = computeStateDisplay(this.hass.localize, entity, this.hass.locale, this.hass.entities);
        const displayState = state !== null && state !== void 0 ? state : defaultState;
        const primary = computeInfoDisplay(appearance.primary_info, name, displayState, entity, this.hass);
        const secondary = computeInfoDisplay(appearance.secondary_info, name, displayState, entity, this.hass);
        return $ `
            <mushroom-state-info
                slot="info"
                .primary=${primary}
                .secondary=${secondary}
            ></mushroom-state-info>
        `;
    }
}

const cardStyle = r$3 `
    ha-card {
        box-sizing: border-box;
        padding: var(--spacing);
        display: flex;
        flex-direction: column;
        justify-content: var(--layout-align);
        height: auto;
    }
    ha-card.fill-container {
        height: 100%;
    }
    .actions {
        display: flex;
        flex-direction: row;
        align-items: flex-start;
        justify-content: flex-start;
        overflow-x: auto;
        overflow-y: hidden;
        scrollbar-width: none; /* Firefox */
        -ms-overflow-style: none; /* IE 10+ */
    }
    .actions::-webkit-scrollbar {
        background: transparent; /* Chrome/Safari/Webkit */
        height: 0px;
    }
    .actions *:not(:last-child) {
        margin-right: var(--spacing);
    }
    .actions[rtl] *:not(:last-child) {
        margin-right: initial;
        margin-left: var(--spacing);
    }
    .unavailable {
        --main-color: var(--warning-color);
    }
`;

function registerCustomCard(params) {
    const windowWithCards = window;
    windowWithCards.customCards = windowWithCards.customCards || [];
    windowWithCards.customCards.push(Object.assign(Object.assign({}, params), { preview: true }));
}

const alarmPanelIcon = (state) => {
    switch (state) {
        case "armed_away":
            return "mdi:shield-lock";
        case "armed_vacation":
            return "mdi:shield-airplane";
        case "armed_home":
            return "mdi:shield-home";
        case "armed_night":
            return "mdi:shield-moon";
        case "armed_custom_bypass":
            return "mdi:security";
        case "pending":
        case "arming":
            return "mdi:shield-sync";
        case "triggered":
            return "mdi:bell-ring";
        case "disarmed":
            return "mdi:shield-off";
        default:
            return "mdi:shield";
    }
};
const alarmPanelIconAction = (state) => {
    switch (state) {
        case "armed_away":
            return "mdi:shield-lock-outline";
        case "armed_vacation":
            return "mdi:shield-airplane-outline";
        case "armed_home":
            return "mdi:shield-home-outline";
        case "armed_night":
            return "mdi:shield-moon-outline";
        case "armed_custom_bypass":
            return "mdi:shield-half-full";
        case "disarmed":
            return "mdi:shield-off-outline";
        default:
            return "mdi:shield-outline";
    }
};

const binarySensorIcon = (state, stateObj) => {
    const isOff = state === "off";
    switch (stateObj === null || stateObj === void 0 ? void 0 : stateObj.attributes.device_class) {
        case "battery":
            return isOff ? "mdi:battery" : "mdi:battery-outline";
        case "battery_charging":
            return isOff ? "mdi:battery" : "mdi:battery-charging";
        case "carbon_monoxide":
            return isOff ? "mdi:smoke-detector" : "mdi:smoke-detector-alert";
        case "cold":
            return isOff ? "mdi:thermometer" : "mdi:snowflake";
        case "connectivity":
            return isOff ? "mdi:close-network-outline" : "mdi:check-network-outline";
        case "door":
            return isOff ? "mdi:door-closed" : "mdi:door-open";
        case "garage_door":
            return isOff ? "mdi:garage" : "mdi:garage-open";
        case "power":
            return isOff ? "mdi:power-plug-off" : "mdi:power-plug";
        case "gas":
        case "problem":
        case "safety":
        case "tamper":
            return isOff ? "mdi:check-circle" : "mdi:alert-circle";
        case "smoke":
            return isOff ? "mdi:smoke-detector-variant" : "mdi:smoke-detector-variant-alert";
        case "heat":
            return isOff ? "mdi:thermometer" : "mdi:fire";
        case "light":
            return isOff ? "mdi:brightness-5" : "mdi:brightness-7";
        case "lock":
            return isOff ? "mdi:lock" : "mdi:lock-open";
        case "moisture":
            return isOff ? "mdi:water-off" : "mdi:water";
        case "motion":
            return isOff ? "mdi:motion-sensor-off" : "mdi:motion-sensor";
        case "occupancy":
            return isOff ? "mdi:home-outline" : "mdi:home";
        case "opening":
            return isOff ? "mdi:square" : "mdi:square-outline";
        case "plug":
            return isOff ? "mdi:power-plug-off" : "mdi:power-plug";
        case "presence":
            return isOff ? "mdi:home-outline" : "mdi:home";
        case "running":
            return isOff ? "mdi:stop" : "mdi:play";
        case "sound":
            return isOff ? "mdi:music-note-off" : "mdi:music-note";
        case "update":
            return isOff ? "mdi:package" : "mdi:package-up";
        case "vibration":
            return isOff ? "mdi:crop-portrait" : "mdi:vibrate";
        case "window":
            return isOff ? "mdi:window-closed" : "mdi:window-open";
        default:
            return isOff ? "mdi:radiobox-blank" : "mdi:checkbox-marked-circle";
    }
};

const coverIcon = (state, stateObj) => {
    const open = state !== "closed";
    switch (stateObj === null || stateObj === void 0 ? void 0 : stateObj.attributes.device_class) {
        case "garage":
            switch (state) {
                case "opening":
                    return "mdi:arrow-up-box";
                case "closing":
                    return "mdi:arrow-down-box";
                case "closed":
                    return "mdi:garage";
                default:
                    return "mdi:garage-open";
            }
        case "gate":
            switch (state) {
                case "opening":
                case "closing":
                    return "mdi:gate-arrow-right";
                case "closed":
                    return "mdi:gate";
                default:
                    return "mdi:gate-open";
            }
        case "door":
            return open ? "mdi:door-open" : "mdi:door-closed";
        case "damper":
            return open ? "mdi:circle" : "mdi:circle-slice-8";
        case "shutter":
            switch (state) {
                case "opening":
                    return "mdi:arrow-up-box";
                case "closing":
                    return "mdi:arrow-down-box";
                case "closed":
                    return "mdi:window-shutter";
                default:
                    return "mdi:window-shutter-open";
            }
        case "curtain":
            switch (state) {
                case "opening":
                    return "mdi:arrow-split-vertical";
                case "closing":
                    return "mdi:arrow-collapse-horizontal";
                case "closed":
                    return "mdi:curtains-closed";
                default:
                    return "mdi:curtains";
            }
        case "blind":
            switch (state) {
                case "opening":
                    return "mdi:arrow-up-box";
                case "closing":
                    return "mdi:arrow-down-box";
                case "closed":
                    return "mdi:blinds-horizontal-closed";
                default:
                    return "mdi:blinds-horizontal";
            }
        case "shade":
            switch (state) {
                case "opening":
                    return "mdi:arrow-up-box";
                case "closing":
                    return "mdi:arrow-down-box";
                case "closed":
                    return "mdi:roller-shade-closed";
                default:
                    return "mdi:roller-shade";
            }
        case "window":
            switch (state) {
                case "opening":
                    return "mdi:arrow-up-box";
                case "closing":
                    return "mdi:arrow-down-box";
                case "closed":
                    return "mdi:window-closed";
                default:
                    return "mdi:window-open";
            }
    }
    switch (state) {
        case "opening":
            return "mdi:arrow-up-box";
        case "closing":
            return "mdi:arrow-down-box";
        case "closed":
            return "mdi:window-closed";
        default:
            return "mdi:window-open";
    }
};
const computeOpenIcon = (stateObj) => {
    switch (stateObj.attributes.device_class) {
        case "awning":
        case "curtain":
        case "door":
        case "gate":
            return "mdi:arrow-expand-horizontal";
        default:
            return "mdi:arrow-up";
    }
};
const computeCloseIcon = (stateObj) => {
    switch (stateObj.attributes.device_class) {
        case "awning":
        case "curtain":
        case "door":
        case "gate":
            return "mdi:arrow-collapse-horizontal";
        default:
            return "mdi:arrow-down";
    }
};

const FIXED_DEVICE_CLASS_ICONS = {
    apparent_power: "mdi:flash",
    aqi: "mdi:air-filter",
    atmospheric_pressure: "mdi:thermometer-lines",
    // battery: "mdi:battery", => not included by design since `sensorIcon()` will dynamically determine the icon
    carbon_dioxide: "mdi:molecule-co2",
    carbon_monoxide: "mdi:molecule-co",
    current: "mdi:current-ac",
    data_rate: "mdi:transmission-tower",
    data_size: "mdi:database",
    date: "mdi:calendar",
    distance: "mdi:arrow-left-right",
    duration: "mdi:progress-clock",
    energy: "mdi:lightning-bolt",
    frequency: "mdi:sine-wave",
    gas: "mdi:meter-gas",
    humidity: "mdi:water-percent",
    illuminance: "mdi:brightness-5",
    irradiance: "mdi:sun-wireless",
    moisture: "mdi:water-percent",
    monetary: "mdi:cash",
    nitrogen_dioxide: "mdi:molecule",
    nitrogen_monoxide: "mdi:molecule",
    nitrous_oxide: "mdi:molecule",
    ozone: "mdi:molecule",
    pm1: "mdi:molecule",
    pm10: "mdi:molecule",
    pm25: "mdi:molecule",
    power: "mdi:flash",
    power_factor: "mdi:angle-acute",
    precipitation: "mdi:weather-rainy",
    precipitation_intensity: "mdi:weather-pouring",
    pressure: "mdi:gauge",
    reactive_power: "mdi:flash",
    signal_strength: "mdi:wifi",
    sound_pressure: "mdi:ear-hearing",
    speed: "mdi:speedometer",
    sulphur_dioxide: "mdi:molecule",
    temperature: "mdi:thermometer",
    timestamp: "mdi:clock",
    volatile_organic_compounds: "mdi:molecule",
    voltage: "mdi:sine-wave",
    volume: "mdi:car-coolant-level",
    water: "mdi:water",
    weight: "mdi:weight",
    wind_speed: "mdi:weather-windy",
};
const SENSOR_DEVICE_CLASS_BATTERY = "battery";
const BATTERY_ICONS = {
    10: "mdi:battery-10",
    20: "mdi:battery-20",
    30: "mdi:battery-30",
    40: "mdi:battery-40",
    50: "mdi:battery-50",
    60: "mdi:battery-60",
    70: "mdi:battery-70",
    80: "mdi:battery-80",
    90: "mdi:battery-90",
    100: "mdi:battery",
};
const BATTERY_CHARGING_ICONS = {
    10: "mdi:battery-charging-10",
    20: "mdi:battery-charging-20",
    30: "mdi:battery-charging-30",
    40: "mdi:battery-charging-40",
    50: "mdi:battery-charging-50",
    60: "mdi:battery-charging-60",
    70: "mdi:battery-charging-70",
    80: "mdi:battery-charging-80",
    90: "mdi:battery-charging-90",
    100: "mdi:battery-charging",
};
const batteryStateIcon = (batteryEntity, batteryChargingEntity) => {
    const battery = batteryEntity.state;
    const batteryCharging = (batteryChargingEntity === null || batteryChargingEntity === void 0 ? void 0 : batteryChargingEntity.state) === "on";
    return batteryIcon(battery, batteryCharging);
};
const batteryIcon = (batteryState, batteryCharging) => {
    const batteryValue = Number(batteryState);
    if (isNaN(batteryValue)) {
        if (batteryState === "off") {
            return "mdi:battery";
        }
        if (batteryState === "on") {
            return "mdi:battery-alert";
        }
        return "mdi:battery-unknown";
    }
    const batteryRound = Math.round(batteryValue / 10) * 10;
    if (batteryCharging && batteryValue >= 10) {
        return BATTERY_CHARGING_ICONS[batteryRound];
    }
    if (batteryCharging) {
        return "mdi:battery-charging-outline";
    }
    if (batteryValue <= 5) {
        return "mdi:battery-alert-variant-outline";
    }
    return BATTERY_ICONS[batteryRound];
};
const sensorIcon = (entity) => {
    const dclass = entity === null || entity === void 0 ? void 0 : entity.attributes.device_class;
    if (dclass && dclass in FIXED_DEVICE_CLASS_ICONS) {
        return FIXED_DEVICE_CLASS_ICONS[dclass];
    }
    if (dclass === SENSOR_DEVICE_CLASS_BATTERY) {
        return entity ? batteryStateIcon(entity) : "mdi:battery";
    }
    const unit = entity === null || entity === void 0 ? void 0 : entity.attributes.unit_of_measurement;
    if (unit === UNIT_C || unit === UNIT_F) {
        return "mdi:thermometer";
    }
    return undefined;
};

const weatherIcons = {
    "clear-night": "mdi:weather-night",
    cloudy: "mdi:weather-cloudy",
    exceptional: "mdi:alert-circle-outline",
    fog: "mdi:weather-fog",
    hail: "mdi:weather-hail",
    lightning: "mdi:weather-lightning",
    "lightning-rainy": "mdi:weather-lightning-rainy",
    partlycloudy: "mdi:weather-partly-cloudy",
    pouring: "mdi:weather-pouring",
    rainy: "mdi:weather-rainy",
    snowy: "mdi:weather-snowy",
    "snowy-rainy": "mdi:weather-snowy-rainy",
    sunny: "mdi:weather-sunny",
    windy: "mdi:weather-windy",
    "windy-variant": "mdi:weather-windy-variant",
};
const weatherIcon = (state, nightTime) => !state
    ? undefined
    : nightTime && state === "partlycloudy"
        ? "mdiWeatherNightPartlyCloudy"
        : weatherIcons[state];

const DEFAULT_DOMAIN_ICON = "mdi:bookmark";
const FIXED_DOMAIN_ICONS = {
    alert: "mdi:alert",
    air_quality: "mdi:air-filter",
    automation: "mdi:robot",
    calendar: "mdi:calendar",
    camera: "mdi:video",
    climate: "mdi:thermostat",
    configurator: "mdi:cog",
    conversation: "mdi:text-to-speech",
    counter: "mdi:counter",
    fan: "mdi:fan",
    google_assistant: "mdi:google-assistant",
    group: "mdi:google-circles-communities",
    homeassistant: "mdi:home-assistant",
    homekit: "mdi:home-automation",
    image_processing: "mdi:image-filter-frames",
    input_button: "mdi:gesture-tap-button",
    input_datetime: "mdi:calendar-clock",
    input_number: "mdi:ray-vertex",
    input_select: "mdi:format-list-bulleted",
    input_text: "mdi:form-textbox",
    light: "mdi:lightbulb",
    mailbox: "mdi:mailbox",
    notify: "mdi:comment-alert",
    number: "mdi:ray-vertex",
    persistent_notification: "mdi:bell",
    person: "mdi:account",
    plant: "mdi:flower",
    proximity: "mdi:apple-safari",
    remote: "mdi:remote",
    scene: "mdi:palette",
    script: "mdi:script-text",
    select: "mdi:format-list-bulleted",
    sensor: "mdi:eye",
    siren: "mdi:bullhorn",
    simple_alarm: "mdi:bell",
    sun: "mdi:white-balance-sunny",
    timer: "mdi:timer-outline",
    updater: "mdi:cloud-upload",
    vacuum: "mdi:robot-vacuum",
    water_heater: "mdi:thermometer",
    zone: "mdi:map-marker-radius",
};
function domainIcon(domain, stateObj, state) {
    const compareState = state !== undefined ? state : stateObj === null || stateObj === void 0 ? void 0 : stateObj.state;
    switch (domain) {
        case "alarm_control_panel":
            return alarmPanelIcon(compareState);
        case "binary_sensor":
            return binarySensorIcon(compareState, stateObj);
        case "button":
            switch (stateObj === null || stateObj === void 0 ? void 0 : stateObj.attributes.device_class) {
                case "restart":
                    return "mdi:restart";
                case "update":
                    return "mdi:package-up";
                default:
                    return "mdi:gesture-tap-button";
            }
        case "cover":
            return coverIcon(compareState, stateObj);
        case "device_tracker":
            if ((stateObj === null || stateObj === void 0 ? void 0 : stateObj.attributes.source_type) === "router") {
                return compareState === "home" ? "mdi:lan-connect" : "mdi:lan-disconnect";
            }
            if (["bluetooth", "bluetooth_le"].includes(stateObj === null || stateObj === void 0 ? void 0 : stateObj.attributes.source_type)) {
                return compareState === "home" ? "mdi:bluetooth-connect" : "mdi:bluetooth";
            }
            return compareState === "not_home" ? "mdi:account-arrow-right" : "mdi:account";
        case "humidifier":
            return compareState && compareState === "off"
                ? "mdi:air-humidifier-off"
                : "mdi:air-humidifier";
        case "input_boolean":
            return compareState === "on" ? "mdi:check-circle-outline" : "mdi:close-circle-outline";
        case "input_datetime":
            if (!(stateObj === null || stateObj === void 0 ? void 0 : stateObj.attributes.has_date)) {
                return "mdi:clock";
            }
            if (!stateObj.attributes.has_time) {
                return "mdi:calendar";
            }
            break;
        case "lock":
            switch (compareState) {
                case "unlocked":
                    return "mdi:lock-open";
                case "jammed":
                    return "mdi:lock-alert";
                case "locking":
                case "unlocking":
                    return "mdi:lock-clock";
                default:
                    return "mdi:lock";
            }
        case "media_player":
            switch (stateObj === null || stateObj === void 0 ? void 0 : stateObj.attributes.device_class) {
                case "speaker":
                    switch (compareState) {
                        case "playing":
                            return "mdi:speaker-play";
                        case "paused":
                            return "mdi:speaker-pause";
                        case "off":
                            return "mdi:speaker-off";
                        default:
                            return "mdi:speaker";
                    }
                case "tv":
                    switch (compareState) {
                        case "playing":
                            return "mdi:television-play";
                        case "paused":
                            return "mdi:television-pause";
                        case "off":
                            return "mdi:television-off";
                        default:
                            return "mdi:television";
                    }
                case "receiver":
                    switch (compareState) {
                        case "off":
                            return "mdi:audio-video-off";
                        default:
                            return "mdi:audio-video";
                    }
                default:
                    switch (compareState) {
                        case "playing":
                        case "paused":
                            return "mdi:cast-connected";
                        case "off":
                            return "mdi:cast-off";
                        default:
                            return "mdi:cast";
                    }
            }
        case "person":
            return compareState === "not_home" ? "mdi:account-arrow-right" : "mdi:account";
        case "switch":
            switch (stateObj === null || stateObj === void 0 ? void 0 : stateObj.attributes.device_class) {
                case "outlet":
                    return compareState === "on" ? "mdi:power-plug" : "mdi:power-plug-off";
                case "switch":
                    return compareState === "on"
                        ? "mdi:toggle-switch-variant"
                        : "mdi:toggle-switch-variant-off";
                default:
                    return "mdi:toggle-switch-variant";
            }
        case "sensor": {
            const icon = sensorIcon(stateObj);
            if (icon) {
                return icon;
            }
            break;
        }
        case "sun":
            return (stateObj === null || stateObj === void 0 ? void 0 : stateObj.state) === "above_horizon"
                ? FIXED_DOMAIN_ICONS[domain]
                : "mdi:weather-night";
        case "switch_as_x":
            return "mdi:swap-horizontal";
        case "threshold":
            return "mdi:chart-sankey";
        case "update":
            return (stateObj === null || stateObj === void 0 ? void 0 : stateObj.state) === "on"
                ? updateIsInstalling(stateObj)
                    ? "mdi:package-down"
                    : "mdi:package-up"
                : "mdi:package";
        case "weather":
            return weatherIcon(stateObj === null || stateObj === void 0 ? void 0 : stateObj.state);
    }
    if (domain in FIXED_DOMAIN_ICONS) {
        return FIXED_DOMAIN_ICONS[domain];
    }
    return DEFAULT_DOMAIN_ICON;
}

function stateIcon(entity) {
    if (entity.attributes.icon) {
        return entity.attributes.icon;
    }
    const domain = computeDomain(entity.entity_id);
    const state = entity.state;
    return domainIcon(domain, entity, state);
}

const PREFIX_NAME = "mushroom";

const ALARM_CONTROl_PANEL_CARD_NAME = `${PREFIX_NAME}-alarm-control-panel-card`;
const ALARM_CONTROl_PANEL_CARD_EDITOR_NAME = `${ALARM_CONTROl_PANEL_CARD_NAME}-editor`;
const ALARM_CONTROl_PANEL_ENTITY_DOMAINS = ["alarm_control_panel"];
const ALARM_CONTROL_PANEL_CARD_STATE_COLOR = {
    disarmed: "var(--rgb-state-alarm-disarmed)",
    armed: "var(--rgb-state-alarm-armed)",
    triggered: "var(--rgb-state-alarm-triggered)",
    unavailable: "var(--rgb-warning)",
};
const ALARM_CONTROL_PANEL_CARD_DEFAULT_STATE_COLOR = "var(--rgb-grey)";
const ALARM_CONTROL_PANEL_CARD_STATE_SERVICE = {
    disarmed: "alarm_disarm",
    armed_away: "alarm_arm_away",
    armed_home: "alarm_arm_home",
    armed_night: "alarm_arm_night",
    armed_vacation: "alarm_arm_vacation",
    armed_custom_bypass: "alarm_arm_custom_bypass",
};

function getStateColor$3(state) {
    var _a;
    return ((_a = ALARM_CONTROL_PANEL_CARD_STATE_COLOR[state.split("_")[0]]) !== null && _a !== void 0 ? _a : ALARM_CONTROL_PANEL_CARD_DEFAULT_STATE_COLOR);
}
function getStateService(state) {
    return ALARM_CONTROL_PANEL_CARD_STATE_SERVICE[state];
}
function shouldPulse(state) {
    return ["arming", "triggered", "pending", UNAVAILABLE].indexOf(state) >= 0;
}
function isActionsAvailable(entity) {
    return UNAVAILABLE !== entity.state;
}
function isDisarmed(entity) {
    return entity.state === "disarmed";
}
function hasCode(entity) {
    return entity.attributes.code_format && entity.attributes.code_format !== "no_code";
}

registerCustomCard({
    type: ALARM_CONTROl_PANEL_CARD_NAME,
    name: "Mushroom Alarm Control Panel Card",
    description: "Card for alarm control panel",
});
const BUTTONS = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "", "0", "clear"];
/*
 * Ref: https://github.com/home-assistant/frontend/blob/dev/src/panels/lovelace/cards/hui-alarm-panel-card.ts
 * TODO: customize icon for modes (advanced YAML configuration)
 */
let AlarmControlPanelCard = class AlarmControlPanelCard extends MushroomBaseCard {
    static async getConfigElement() {
        await Promise.resolve().then(function () { return alarmControlPanelCardEditor; });
        return document.createElement(ALARM_CONTROl_PANEL_CARD_EDITOR_NAME);
    }
    static async getStubConfig(hass) {
        const entities = Object.keys(hass.states);
        const panels = entities.filter((e) => ALARM_CONTROl_PANEL_ENTITY_DOMAINS.includes(e.split(".")[0]));
        return {
            type: `custom:${ALARM_CONTROl_PANEL_CARD_NAME}`,
            entity: panels[0],
            states: ["armed_home", "armed_away"],
        };
    }
    getCardSize() {
        return 1;
    }
    setConfig(config) {
        this._config = Object.assign({ tap_action: {
                action: "more-info",
            }, hold_action: {
                action: "more-info",
            } }, config);
        this.loadComponents();
    }
    updated(changedProperties) {
        super.updated(changedProperties);
        if (this.hass && changedProperties.has("hass")) {
            this.loadComponents();
        }
    }
    async loadComponents() {
        if (!this._config || !this.hass || !this._config.entity)
            return;
        const entity_id = this._config.entity;
        const entity = this.hass.states[entity_id];
        if (hasCode(entity)) {
            void Promise.resolve().then(function () { return mushroomTextfield; });
        }
    }
    _onTap(e, state) {
        var _a, _b;
        const service = getStateService(state);
        if (!service)
            return;
        e.stopPropagation();
        const code = ((_a = this._input) === null || _a === void 0 ? void 0 : _a.value) || undefined;
        this.hass.callService("alarm_control_panel", service, {
            entity_id: (_b = this._config) === null || _b === void 0 ? void 0 : _b.entity,
            code,
        });
        if (this._input) {
            this._input.value = "";
        }
    }
    _handlePadClick(e) {
        const val = e.currentTarget.value;
        if (this._input) {
            this._input.value = val === "clear" ? "" : this._input.value + val;
        }
    }
    _handleAction(ev) {
        handleAction(this, this.hass, this._config, ev.detail.action);
    }
    get _hasCode() {
        var _a, _b, _c;
        const entity_id = (_a = this._config) === null || _a === void 0 ? void 0 : _a.entity;
        if (entity_id) {
            const entity = this.hass.states[entity_id];
            return hasCode(entity) && ((_c = (_b = this._config) === null || _b === void 0 ? void 0 : _b.show_keypad) !== null && _c !== void 0 ? _c : false);
        }
        return false;
    }
    render() {
        if (!this.hass || !this._config || !this._config.entity) {
            return $ ``;
        }
        const entity_id = this._config.entity;
        const entity = this.hass.states[entity_id];
        const name = this._config.name || entity.attributes.friendly_name || "";
        const icon = this._config.icon || stateIcon(entity);
        const appearance = computeAppearance(this._config);
        const picture = computeEntityPicture(entity, appearance.icon_type);
        const actions = this._config.states && this._config.states.length > 0
            ? isDisarmed(entity)
                ? this._config.states.map((state) => ({ state }))
                : [{ state: "disarmed" }]
            : [];
        const isActionEnabled = isActionsAvailable(entity);
        const rtl = computeRTL(this.hass);
        return $ `
            <ha-card class=${o({ "fill-container": appearance.fill_container })}>
                <mushroom-card .appearance=${appearance} ?rtl=${rtl}>
                    <mushroom-state-item
                        ?rtl=${rtl}
                        .appearance=${appearance}
                        @action=${this._handleAction}
                        .actionHandler=${actionHandler({
            hasHold: hasAction(this._config.hold_action),
            hasDoubleClick: hasAction(this._config.double_tap_action),
        })}
                    >
                        ${picture ? this.renderPicture(picture) : this.renderIcon(entity, icon)}
                        ${this.renderBadge(entity)}
                        ${this.renderStateInfo(entity, appearance, name)};
                    </mushroom-state-item>
                    ${actions.length > 0
            ? $ `
                              <mushroom-button-group
                                  .fill="${appearance.layout !== "horizontal"}"
                                  ?rtl=${rtl}
                              >
                                  ${actions.map((action) => $ `
                                          <mushroom-button
                                              .icon=${alarmPanelIconAction(action.state)}
                                              @click=${(e) => this._onTap(e, action.state)}
                                              .disabled=${!isActionEnabled}
                                          ></mushroom-button>
                                      `)}
                              </mushroom-button-group>
                          `
            : null}
                </mushroom-card>
                ${!this._hasCode
            ? $ ``
            : $ `
                          <mushroom-textfield
                              id="alarmCode"
                              .label=${this.hass.localize("ui.card.alarm_control_panel.code")}
                              type="password"
                              .inputmode=${entity.attributes.code_format === "number"
                ? "numeric"
                : "text"}
                          ></mushroom-textfield>
                      `}
                ${!(this._hasCode && entity.attributes.code_format === "number")
            ? $ ``
            : $ `
                          <div id="keypad">
                              ${BUTTONS.map((value) => value === ""
                ? $ `<mwc-button disabled></mwc-button>`
                : $ `
                                            <mwc-button
                                                .value=${value}
                                                @click=${this._handlePadClick}
                                                outlined
                                                class=${o({
                    numberkey: value !== "clear",
                })}
                                            >
                                                ${value === "clear"
                    ? this.hass.localize(`ui.card.alarm_control_panel.clear_code`)
                    : value}
                                            </mwc-button>
                                        `)}
                          </div>
                      `}
            </ha-card>
        `;
    }
    renderIcon(entity, icon) {
        const color = getStateColor$3(entity.state);
        const shapePulse = shouldPulse(entity.state);
        const iconStyle = {
            "--icon-color": `rgb(${color})`,
            "--shape-color": `rgba(${color}, 0.2)`,
        };
        return $ `
            <mushroom-shape-icon
                slot="icon"
                style=${i$2(iconStyle)}
                class=${o({
            pulse: shapePulse,
        })}
                .icon=${icon}
            ></mushroom-shape-icon>
        `;
    }
    static get styles() {
        return [
            super.styles,
            cardStyle,
            r$3 `
                mushroom-state-item {
                    cursor: pointer;
                }
                .alert {
                    --main-color: var(--warning-color);
                }
                mushroom-shape-icon.pulse {
                    --shape-animation: 1s ease 0s infinite normal none running pulse;
                }
                mushroom-textfield {
                    display: block;
                    margin: 8px auto;
                    max-width: 150px;
                    text-align: center;
                }
                #keypad {
                    display: flex;
                    justify-content: center;
                    flex-wrap: wrap;
                    margin: auto;
                    width: 100%;
                    max-width: 300px;
                }
                #keypad mwc-button {
                    padding: 8px;
                    width: 30%;
                    box-sizing: border-box;
                }
            `,
        ];
    }
};
__decorate([
    t$1()
], AlarmControlPanelCard.prototype, "_config", void 0);
__decorate([
    i$4("#alarmCode")
], AlarmControlPanelCard.prototype, "_input", void 0);
AlarmControlPanelCard = __decorate([
    n$1(ALARM_CONTROl_PANEL_CARD_NAME)
], AlarmControlPanelCard);

let Chip = class Chip extends s$1 {
    constructor() {
        super(...arguments);
        this.icon = "";
        this.label = "";
        this.avatar = "";
        this.avatarOnly = false;
    }
    render() {
        return $ `
            <ha-card>
                ${this.avatar ? $ ` <img class="avatar" src=${this.avatar} /> ` : null}
                ${!this.avatarOnly
            ? $ `
                          <div class="content">
                              <slot></slot>
                          </div>
                      `
            : null}
            </ha-card>
        `;
    }
    static get styles() {
        return r$3 `
            :host {
                --icon-color: var(--primary-text-color);
                --text-color: var(--primary-text-color);
            }
            ha-card {
                box-sizing: border-box;
                height: var(--chip-height);
                min-width: var(--chip-height);
                font-size: var(--chip-height);
                width: auto;
                border-radius: var(--chip-border-radius);
                display: flex;
                flex-direction: row;
                align-items: center;
                background: var(--chip-background);
                border-width: var(--chip-border-width);
                border-color: var(--chip-border-color);
                box-shadow: var(--chip-box-shadow);
                box-sizing: content-box;
            }
            .avatar {
                --avatar-size: calc(var(--chip-height) - 2 * var(--chip-avatar-padding));
                border-radius: var(--chip-avatar-border-radius);
                height: var(--avatar-size);
                width: var(--avatar-size);
                margin-left: var(--chip-avatar-padding);
                box-sizing: border-box;
                object-fit: cover;
            }
            :host([rtl]) .avatar {
                margin-left: initial;
                margin-right: var(--chip-avatar-padding);
            }
            .content {
                display: flex;
                flex-direction: row;
                align-items: center;
                justify-content: center;
                height: 100%;
                padding: var(--chip-padding);
                line-height: 0;
            }
            ::slotted(ha-icon) {
                display: flex;
                --mdc-icon-size: var(--chip-icon-size);
                color: var(--icon-color);
            }
            ::slotted(svg) {
                width: var(--chip-icon-size);
                height: var(--chip-icon-size);
                display: flex;
            }
            ::slotted(span) {
                font-weight: var(--chip-font-weight);
                font-size: var(--chip-font-size);
                line-height: 1;
                color: var(--text-color);
            }
            ::slotted(*:not(:last-child)) {
                margin-right: 0.15em;
            }
            :host([rtl]) ::slotted(*:not(:last-child)) {
                margin-right: initial;
                margin-left: 0.15em;
            }
        `;
    }
};
__decorate([
    e$3()
], Chip.prototype, "icon", void 0);
__decorate([
    e$3()
], Chip.prototype, "label", void 0);
__decorate([
    e$3()
], Chip.prototype, "avatar", void 0);
__decorate([
    e$3()
], Chip.prototype, "avatarOnly", void 0);
Chip = __decorate([
    n$1("mushroom-chip")
], Chip);

const createChipElement = (config) => {
    try {
        // @ts-ignore
        const element = document.createElement(computeChipComponentName(config.type), config);
        element.setConfig(config);
        return element;
    }
    catch (err) {
        return undefined;
    }
};
function computeChipComponentName(type) {
    return `${PREFIX_NAME}-${type}-chip`;
}
function computeChipEditorComponentName(type) {
    return `${PREFIX_NAME}-${type}-chip-editor`;
}

let EntityChip = class EntityChip extends s$1 {
    static async getConfigElement() {
        await Promise.resolve().then(function () { return entityChipEditor; });
        return document.createElement(computeChipEditorComponentName("entity"));
    }
    static async getStubConfig(hass) {
        const entities = Object.keys(hass.states);
        return {
            type: `entity`,
            entity: entities[0],
        };
    }
    setConfig(config) {
        this._config = config;
    }
    _handleAction(ev) {
        handleAction(this, this.hass, this._config, ev.detail.action);
    }
    render() {
        var _a;
        if (!this.hass || !this._config || !this._config.entity) {
            return $ ``;
        }
        const entity_id = this._config.entity;
        const entity = this.hass.states[entity_id];
        const name = this._config.name || entity.attributes.friendly_name || "";
        const icon = this._config.icon || stateIcon(entity);
        const iconColor = this._config.icon_color;
        const picture = this._config.use_entity_picture ? getEntityPicture(entity) : undefined;
        const stateDisplay = computeStateDisplay(this.hass.localize, entity, this.hass.locale, this.hass.entities);
        const active = isActive(entity);
        if (iconColor) {
            computeRgbColor(iconColor);
        }
        const content = computeInfoDisplay((_a = this._config.content_info) !== null && _a !== void 0 ? _a : "state", name, stateDisplay, entity, this.hass);
        const rtl = computeRTL(this.hass);
        return $ `
            <mushroom-chip
                ?rtl=${rtl}
                @action=${this._handleAction}
                .actionHandler=${actionHandler({
            hasHold: hasAction(this._config.hold_action),
            hasDoubleClick: hasAction(this._config.double_tap_action),
        })}
                .avatar=${picture ? this.hass.hassUrl(picture) : undefined}
                .avatarOnly=${picture && !content}
            >
                ${!picture ? this.renderIcon(icon, iconColor, active) : null}
                ${content ? $ `<span>${content}</span>` : null}
            </mushroom-chip>
        `;
    }
    renderIcon(icon, iconColor, active) {
        const iconStyle = {};
        if (iconColor) {
            const iconRgbColor = computeRgbColor(iconColor);
            iconStyle["--color"] = `rgb(${iconRgbColor})`;
        }
        return $ `
            <ha-icon
                .icon=${icon}
                style=${i$2(iconStyle)}
                class=${o({ active })}
            ></ha-icon>
        `;
    }
    static get styles() {
        return r$3 `
            mushroom-chip {
                cursor: pointer;
            }
            ha-icon.active {
                color: var(--color);
            }
        `;
    }
};
__decorate([
    e$3({ attribute: false })
], EntityChip.prototype, "hass", void 0);
__decorate([
    t$1()
], EntityChip.prototype, "_config", void 0);
EntityChip = __decorate([
    n$1(computeChipComponentName("entity"))
], EntityChip);

const cloudyStates = new Set([
    "partlycloudy",
    "cloudy",
    "fog",
    "windy",
    "windy-variant",
    "hail",
    "rainy",
    "snowy",
    "snowy-rainy",
    "pouring",
    "lightning",
    "lightning-rainy",
]);
const rainStates = new Set(["hail", "rainy", "pouring"]);
const windyStates = new Set(["windy", "windy-variant"]);
const snowyStates = new Set(["snowy", "snowy-rainy"]);
const lightningStates = new Set(["lightning", "lightning-rainy"]);
const weatherSVGStyles = r$3 `
    .rain {
        fill: var(--weather-icon-rain-color, #30b3ff);
    }
    .sun {
        fill: var(--weather-icon-sun-color, #fdd93c);
    }
    .moon {
        fill: var(--weather-icon-moon-color, #fcf497);
    }
    .cloud-back {
        fill: var(--weather-icon-cloud-back-color, #d4d4d4);
    }
    .cloud-front {
        fill: var(--weather-icon-cloud-front-color, #f9f9f9);
    }
`;
const getWeatherStateSVG = (state, nightTime) => y `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 17 17"
  >
  ${state === "sunny"
    ? y `
          <path
            class="sun"
            d="m 14.39303,8.4033507 c 0,3.3114723 -2.684145,5.9956173 -5.9956169,5.9956173 -3.3114716,0 -5.9956168,-2.684145 -5.9956168,-5.9956173 0,-3.311471 2.6841452,-5.995617 5.9956168,-5.995617 3.3114719,0 5.9956169,2.684146 5.9956169,5.995617"
          />
        `
    : ""}
  ${state === "clear-night"
    ? y `
          <path
            class="moon"
            d="m 13.502891,11.382935 c -1.011285,1.859223 -2.976664,3.121381 -5.2405751,3.121381 -3.289929,0 -5.953329,-2.663833 -5.953329,-5.9537625 0,-2.263911 1.261724,-4.228856 3.120948,-5.240575 -0.452782,0.842738 -0.712753,1.806363 -0.712753,2.832381 0,3.289928 2.663833,5.9533275 5.9533291,5.9533275 1.026017,0 1.989641,-0.259969 2.83238,-0.712752"
          />
        `
    : ""}
  ${state === "partlycloudy" && nightTime
    ? y `
          <path
            class="moon"
            d="m14.981 4.2112c0 1.9244-1.56 3.4844-3.484 3.4844-1.9244 0-3.4844-1.56-3.4844-3.4844s1.56-3.484 3.4844-3.484c1.924 0 3.484 1.5596 3.484 3.484"
          />
        `
    : state === "partlycloudy"
        ? y `
          <path
            class="sun"
            d="m14.981 4.2112c0 1.9244-1.56 3.4844-3.484 3.4844-1.9244 0-3.4844-1.56-3.4844-3.4844s1.56-3.484 3.4844-3.484c1.924 0 3.484 1.5596 3.484 3.484"
          />
        `
        : ""}
  ${cloudyStates.has(state)
    ? y `
          <path
            class="cloud-back"
            d="m3.8863 5.035c-0.54892 0.16898-1.04 0.46637-1.4372 0.8636-0.63077 0.63041-1.0206 1.4933-1.0206 2.455 0 1.9251 1.5589 3.4682 3.4837 3.4682h6.9688c1.9251 0 3.484-1.5981 3.484-3.5232 0-1.9251-1.5589-3.5232-3.484-3.5232h-1.0834c-0.25294-1.6916-1.6986-2.9083-3.4463-2.9083-1.7995 0-3.2805 1.4153-3.465 3.1679"
          />
          <path
            class="cloud-front"
            d="m4.1996 7.6995c-0.33902 0.10407-0.64276 0.28787-0.88794 0.5334-0.39017 0.38982-0.63147 0.92322-0.63147 1.5176 0 1.1896 0.96414 2.1431 2.1537 2.1431h4.3071c1.1896 0 2.153-0.98742 2.153-2.1777 0-1.1896-0.96344-2.1777-2.153-2.1777h-0.66992c-0.15593-1.0449-1.0499-1.7974-2.1297-1.7974-1.112 0-2.0274 0.87524-2.1417 1.9586"
          />
        `
    : ""}
  ${rainStates.has(state)
    ? y `
          <path
            class="rain"
            d="m5.2852 14.734c-0.22401 0.24765-0.57115 0.2988-0.77505 0.11395-0.20391-0.1845-0.18732-0.53481 0.036689-0.78281 0.14817-0.16298 0.59126-0.32914 0.87559-0.42369 0.12453-0.04092 0.22684 0.05186 0.19791 0.17956-0.065617 0.2921-0.18732 0.74965-0.33514 0.91299"
          />
          <path
            class="rain"
            d="m11.257 14.163c-0.22437 0.24765-0.57115 0.2988-0.77505 0.11395-0.2039-0.1845-0.18768-0.53481 0.03669-0.78281 0.14817-0.16298 0.59126-0.32914 0.8756-0.42369 0.12453-0.04092 0.22684 0.05186 0.19791 0.17956-0.06562 0.2921-0.18732 0.74965-0.33514 0.91299"
          />
          <path
            class="rain"
            d="m8.432 15.878c-0.15452 0.17039-0.3937 0.20567-0.53446 0.07867-0.14041-0.12735-0.12876-0.36865 0.025753-0.53975 0.10195-0.11218 0.40711-0.22684 0.60325-0.29175 0.085725-0.02858 0.15628 0.03563 0.13652 0.12382-0.045508 0.20108-0.12912 0.51647-0.23107 0.629"
          />
          <path
            class="rain"
            d="m7.9991 14.118c-0.19226 0.21237-0.49001 0.25612-0.66499 0.09737-0.17462-0.15804-0.16051-0.45861 0.03175-0.67098 0.12665-0.14005 0.50729-0.28293 0.75071-0.36336 0.10689-0.03563 0.19473 0.0441 0.17004 0.15346-0.056092 0.25082-0.16051 0.64347-0.28751 0.78352"
          />
        `
    : ""}
  ${state === "pouring"
    ? y `
          <path
            class="rain"
            d="m10.648 16.448c-0.19226 0.21449-0.49001 0.25894-0.66499 0.09878-0.17498-0.16016-0.16087-0.4639 0.03175-0.67874 0.12665-0.14146 0.50694-0.2854 0.75071-0.36724 0.10689-0.03563 0.19473 0.0448 0.17004 0.15558-0.05645 0.25365-0.16051 0.65017-0.28751 0.79163"
          />
          <path
            class="rain"
            d="m5.9383 16.658c-0.22437 0.25012-0.5715 0.30162-0.77505 0.11501-0.20391-0.18627-0.18768-0.54046 0.036689-0.79093 0.14817-0.1651 0.59126-0.33267 0.87559-0.42827 0.12418-0.04127 0.22648 0.05221 0.19791 0.18168-0.065617 0.29528-0.18732 0.75741-0.33514 0.92251"
          />
        `
    : ""}
  ${windyStates.has(state)
    ? y `
          <path
            class="cloud-back"
            d="m 13.59616,15.30968 c 0,0 -0.09137,-0.0071 -0.250472,-0.0187 -0.158045,-0.01235 -0.381353,-0.02893 -0.64382,-0.05715 -0.262466,-0.02716 -0.564444,-0.06385 -0.877358,-0.124531 -0.156986,-0.03034 -0.315383,-0.06844 -0.473781,-0.111478 -0.157691,-0.04551 -0.313266,-0.09842 -0.463902,-0.161219 l -0.267406,-0.0949 c -0.09984,-0.02646 -0.205669,-0.04904 -0.305153,-0.06738 -0.193322,-0.02716 -0.3838218,-0.03316 -0.5640912,-0.02011 -0.3626556,0.02611 -0.6847417,0.119239 -0.94615,0.226483 -0.2617611,0.108656 -0.4642556,0.230364 -0.600075,0.324203 -0.1358195,0.09419 -0.2049639,0.160514 -0.2049639,0.160514 0,0 0.089958,-0.01623 0.24765,-0.04445 0.1559278,-0.02575 0.3764139,-0.06174 0.6367639,-0.08714 0.2596444,-0.02646 0.5591527,-0.0441 0.8678333,-0.02328 0.076905,0.0035 0.1538111,0.01658 0.2321278,0.02293 0.077611,0.01058 0.1534581,0.02893 0.2314221,0.04022 0.07267,0.01834 0.1397,0.03986 0.213078,0.05644 l 0.238125,0.08925 c 0.09207,0.03281 0.183444,0.07055 0.275872,0.09878 0.09243,0.0261 0.185208,0.05327 0.277636,0.07161 0.184856,0.0388 0.367947,0.06174 0.543983,0.0702 0.353131,0.01905 0.678745,-0.01341 0.951442,-0.06456 0.27305,-0.05292 0.494595,-0.123119 0.646642,-0.181681 0.152047,-0.05785 0.234597,-0.104069 0.234597,-0.104069"
          />
          <path
            class="cloud-back"
            d="m 4.7519154,13.905801 c 0,0 0.091369,-0.0032 0.2511778,-0.0092 0.1580444,-0.0064 0.3820583,-0.01446 0.6455833,-0.03281 0.2631722,-0.01729 0.5662083,-0.04269 0.8812389,-0.09137 0.1576916,-0.02434 0.3175,-0.05609 0.4776611,-0.09384 0.1591027,-0.03951 0.3167944,-0.08643 0.4699,-0.14358 l 0.2702277,-0.08467 c 0.1008945,-0.02222 0.2074334,-0.04127 0.3072695,-0.05574 0.1943805,-0.01976 0.3848805,-0.0187 0.5651499,0.0014 0.3608917,0.03951 0.67945,0.144639 0.936625,0.261761 0.2575278,0.118534 0.4554364,0.247297 0.5873754,0.346781 0.132291,0.09913 0.198966,0.168275 0.198966,0.168275 0,0 -0.08925,-0.01976 -0.245886,-0.05397 C 9.9423347,14.087088 9.7232597,14.042988 9.4639681,14.00736 9.2057347,13.97173 8.9072848,13.94245 8.5978986,13.95162 c -0.077258,7.06e-4 -0.1541638,0.01058 -0.2328333,0.01411 -0.077964,0.0078 -0.1545166,0.02328 -0.2331861,0.03175 -0.073025,0.01588 -0.1404055,0.03422 -0.2141361,0.04798 l -0.2420055,0.08008 c -0.093486,0.02963 -0.1859139,0.06421 -0.2794,0.0889 C 7.3028516,14.23666 7.2093653,14.2603 7.116232,14.27512 6.9303181,14.30722 6.7465209,14.3231 6.5697792,14.32486 6.2166487,14.33046 5.8924459,14.28605 5.6218654,14.224318 5.3505793,14.161565 5.1318571,14.082895 4.9822793,14.01869 4.8327015,13.95519 4.7519154,13.905801 4.7519154,13.905801"
          />
        `
    : ""}
  ${snowyStates.has(state)
    ? y `
          <path
            class="rain"
            d="m 8.4319893,15.348341 c 0,0.257881 -0.209197,0.467079 -0.467078,0.467079 -0.258586,0 -0.46743,-0.209198 -0.46743,-0.467079 0,-0.258233 0.208844,-0.467431 0.46743,-0.467431 0.257881,0 0.467078,0.209198 0.467078,0.467431"
          />
          <path
            class="rain"
            d="m 11.263878,14.358553 c 0,0.364067 -0.295275,0.659694 -0.659695,0.659694 -0.364419,0 -0.6596937,-0.295627 -0.6596937,-0.659694 0,-0.364419 0.2952747,-0.659694 0.6596937,-0.659694 0.36442,0 0.659695,0.295275 0.659695,0.659694"
          />
          <path
            class="rain"
            d="m 5.3252173,13.69847 c 0,0.364419 -0.295275,0.660047 -0.659695,0.660047 -0.364067,0 -0.659694,-0.295628 -0.659694,-0.660047 0,-0.364067 0.295627,-0.659694 0.659694,-0.659694 0.36442,0 0.659695,0.295627 0.659695,0.659694"
          />
        `
    : ""}
  ${lightningStates.has(state)
    ? y `
          <path
            class="sun"
            d="m 9.9252695,10.935875 -1.6483986,2.341014 1.1170184,0.05929 -1.2169864,2.02141 3.0450261,-2.616159 H 9.8864918 L 10.97937,11.294651 10.700323,10.79794 h -0.508706 l -0.2663475,0.137936"
          />
        `
    : ""}
  </svg>`;

let WeatherChip = class WeatherChip extends s$1 {
    static async getConfigElement() {
        await Promise.resolve().then(function () { return weatherChipEditor; });
        return document.createElement(computeChipEditorComponentName("weather"));
    }
    static async getStubConfig(hass) {
        const entities = Object.keys(hass.states);
        const weathers = entities.filter((e) => e.split(".")[0] === "weather");
        return {
            type: `weather`,
            entity: weathers[0],
        };
    }
    setConfig(config) {
        this._config = config;
    }
    _handleAction(ev) {
        handleAction(this, this.hass, this._config, ev.detail.action);
    }
    render() {
        if (!this.hass || !this._config || !this._config.entity) {
            return $ ``;
        }
        const entity_id = this._config.entity;
        const entity = this.hass.states[entity_id];
        const weatherIcon = getWeatherStateSVG(entity.state, true);
        const displayLabels = [];
        if (this._config.show_conditions) {
            const stateDisplay = computeStateDisplay(this.hass.localize, entity, this.hass.locale, this.hass.entities);
            displayLabels.push(stateDisplay);
        }
        if (this._config.show_temperature) {
            const temperatureDisplay = `${formatNumber(entity.attributes.temperature, this.hass.locale)} ${this.hass.config.unit_system.temperature}`;
            displayLabels.push(temperatureDisplay);
        }
        const rtl = computeRTL(this.hass);
        return $ `
            <mushroom-chip
                ?rtl=${rtl}
                @action=${this._handleAction}
                .actionHandler=${actionHandler({
            hasHold: hasAction(this._config.hold_action),
            hasDoubleClick: hasAction(this._config.double_tap_action),
        })}
            >
                ${weatherIcon}
                ${displayLabels.length > 0 ? $ `<span>${displayLabels.join(" / ")}</span>` : null}
            </mushroom-chip>
        `;
    }
    static get styles() {
        return [
            weatherSVGStyles,
            r$3 `
                mushroom-chip {
                    cursor: pointer;
                }
            `,
        ];
    }
};
__decorate([
    e$3({ attribute: false })
], WeatherChip.prototype, "hass", void 0);
__decorate([
    t$1()
], WeatherChip.prototype, "_config", void 0);
WeatherChip = __decorate([
    n$1(computeChipComponentName("weather"))
], WeatherChip);

const DEFAULT_BACK_ICON = "mdi:arrow-left";
let BackChip = class BackChip extends s$1 {
    static async getConfigElement() {
        await Promise.resolve().then(function () { return backChipEditor; });
        return document.createElement(computeChipEditorComponentName("back"));
    }
    static async getStubConfig(_hass) {
        return {
            type: `back`,
        };
    }
    setConfig(config) {
        this._config = config;
    }
    _handleAction() {
        window.history.back();
    }
    render() {
        if (!this.hass || !this._config) {
            return $ ``;
        }
        const icon = this._config.icon || DEFAULT_BACK_ICON;
        const rtl = computeRTL(this.hass);
        return $ `
            <mushroom-chip
                ?rtl=${rtl}
                @action=${this._handleAction}
                .actionHandler=${actionHandler()}
            >
                <ha-icon .icon=${icon}></ha-icon>
            </mushroom-chip>
        `;
    }
    static get styles() {
        return r$3 `
            mushroom-chip {
                cursor: pointer;
            }
        `;
    }
};
__decorate([
    e$3({ attribute: false })
], BackChip.prototype, "hass", void 0);
__decorate([
    t$1()
], BackChip.prototype, "_config", void 0);
BackChip = __decorate([
    n$1(computeChipComponentName("back"))
], BackChip);

const DEFAULT_ACTION_ICON = "mdi:flash";
let ActionChip = class ActionChip extends s$1 {
    static async getConfigElement() {
        await Promise.resolve().then(function () { return actionChipEditor; });
        return document.createElement(computeChipEditorComponentName("action"));
    }
    static async getStubConfig(_hass) {
        return {
            type: `action`,
        };
    }
    setConfig(config) {
        this._config = config;
    }
    _handleAction(ev) {
        handleAction(this, this.hass, this._config, ev.detail.action);
    }
    render() {
        if (!this.hass || !this._config) {
            return $ ``;
        }
        const icon = this._config.icon || DEFAULT_ACTION_ICON;
        const iconColor = this._config.icon_color;
        const iconStyle = {};
        if (iconColor) {
            const iconRgbColor = computeRgbColor(iconColor);
            iconStyle["--color"] = `rgb(${iconRgbColor})`;
        }
        const rtl = computeRTL(this.hass);
        return $ `
            <mushroom-chip
                ?rtl=${rtl}
                @action=${this._handleAction}
                .actionHandler=${actionHandler({
            hasHold: hasAction(this._config.hold_action),
            hasDoubleClick: hasAction(this._config.double_tap_action),
        })}
            >
                <ha-icon .icon=${icon} style=${i$2(iconStyle)}></ha-icon>
            </mushroom-chip>
        `;
    }
    static get styles() {
        return r$3 `
            mushroom-chip {
                cursor: pointer;
            }
            ha-icon {
                color: var(--color);
            }
        `;
    }
};
__decorate([
    e$3({ attribute: false })
], ActionChip.prototype, "hass", void 0);
__decorate([
    t$1()
], ActionChip.prototype, "_config", void 0);
ActionChip = __decorate([
    n$1(computeChipComponentName("action"))
], ActionChip);

const DEFAULT_MENU_ICON = "mdi:menu";
let MenuChip = class MenuChip extends s$1 {
    static async getConfigElement() {
        await Promise.resolve().then(function () { return menuChipEditor; });
        return document.createElement(computeChipEditorComponentName("menu"));
    }
    static async getStubConfig(_hass) {
        return {
            type: `menu`,
        };
    }
    setConfig(config) {
        this._config = config;
    }
    _handleAction() {
        fireEvent(this, "hass-toggle-menu");
    }
    render() {
        if (!this.hass || !this._config) {
            return $ ``;
        }
        const icon = this._config.icon || DEFAULT_MENU_ICON;
        const rtl = computeRTL(this.hass);
        return $ `
            <mushroom-chip
                ?rtl=${rtl}
                @action=${this._handleAction}
                .actionHandler=${actionHandler()}
            >
                <ha-icon .icon=${icon}></ha-icon>
            </mushroom-chip>
        `;
    }
    static get styles() {
        return r$3 `
            mushroom-chip {
                cursor: pointer;
            }
        `;
    }
};
__decorate([
    e$3({ attribute: false })
], MenuChip.prototype, "hass", void 0);
__decorate([
    t$1()
], MenuChip.prototype, "_config", void 0);
MenuChip = __decorate([
    n$1(computeChipComponentName("menu"))
], MenuChip);

const TEMPLATE_KEYS$2 = ["content", "icon", "icon_color", "picture"];
let TemplateChip = class TemplateChip extends s$1 {
    constructor() {
        super(...arguments);
        this._templateResults = {};
        this._unsubRenderTemplates = new Map();
    }
    static async getConfigElement() {
        await Promise.resolve().then(function () { return templateChipEditor; });
        return document.createElement(computeChipEditorComponentName("template"));
    }
    static async getStubConfig(_hass) {
        return {
            type: `template`,
        };
    }
    setConfig(config) {
        TEMPLATE_KEYS$2.forEach((key) => {
            var _a, _b;
            if (((_a = this._config) === null || _a === void 0 ? void 0 : _a[key]) !== config[key] || ((_b = this._config) === null || _b === void 0 ? void 0 : _b.entity) != config.entity) {
                this._tryDisconnectKey(key);
            }
        });
        this._config = Object.assign({ tap_action: {
                action: "toggle",
            }, hold_action: {
                action: "more-info",
            } }, config);
    }
    connectedCallback() {
        super.connectedCallback();
        this._tryConnect();
    }
    disconnectedCallback() {
        this._tryDisconnect();
    }
    _handleAction(ev) {
        handleAction(this, this.hass, this._config, ev.detail.action);
    }
    isTemplate(key) {
        var _a;
        const value = (_a = this._config) === null || _a === void 0 ? void 0 : _a[key];
        return value === null || value === void 0 ? void 0 : value.includes("{");
    }
    getValue(key) {
        var _a, _b;
        return this.isTemplate(key) ? (_a = this._templateResults[key]) === null || _a === void 0 ? void 0 : _a.result : (_b = this._config) === null || _b === void 0 ? void 0 : _b[key];
    }
    render() {
        if (!this.hass || !this._config) {
            return $ ``;
        }
        const icon = this.getValue("icon");
        const iconColor = this.getValue("icon_color");
        const content = this.getValue("content");
        const picture = this.getValue("picture");
        const rtl = computeRTL(this.hass);
        return $ `
            <mushroom-chip
                ?rtl=${rtl}
                @action=${this._handleAction}
                .actionHandler=${actionHandler({
            hasHold: hasAction(this._config.hold_action),
            hasDoubleClick: hasAction(this._config.double_tap_action),
        })}
                .avatar=${picture ? this.hass.hassUrl(picture) : undefined}
                .avatarOnly=${picture && !content}
            >
                ${icon && !picture ? this.renderIcon(icon, iconColor) : null}
                ${content ? this.renderContent(content) : null}
            </mushroom-chip>
        `;
    }
    renderIcon(icon, iconColor) {
        const iconStyle = {};
        if (iconColor) {
            const iconRgbColor = computeRgbColor(iconColor);
            iconStyle["--color"] = `rgb(${iconRgbColor})`;
        }
        return $ `<ha-icon .icon=${icon} style=${i$2(iconStyle)}></ha-icon>`;
    }
    renderContent(content) {
        return $ `<span>${content}</span>`;
    }
    updated(changedProps) {
        super.updated(changedProps);
        if (!this._config || !this.hass) {
            return;
        }
        this._tryConnect();
    }
    async _tryConnect() {
        TEMPLATE_KEYS$2.forEach((key) => {
            this._tryConnectKey(key);
        });
    }
    async _tryConnectKey(key) {
        var _a, _b;
        if (this._unsubRenderTemplates.get(key) !== undefined ||
            !this.hass ||
            !this._config ||
            !this.isTemplate(key)) {
            return;
        }
        try {
            const sub = subscribeRenderTemplate(this.hass.connection, (result) => {
                this._templateResults = Object.assign(Object.assign({}, this._templateResults), { [key]: result });
            }, {
                template: (_a = this._config[key]) !== null && _a !== void 0 ? _a : "",
                entity_ids: this._config.entity_id,
                variables: {
                    config: this._config,
                    user: this.hass.user.name,
                    entity: this._config.entity,
                },
                strict: true,
            });
            this._unsubRenderTemplates.set(key, sub);
            await sub;
        }
        catch (_err) {
            const result = {
                result: (_b = this._config[key]) !== null && _b !== void 0 ? _b : "",
                listeners: {
                    all: false,
                    domains: [],
                    entities: [],
                    time: false,
                },
            };
            this._templateResults = Object.assign(Object.assign({}, this._templateResults), { [key]: result });
            this._unsubRenderTemplates.delete(key);
        }
    }
    async _tryDisconnect() {
        TEMPLATE_KEYS$2.forEach((key) => {
            this._tryDisconnectKey(key);
        });
    }
    async _tryDisconnectKey(key) {
        const unsubRenderTemplate = this._unsubRenderTemplates.get(key);
        if (!unsubRenderTemplate) {
            return;
        }
        try {
            const unsub = await unsubRenderTemplate;
            unsub();
            this._unsubRenderTemplates.delete(key);
        }
        catch (err) {
            if (err.code === "not_found" || err.code === "template_error") ;
            else {
                throw err;
            }
        }
    }
    static get styles() {
        return r$3 `
            mushroom-chip {
                cursor: pointer;
            }
            ha-icon {
                color: var(--color);
            }
        `;
    }
};
__decorate([
    e$3({ attribute: false })
], TemplateChip.prototype, "hass", void 0);
__decorate([
    t$1()
], TemplateChip.prototype, "_config", void 0);
__decorate([
    t$1()
], TemplateChip.prototype, "_templateResults", void 0);
__decorate([
    t$1()
], TemplateChip.prototype, "_unsubRenderTemplates", void 0);
TemplateChip = __decorate([
    n$1(computeChipComponentName("template"))
], TemplateChip);

let ConditionalBase = class ConditionalBase extends a$1 {
    constructor() {
        super(...arguments);
        this.hidden = false;
    }
    createRenderRoot() {
        return this;
    }
    validateConfig(config) {
        if (!config.conditions) {
            throw new Error("No conditions configured");
        }
        if (!Array.isArray(config.conditions)) {
            throw new Error("Conditions need to be an array");
        }
        if (!validateConditionalConfig(config.conditions)) {
            throw new Error("Conditions are invalid");
        }
        if (this.lastChild) {
            this.removeChild(this.lastChild);
        }
        this._config = config;
    }
    update(changed) {
        super.update(changed);
        if (!this._element || !this.hass || !this._config) {
            return;
        }
        this._element.editMode = this.editMode;
        const visible = this.editMode || checkConditionsMet(this._config.conditions, this.hass);
        this.hidden = !visible;
        this.style.setProperty("display", visible ? "" : "none");
        if (visible) {
            this._element.hass = this.hass;
            if (!this._element.parentElement) {
                this.appendChild(this._element);
            }
        }
    }
};
__decorate([
    e$3({ attribute: false })
], ConditionalBase.prototype, "hass", void 0);
__decorate([
    e$3()
], ConditionalBase.prototype, "editMode", void 0);
__decorate([
    e$3()
], ConditionalBase.prototype, "_config", void 0);
__decorate([
    e$3({ type: Boolean, reflect: true })
], ConditionalBase.prototype, "hidden", void 0);
ConditionalBase = __decorate([
    n$1("mushroom-conditional-base")
], ConditionalBase);

let ConditionalChip = class ConditionalChip extends ConditionalBase {
    static async getConfigElement() {
        await Promise.resolve().then(function () { return conditionalChipEditor; });
        return document.createElement(computeChipEditorComponentName("conditional"));
    }
    static async getStubConfig() {
        return {
            type: `conditional`,
            conditions: [],
        };
    }
    setConfig(config) {
        this.validateConfig(config);
        if (!config.chip) {
            throw new Error("No row configured");
        }
        this._element = createChipElement(config.chip);
    }
};
ConditionalChip = __decorate([
    n$1(computeChipComponentName("conditional"))
], ConditionalChip);

function getBrightness(entity) {
    return entity.attributes.brightness != null
        ? Math.max(Math.round((entity.attributes.brightness * 100) / 255), 1)
        : undefined;
}
function getColorTemp(entity) {
    return entity.attributes.color_temp != null
        ? Math.round(entity.attributes.color_temp)
        : undefined;
}
function getRGBColor(entity) {
    return entity.attributes.rgb_color != null ? entity.attributes.rgb_color : undefined;
}
function isColorLight(rgb) {
    const color$1 = color.rgb(rgb);
    return color$1.l() > 96;
}
function isColorSuperLight(rgb) {
    const color$1 = color.rgb(rgb);
    return color$1.l() > 97;
}
function supportsColorTempControl(entity) {
    var _a;
    return (_a = entity.attributes.supported_color_modes) === null || _a === void 0 ? void 0 : _a.some((m) => ["color_temp" /* COLOR_TEMP */].includes(m));
}
function supportsColorControl(entity) {
    return lightSupportsColor(entity);
}
function supportsBrightnessControl(entity) {
    return lightSupportsDimming(entity);
}

let LightChip = class LightChip extends s$1 {
    static async getConfigElement() {
        await Promise.resolve().then(function () { return lightChipEditor; });
        return document.createElement(computeChipEditorComponentName("light"));
    }
    static async getStubConfig(hass) {
        const entities = Object.keys(hass.states);
        const lights = entities.filter((e) => e.split(".")[0] === "light");
        return {
            type: `light`,
            entity: lights[0],
        };
    }
    setConfig(config) {
        this._config = Object.assign({ tap_action: {
                action: "toggle",
            }, hold_action: {
                action: "more-info",
            } }, config);
    }
    _handleAction(ev) {
        handleAction(this, this.hass, this._config, ev.detail.action);
    }
    render() {
        var _a, _b;
        if (!this.hass || !this._config || !this._config.entity) {
            return $ ``;
        }
        const entity_id = this._config.entity;
        const entity = this.hass.states[entity_id];
        const name = this._config.name || entity.attributes.friendly_name || "";
        const icon = this._config.icon || stateIcon(entity);
        const stateDisplay = computeStateDisplay(this.hass.localize, entity, this.hass.locale, this.hass.entities);
        const active = isActive(entity);
        const lightRgbColor = getRGBColor(entity);
        const iconStyle = {};
        if (lightRgbColor && ((_a = this._config) === null || _a === void 0 ? void 0 : _a.use_light_color)) {
            const color = lightRgbColor.join(",");
            iconStyle["--color"] = `rgb(${color})`;
            if (isColorSuperLight(lightRgbColor)) {
                iconStyle["--color"] = `rgba(var(--rgb-primary-text-color), 0.2)`;
            }
        }
        const content = computeInfoDisplay((_b = this._config.content_info) !== null && _b !== void 0 ? _b : "state", name, stateDisplay, entity, this.hass);
        const rtl = computeRTL(this.hass);
        return $ `
            <mushroom-chip
                ?rtl=${rtl}
                @action=${this._handleAction}
                .actionHandler=${actionHandler({
            hasHold: hasAction(this._config.hold_action),
            hasDoubleClick: hasAction(this._config.double_tap_action),
        })}
            >
                <ha-icon
                    .icon=${icon}
                    style=${i$2(iconStyle)}
                    class=${o({ active })}
                ></ha-icon>
                ${content ? $ `<span>${content}</span>` : null}
            </mushroom-chip>
        `;
    }
    static get styles() {
        return r$3 `
            :host {
                --color: rgb(var(--rgb-state-light));
            }
            mushroom-chip {
                cursor: pointer;
            }
            ha-icon.active {
                color: var(--color);
            }
        `;
    }
};
__decorate([
    e$3({ attribute: false })
], LightChip.prototype, "hass", void 0);
__decorate([
    t$1()
], LightChip.prototype, "_config", void 0);
LightChip = __decorate([
    n$1(computeChipComponentName("light"))
], LightChip);

let AlarmControlPanelChip = class AlarmControlPanelChip extends s$1 {
    static async getConfigElement() {
        await Promise.resolve().then(function () { return alarmControlPanelChipEditor; });
        return document.createElement(computeChipEditorComponentName("alarm-control-panel"));
    }
    static async getStubConfig(hass) {
        const entities = Object.keys(hass.states);
        const panels = entities.filter((e) => ALARM_CONTROl_PANEL_ENTITY_DOMAINS.includes(e.split(".")[0]));
        return {
            type: `alarm-control-panel`,
            entity: panels[0],
        };
    }
    setConfig(config) {
        this._config = config;
    }
    _handleAction(ev) {
        handleAction(this, this.hass, this._config, ev.detail.action);
    }
    render() {
        var _a;
        if (!this.hass || !this._config || !this._config.entity) {
            return $ ``;
        }
        const entity_id = this._config.entity;
        const entity = this.hass.states[entity_id];
        const name = this._config.name || entity.attributes.friendly_name || "";
        const icon = this._config.icon || stateIcon(entity);
        const iconColor = getStateColor$3(entity.state);
        const iconPulse = shouldPulse(entity.state);
        const stateDisplay = computeStateDisplay(this.hass.localize, entity, this.hass.locale, this.hass.entities);
        const iconStyle = {};
        if (iconColor) {
            const iconRgbColor = computeRgbColor(iconColor);
            iconStyle["--color"] = `rgb(${iconRgbColor})`;
        }
        const content = computeInfoDisplay((_a = this._config.content_info) !== null && _a !== void 0 ? _a : "state", name, stateDisplay, entity, this.hass);
        const rtl = computeRTL(this.hass);
        return $ `
            <mushroom-chip
                ?rtl=${rtl}
                @action=${this._handleAction}
                .actionHandler=${actionHandler({
            hasHold: hasAction(this._config.hold_action),
            hasDoubleClick: hasAction(this._config.double_tap_action),
        })}
            >
                <ha-icon
                    .icon=${icon}
                    style=${i$2(iconStyle)}
                    class=${o({ pulse: iconPulse })}
                ></ha-icon>
                ${content ? $ `<span>${content}</span>` : null}
            </mushroom-chip>
        `;
    }
    // Animation cannot be defined on chip element, key-frames cannot be scoped to a slotted element: https://github.com/WICG/webcomponents/issues/748
    static get styles() {
        return r$3 `
            mushroom-chip {
                cursor: pointer;
            }
            ha-icon {
                color: var(--color);
            }
            ha-icon.pulse {
                animation: 1s ease 0s infinite normal none running pulse;
            }
            ${animation.pulse}
        `;
    }
};
__decorate([
    e$3({ attribute: false })
], AlarmControlPanelChip.prototype, "hass", void 0);
__decorate([
    t$1()
], AlarmControlPanelChip.prototype, "_config", void 0);
AlarmControlPanelChip = __decorate([
    n$1(computeChipComponentName("alarm-control-panel"))
], AlarmControlPanelChip);

const CHIPS_CARD_NAME = `${PREFIX_NAME}-chips-card`;
const CHIPS_CARD_EDITOR_NAME = `${CHIPS_CARD_NAME}-editor`;

registerCustomCard({
    type: CHIPS_CARD_NAME,
    name: "Mushroom Chips Card",
    description: "Card with chips to display informations",
});
let ChipsCard = class ChipsCard extends s$1 {
    static async getConfigElement() {
        await Promise.resolve().then(function () { return chipsCardEditor; });
        return document.createElement(CHIPS_CARD_EDITOR_NAME);
    }
    static async getStubConfig(_hass) {
        const chips = await Promise.all([EntityChip.getStubConfig(_hass)]);
        return {
            type: `custom:${CHIPS_CARD_NAME}`,
            chips,
        };
    }
    set hass(hass) {
        var _a;
        const currentDarkMode = computeDarkMode(this._hass);
        const newDarkMode = computeDarkMode(hass);
        if (currentDarkMode !== newDarkMode) {
            this.toggleAttribute("dark-mode", newDarkMode);
        }
        this._hass = hass;
        (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelectorAll("div > *").forEach((element) => {
            element.hass = hass;
        });
    }
    getCardSize() {
        return 1;
    }
    setConfig(config) {
        this._config = config;
    }
    render() {
        if (!this._config || !this._hass) {
            return $ ``;
        }
        let alignment = "";
        if (this._config.alignment) {
            alignment = `align-${this._config.alignment}`;
        }
        const rtl = computeRTL(this._hass);
        return $ `
            <ha-card>
                <div class="chip-container ${alignment}" ?rtl=${rtl}>
                    ${this._config.chips.map((chip) => this.renderChip(chip))}
                </div>
            </ha-card>
        `;
    }
    renderChip(chipConfig) {
        const element = createChipElement(chipConfig);
        if (!element) {
            return $ ``;
        }
        if (this._hass) {
            element.hass = this._hass;
        }
        return $ `${element}`;
    }
    static get styles() {
        return [
            MushroomBaseElement.styles,
            r$3 `
                ha-card {
                    background: none;
                    box-shadow: none;
                    border-radius: 0;
                    border: none;
                }
                .chip-container {
                    display: flex;
                    flex-direction: row;
                    align-items: flex-start;
                    justify-content: flex-start;
                    flex-wrap: wrap;
                    margin-bottom: calc(-1 * var(--chip-spacing));
                }
                .chip-container.align-end {
                    justify-content: flex-end;
                }
                .chip-container.align-center {
                    justify-content: center;
                }
                .chip-container.align-justify {
                    justify-content: space-between;
                }
                .chip-container * {
                    margin-bottom: var(--chip-spacing);
                }
                .chip-container *:not(:last-child) {
                    margin-right: var(--chip-spacing);
                }
                .chip-container[rtl] *:not(:last-child) {
                    margin-right: initial;
                    margin-left: var(--chip-spacing);
                }
            `,
        ];
    }
};
__decorate([
    t$1()
], ChipsCard.prototype, "_config", void 0);
ChipsCard = __decorate([
    n$1(CHIPS_CARD_NAME)
], ChipsCard);

const CLIMATE_CARD_NAME = `${PREFIX_NAME}-climate-card`;
const CLIMATE_CARD_EDITOR_NAME = `${CLIMATE_CARD_NAME}-editor`;
const CLIMATE_ENTITY_DOMAINS = ["climate"];

const CLIMATE_HVAC_MODE_COLORS = {
    auto: "var(--rgb-state-climate-auto)",
    cool: "var(--rgb-state-climate-cool)",
    dry: "var(--rgb-state-climate-dry)",
    fan_only: "var(--rgb-state-climate-fan-only)",
    heat: "var(--rgb-state-climate-heat)",
    heat_cool: "var(--rgb-state-climate-heat-cool)",
    off: "var(--rgb-state-climate-off)",
};
const CLIMATE_HVAC_ACTION_COLORS = {
    cooling: "var(--rgb-state-climate-cool)",
    drying: "var(--rgb-state-climate-dry)",
    heating: "var(--rgb-state-climate-heat)",
    idle: "var(--rgb-state-climate-idle)",
    off: "var(--rgb-state-climate-off)",
};
const CLIMATE_HVAC_MODE_ICONS = {
    auto: "mdi:calendar-sync",
    cool: "mdi:snowflake",
    dry: "mdi:water-percent",
    fan_only: "mdi:fan",
    heat: "mdi:fire",
    heat_cool: "mdi:autorenew",
    off: "mdi:power",
};
const CLIMATE_HVAC_ACTION_ICONS = {
    cooling: "mdi:snowflake",
    drying: "mdi:water-percent",
    heating: "mdi:fire",
    idle: "mdi:clock-outline",
    off: "mdi:power",
};
function getHvacModeColor(hvacMode) {
    var _a;
    return (_a = CLIMATE_HVAC_MODE_COLORS[hvacMode]) !== null && _a !== void 0 ? _a : CLIMATE_HVAC_MODE_COLORS.off;
}
function getHvacActionColor(hvacAction) {
    var _a;
    return (_a = CLIMATE_HVAC_ACTION_COLORS[hvacAction]) !== null && _a !== void 0 ? _a : CLIMATE_HVAC_ACTION_COLORS.off;
}
function getHvacModeIcon(hvacMode) {
    var _a;
    return (_a = CLIMATE_HVAC_MODE_ICONS[hvacMode]) !== null && _a !== void 0 ? _a : "mdi:thermostat";
}
function getHvacActionIcon(hvacAction) {
    var _a;
    return (_a = CLIMATE_HVAC_ACTION_ICONS[hvacAction]) !== null && _a !== void 0 ? _a : "";
}

const isHvacModesVisible = (entity, modes) => (entity.attributes.hvac_modes || []).some((mode) => (modes !== null && modes !== void 0 ? modes : []).includes(mode));
let ClimateHvacModesControl = class ClimateHvacModesControl extends s$1 {
    constructor() {
        super(...arguments);
        this.fill = false;
    }
    callService(e) {
        e.stopPropagation();
        const mode = e.target.mode;
        this.hass.callService("climate", "set_hvac_mode", {
            entity_id: this.entity.entity_id,
            hvac_mode: mode,
        });
    }
    render() {
        const rtl = computeRTL(this.hass);
        const modes = this.entity.attributes.hvac_modes
            .filter((mode) => { var _a; return ((_a = this.modes) !== null && _a !== void 0 ? _a : []).includes(mode); })
            .sort(compareClimateHvacModes);
        return $ `
            <mushroom-button-group .fill=${this.fill} ?rtl=${rtl}>
                ${modes.map((mode) => this.renderModeButton(mode))}
            </mushroom-button-group>
        `;
    }
    renderModeButton(mode) {
        const iconStyle = {};
        const color = mode === "off" ? "var(--rgb-grey)" : getHvacModeColor(mode);
        if (mode === this.entity.state) {
            iconStyle["--icon-color"] = `rgb(${color})`;
            iconStyle["--bg-color"] = `rgba(${color}, 0.2)`;
        }
        return $ `
            <mushroom-button
                style=${i$2(iconStyle)}
                .icon=${getHvacModeIcon(mode)}
                .mode=${mode}
                .disabled=${!isAvailable(this.entity)}
                @click=${this.callService}
            ></mushroom-button>
        `;
    }
};
__decorate([
    e$3({ attribute: false })
], ClimateHvacModesControl.prototype, "hass", void 0);
__decorate([
    e$3({ attribute: false })
], ClimateHvacModesControl.prototype, "entity", void 0);
__decorate([
    e$3({ attribute: false })
], ClimateHvacModesControl.prototype, "modes", void 0);
__decorate([
    e$3()
], ClimateHvacModesControl.prototype, "fill", void 0);
ClimateHvacModesControl = __decorate([
    n$1("mushroom-climate-hvac-modes-control")
], ClimateHvacModesControl);

const DEFAULT_STEP = 1;
const DEFAULT_DEBOUCE_TIME = 2000;
const getInputNumberDebounceTime = (element) => {
    const debounceTimeValue = window
        .getComputedStyle(element)
        .getPropertyValue("--input-number-debounce");
    const debounceTime = parseFloat(debounceTimeValue);
    return isNaN(debounceTime) ? DEFAULT_DEBOUCE_TIME : debounceTime;
};
let InputNumber = class InputNumber extends s$1 {
    constructor() {
        super(...arguments);
        this.disabled = false;
        this.formatOptions = {};
        this.pending = false;
        this.dispatchValue = (value) => {
            this.pending = false;
            this.dispatchEvent(new CustomEvent("change", {
                detail: {
                    value,
                },
            }));
        };
        this.debounceDispatchValue = this.dispatchValue;
    }
    _incrementValue(e) {
        var _a;
        e.stopPropagation();
        if (!this.value)
            return;
        const value = round(this.value + ((_a = this.step) !== null && _a !== void 0 ? _a : DEFAULT_STEP), 1);
        this._processNewValue(value);
    }
    _decrementValue(e) {
        var _a;
        e.stopPropagation();
        if (!this.value)
            return;
        const value = round(this.value - ((_a = this.step) !== null && _a !== void 0 ? _a : DEFAULT_STEP), 1);
        this._processNewValue(value);
    }
    firstUpdated(changedProperties) {
        super.firstUpdated(changedProperties);
        const debounceTime = getInputNumberDebounceTime(this.container);
        if (debounceTime) {
            this.debounceDispatchValue = debounce(this.dispatchValue, debounceTime);
        }
    }
    _processNewValue(value) {
        const newValue = conditionalClamp(value, this.min, this.max);
        if (this.value !== newValue) {
            this.value = newValue;
            this.pending = true;
        }
        this.debounceDispatchValue(newValue);
    }
    render() {
        const value = this.value != null ? formatNumber(this.value, this.locale, this.formatOptions) : "-";
        return $ `
            <div class="container" id="container">
                <button class="button" @click=${this._decrementValue} .disabled=${this.disabled}>
                    <ha-icon icon="mdi:minus"></ha-icon>
                </button>
                <span
                    class=${o({
            pending: this.pending,
            disabled: this.disabled,
        })}
                >
                    ${value}
                </span>
                <button class="button" @click=${this._incrementValue} .disabled=${this.disabled}>
                    <ha-icon icon="mdi:plus"></ha-icon>
                </button>
            </div>
        `;
    }
    static get styles() {
        return r$3 `
            :host {
                --text-color: var(--primary-text-color);
                --text-color-disabled: rgb(var(--rgb-disabled));
                --icon-color: var(--primary-text-color);
                --icon-color-disabled: rgb(var(--rgb-disabled));
                --bg-color: rgba(var(--rgb-primary-text-color), 0.05);
                --bg-color-disabled: rgba(var(--rgb-disabled), 0.2);
                height: var(--control-height);
                width: calc(var(--control-height) * var(--control-button-ratio) * 3);
                flex: none;
            }
            .container {
                box-sizing: border-box;
                width: 100%;
                height: 100%;
                padding: 6px;
                display: flex;
                flex-direction: row;
                align-items: center;
                justify-content: space-between;
                border-radius: var(--control-border-radius);
                border: none;
                background-color: var(--bg-color);
                transition: background-color 280ms ease-in-out;
            }
            .button {
                display: flex;
                flex-direction: row;
                align-items: center;
                justify-content: center;
                padding: 6px;
                border: none;
                background: none;
                cursor: pointer;
                border-radius: var(--control-border-radius);
                line-height: 0;
            }
            .button:disabled {
                cursor: not-allowed;
            }
            .button ha-icon {
                font-size: var(--control-height);
                --mdc-icon-size: var(--control-icon-size);
                color: var(--icon-color);
                pointer-events: none;
            }
            .button:disabled ha-icon {
                color: var(--icon-color-disabled);
            }
            span {
                font-weight: bold;
                color: var(--text-color);
            }
            span.disabled {
                color: var(--text-color-disabled);
            }
            span.pending {
                opacity: 0.5;
            }
        `;
    }
};
__decorate([
    e$3({ attribute: false })
], InputNumber.prototype, "locale", void 0);
__decorate([
    e$3({ type: Boolean })
], InputNumber.prototype, "disabled", void 0);
__decorate([
    e$3({ attribute: false, type: Number, reflect: true })
], InputNumber.prototype, "value", void 0);
__decorate([
    e$3({ type: Number })
], InputNumber.prototype, "step", void 0);
__decorate([
    e$3({ type: Number })
], InputNumber.prototype, "min", void 0);
__decorate([
    e$3({ type: Number })
], InputNumber.prototype, "max", void 0);
__decorate([
    e$3({ attribute: "false" })
], InputNumber.prototype, "formatOptions", void 0);
__decorate([
    t$1()
], InputNumber.prototype, "pending", void 0);
__decorate([
    i$4("#container")
], InputNumber.prototype, "container", void 0);
InputNumber = __decorate([
    n$1("mushroom-input-number")
], InputNumber);

const isTemperatureControlVisible = (entity) => entity.attributes.temperature != null ||
    (entity.attributes.target_temp_low != null && entity.attributes.target_temp_high != null);
let ClimateTemperatureControl = class ClimateTemperatureControl extends s$1 {
    constructor() {
        super(...arguments);
        this.fill = false;
    }
    get _stepSize() {
        if (this.entity.attributes.target_temp_step) {
            return this.entity.attributes.target_temp_step;
        }
        return this.hass.config.unit_system.temperature === UNIT_F ? 1 : 0.5;
    }
    onValueChange(e) {
        const value = e.detail.value;
        this.hass.callService("climate", "set_temperature", {
            entity_id: this.entity.entity_id,
            temperature: value,
        });
    }
    onLowValueChange(e) {
        const value = e.detail.value;
        this.hass.callService("climate", "set_temperature", {
            entity_id: this.entity.entity_id,
            target_temp_low: value,
            target_temp_high: this.entity.attributes.target_temp_high,
        });
    }
    onHighValueChange(e) {
        const value = e.detail.value;
        this.hass.callService("climate", "set_temperature", {
            entity_id: this.entity.entity_id,
            target_temp_low: this.entity.attributes.target_temp_low,
            target_temp_high: value,
        });
    }
    render() {
        const rtl = computeRTL(this.hass);
        const available = isAvailable(this.entity);
        const formatOptions = this._stepSize === 1
            ? {
                maximumFractionDigits: 0,
            }
            : {
                minimumFractionDigits: 1,
                maximumFractionDigits: 1,
            };
        const modeStyle = (mode) => ({
            "--bg-color": `rgba(var(--rgb-state-climate-${mode}), 0.05)`,
            "--icon-color": `rgb(var(--rgb-state-climate-${mode}))`,
            "--text-color": `rgb(var(--rgb-state-climate-${mode}))`,
        });
        return $ `
            <mushroom-button-group .fill=${this.fill} ?rtl=${rtl}>
                ${this.entity.attributes.temperature != null
            ? $ `
                          <mushroom-input-number
                              .locale=${this.hass.locale}
                              .value=${this.entity.attributes.temperature}
                              .step=${this._stepSize}
                              .min=${this.entity.attributes.min_temp}
                              .max=${this.entity.attributes.max_temp}
                              .disabled=${!available}
                              .formatOptions=${formatOptions}
                              @change=${this.onValueChange}
                          ></mushroom-input-number>
                      `
            : null}
                ${this.entity.attributes.target_temp_low != null &&
            this.entity.attributes.target_temp_high != null
            ? $ `
                          <mushroom-input-number
                              style=${i$2(modeStyle("heat"))}
                              .locale=${this.hass.locale}
                              .value=${this.entity.attributes.target_temp_low}
                              .step=${this._stepSize}
                              .min=${this.entity.attributes.min_temp}
                              .max=${this.entity.attributes.max_temp}
                              .disabled=${!available}
                              .formatOptions=${formatOptions}
                              @change=${this.onLowValueChange}
                          ></mushroom-input-number
                          ><mushroom-input-number
                              style=${i$2(modeStyle("cool"))}
                              .locale=${this.hass.locale}
                              .value=${this.entity.attributes.target_temp_high}
                              .step=${this._stepSize}
                              .min=${this.entity.attributes.min_temp}
                              .max=${this.entity.attributes.max_temp}
                              .disabled=${!available}
                              .formatOptions=${formatOptions}
                              @change=${this.onHighValueChange}
                          ></mushroom-input-number>
                      `
            : null}
            </mushroom-button-group>
        `;
    }
};
__decorate([
    e$3({ attribute: false })
], ClimateTemperatureControl.prototype, "hass", void 0);
__decorate([
    e$3({ attribute: false })
], ClimateTemperatureControl.prototype, "entity", void 0);
__decorate([
    e$3()
], ClimateTemperatureControl.prototype, "fill", void 0);
ClimateTemperatureControl = __decorate([
    n$1("mushroom-climate-temperature-control")
], ClimateTemperatureControl);

const CONTROLS_ICONS$3 = {
    temperature_control: "mdi:thermometer",
    hvac_mode_control: "mdi:thermostat",
};
registerCustomCard({
    type: CLIMATE_CARD_NAME,
    name: "Mushroom Climate Card",
    description: "Card for climate entity",
});
let ClimateCard = class ClimateCard extends MushroomBaseCard {
    constructor() {
        super(...arguments);
        this._controls = [];
    }
    static async getConfigElement() {
        await Promise.resolve().then(function () { return climateCardEditor; });
        return document.createElement(CLIMATE_CARD_EDITOR_NAME);
    }
    static async getStubConfig(hass) {
        const entities = Object.keys(hass.states);
        const climates = entities.filter((e) => CLIMATE_ENTITY_DOMAINS.includes(e.split(".")[0]));
        return {
            type: `custom:${CLIMATE_CARD_NAME}`,
            entity: climates[0],
        };
    }
    _onControlTap(ctrl, e) {
        e.stopPropagation();
        this._activeControl = ctrl;
    }
    getCardSize() {
        return 1;
    }
    setConfig(config) {
        this._config = Object.assign({ tap_action: {
                action: "toggle",
            }, hold_action: {
                action: "more-info",
            } }, config);
        this.updateControls();
    }
    updated(changedProperties) {
        super.updated(changedProperties);
        if (this.hass && changedProperties.has("hass")) {
            this.updateControls();
        }
    }
    updateControls() {
        if (!this._config || !this.hass || !this._config.entity)
            return;
        const entity_id = this._config.entity;
        const entity = this.hass.states[entity_id];
        if (!entity)
            return;
        const controls = [];
        if (!this._config.collapsible_controls || isActive(entity)) {
            if (isTemperatureControlVisible(entity) && this._config.show_temperature_control) {
                controls.push("temperature_control");
            }
            if (isHvacModesVisible(entity, this._config.hvac_modes)) {
                controls.push("hvac_mode_control");
            }
        }
        this._controls = controls;
        const isActiveControlSupported = this._activeControl
            ? controls.includes(this._activeControl)
            : false;
        this._activeControl = isActiveControlSupported ? this._activeControl : controls[0];
    }
    _handleAction(ev) {
        handleAction(this, this.hass, this._config, ev.detail.action);
    }
    render() {
        if (!this.hass || !this._config || !this._config.entity) {
            return $ ``;
        }
        const entity_id = this._config.entity;
        const entity = this.hass.states[entity_id];
        const name = this._config.name || entity.attributes.friendly_name || "";
        const icon = this._config.icon || stateIcon(entity);
        const appearance = computeAppearance(this._config);
        const picture = computeEntityPicture(entity, appearance.icon_type);
        let stateDisplay = computeStateDisplay(this.hass.localize, entity, this.hass.locale, this.hass.entities);
        if (entity.attributes.current_temperature !== null) {
            const temperature = formatNumber(entity.attributes.current_temperature, this.hass.locale);
            const unit = this.hass.config.unit_system.temperature;
            stateDisplay += ` - ${temperature} ${unit}`;
        }
        const rtl = computeRTL(this.hass);
        return $ `
            <ha-card class=${o({ "fill-container": appearance.fill_container })}>
                <mushroom-card .appearance=${appearance} ?rtl=${rtl}>
                    <mushroom-state-item
                        ?rtl=${rtl}
                        .appearance=${appearance}
                        @action=${this._handleAction}
                        .actionHandler=${actionHandler({
            hasHold: hasAction(this._config.hold_action),
            hasDoubleClick: hasAction(this._config.double_tap_action),
        })}
                    >
                        ${picture ? this.renderPicture(picture) : this.renderIcon(entity, icon)}
                        ${this.renderBadge(entity)}
                        ${this.renderStateInfo(entity, appearance, name, stateDisplay)};
                    </mushroom-state-item>
                    ${this._controls.length > 0
            ? $ `
                              <div class="actions" ?rtl=${rtl}>
                                  ${this.renderActiveControl(entity)}${this.renderOtherControls()}
                              </div>
                          `
            : null}
                </mushroom-card>
            </ha-card>
        `;
    }
    renderIcon(entity, icon) {
        const available = isAvailable(entity);
        const color = getHvacModeColor(entity.state);
        const iconStyle = {};
        iconStyle["--icon-color"] = `rgb(${color})`;
        iconStyle["--shape-color"] = `rgba(${color}, 0.2)`;
        return $ `
            <mushroom-shape-icon
                slot="icon"
                .disabled=${!available}
                .icon=${icon}
                style=${i$2(iconStyle)}
            ></mushroom-shape-icon>
        `;
    }
    renderBadge(entity) {
        const unavailable = !isAvailable(entity);
        if (unavailable) {
            return super.renderBadge(entity);
        }
        else {
            return this.renderActionBadge(entity);
        }
    }
    renderActionBadge(entity) {
        const hvac_action = entity.attributes.hvac_action;
        if (!hvac_action || hvac_action == "off")
            return null;
        const color = getHvacActionColor(hvac_action);
        const icon = getHvacActionIcon(hvac_action);
        if (!icon)
            return null;
        return $ `
            <mushroom-badge-icon
                slot="badge"
                .icon=${icon}
                style=${i$2({
            "--main-color": `rgb(${color})`,
        })}
            ></mushroom-badge-icon>
        `;
    }
    renderOtherControls() {
        const otherControls = this._controls.filter((control) => control != this._activeControl);
        return $ `
            ${otherControls.map((ctrl) => $ `
                    <mushroom-button
                        .icon=${CONTROLS_ICONS$3[ctrl]}
                        @click=${(e) => this._onControlTap(ctrl, e)}
                    ></mushroom-button>
                `)}
        `;
    }
    renderActiveControl(entity) {
        var _a, _b;
        const hvac_modes = (_b = (_a = this._config) === null || _a === void 0 ? void 0 : _a.hvac_modes) !== null && _b !== void 0 ? _b : [];
        switch (this._activeControl) {
            case "temperature_control":
                return $ `
                    <mushroom-climate-temperature-control
                        .hass=${this.hass}
                        .entity=${entity}
                        .fill=${true}
                    ></mushroom-climate-temperature-control>
                `;
            case "hvac_mode_control":
                return $ `
                    <mushroom-climate-hvac-modes-control
                        .hass=${this.hass}
                        .entity=${entity}
                        .modes=${hvac_modes}
                        .fill=${true}
                    ></mushroom-climate-hvac-modes-control>
                `;
            default:
                return null;
        }
    }
    static get styles() {
        return [
            super.styles,
            cardStyle,
            r$3 `
                mushroom-state-item {
                    cursor: pointer;
                }
                mushroom-climate-temperature-control,
                mushroom-climate-hvac-modes-control {
                    flex: 1;
                }
            `,
        ];
    }
};
__decorate([
    t$1()
], ClimateCard.prototype, "_config", void 0);
__decorate([
    t$1()
], ClimateCard.prototype, "_activeControl", void 0);
__decorate([
    t$1()
], ClimateCard.prototype, "_controls", void 0);
ClimateCard = __decorate([
    n$1(CLIMATE_CARD_NAME)
], ClimateCard);

const COVER_CARD_NAME = `${PREFIX_NAME}-cover-card`;
const COVER_CARD_EDITOR_NAME = `${COVER_CARD_NAME}-editor`;
const COVER_ENTITY_DOMAINS = ["cover"];

let CoverButtonsControl$1 = class CoverButtonsControl extends s$1 {
    constructor() {
        super(...arguments);
        this.fill = false;
    }
    _onOpenTap(e) {
        e.stopPropagation();
        this.hass.callService("cover", "open_cover", {
            entity_id: this.entity.entity_id,
        });
    }
    _onCloseTap(e) {
        e.stopPropagation();
        this.hass.callService("cover", "close_cover", {
            entity_id: this.entity.entity_id,
        });
    }
    _onStopTap(e) {
        e.stopPropagation();
        this.hass.callService("cover", "stop_cover", {
            entity_id: this.entity.entity_id,
        });
    }
    get openDisabled() {
        const assumedState = this.entity.attributes.assumed_state === true;
        return (isFullyOpen(this.entity) || isOpening(this.entity)) && !assumedState;
    }
    get closedDisabled() {
        const assumedState = this.entity.attributes.assumed_state === true;
        return (isFullyClosed(this.entity) || isClosing(this.entity)) && !assumedState;
    }
    render() {
        const rtl = computeRTL(this.hass);
        return $ `
            <mushroom-button-group .fill=${this.fill} ?rtl=${rtl}>
                ${supportsFeature(this.entity, COVER_SUPPORT_CLOSE)
            ? $ `
                          <mushroom-button
                              .icon=${computeCloseIcon(this.entity)}
                              .disabled=${!isAvailable(this.entity) || this.closedDisabled}
                              @click=${this._onCloseTap}
                          ></mushroom-button>
                      `
            : undefined}
                ${supportsFeature(this.entity, COVER_SUPPORT_STOP)
            ? $ `
                          <mushroom-button
                              icon="mdi:pause"
                              .disabled=${!isAvailable(this.entity)}
                              @click=${this._onStopTap}
                          ></mushroom-button>
                      `
            : undefined}
                ${supportsFeature(this.entity, COVER_SUPPORT_OPEN)
            ? $ `
                          <mushroom-button
                              .icon=${computeOpenIcon(this.entity)}
                              .disabled=${!isAvailable(this.entity) || this.openDisabled}
                              @click=${this._onOpenTap}
                          ></mushroom-button>
                      `
            : undefined}
            </mushroom-button-group>
        `;
    }
};
__decorate([
    e$3({ attribute: false })
], CoverButtonsControl$1.prototype, "hass", void 0);
__decorate([
    e$3({ attribute: false })
], CoverButtonsControl$1.prototype, "entity", void 0);
__decorate([
    e$3()
], CoverButtonsControl$1.prototype, "fill", void 0);
CoverButtonsControl$1 = __decorate([
    n$1("mushroom-cover-buttons-control")
], CoverButtonsControl$1);

var hammer = {exports: {}};

/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */

(function (module) {
	(function(window, document, exportName, undefined$1) {

	var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
	var TEST_ELEMENT = document.createElement('div');

	var TYPE_FUNCTION = 'function';

	var round = Math.round;
	var abs = Math.abs;
	var now = Date.now;

	/**
	 * set a timeout with a given scope
	 * @param {Function} fn
	 * @param {Number} timeout
	 * @param {Object} context
	 * @returns {number}
	 */
	function setTimeoutContext(fn, timeout, context) {
	    return setTimeout(bindFn(fn, context), timeout);
	}

	/**
	 * if the argument is an array, we want to execute the fn on each entry
	 * if it aint an array we don't want to do a thing.
	 * this is used by all the methods that accept a single and array argument.
	 * @param {*|Array} arg
	 * @param {String} fn
	 * @param {Object} [context]
	 * @returns {Boolean}
	 */
	function invokeArrayArg(arg, fn, context) {
	    if (Array.isArray(arg)) {
	        each(arg, context[fn], context);
	        return true;
	    }
	    return false;
	}

	/**
	 * walk objects and arrays
	 * @param {Object} obj
	 * @param {Function} iterator
	 * @param {Object} context
	 */
	function each(obj, iterator, context) {
	    var i;

	    if (!obj) {
	        return;
	    }

	    if (obj.forEach) {
	        obj.forEach(iterator, context);
	    } else if (obj.length !== undefined$1) {
	        i = 0;
	        while (i < obj.length) {
	            iterator.call(context, obj[i], i, obj);
	            i++;
	        }
	    } else {
	        for (i in obj) {
	            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
	        }
	    }
	}

	/**
	 * wrap a method with a deprecation warning and stack trace
	 * @param {Function} method
	 * @param {String} name
	 * @param {String} message
	 * @returns {Function} A new function wrapping the supplied method.
	 */
	function deprecate(method, name, message) {
	    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
	    return function() {
	        var e = new Error('get-stack-trace');
	        var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '')
	            .replace(/^\s+at\s+/gm, '')
	            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';

	        var log = window.console && (window.console.warn || window.console.log);
	        if (log) {
	            log.call(window.console, deprecationMessage, stack);
	        }
	        return method.apply(this, arguments);
	    };
	}

	/**
	 * extend object.
	 * means that properties in dest will be overwritten by the ones in src.
	 * @param {Object} target
	 * @param {...Object} objects_to_assign
	 * @returns {Object} target
	 */
	var assign;
	if (typeof Object.assign !== 'function') {
	    assign = function assign(target) {
	        if (target === undefined$1 || target === null) {
	            throw new TypeError('Cannot convert undefined or null to object');
	        }

	        var output = Object(target);
	        for (var index = 1; index < arguments.length; index++) {
	            var source = arguments[index];
	            if (source !== undefined$1 && source !== null) {
	                for (var nextKey in source) {
	                    if (source.hasOwnProperty(nextKey)) {
	                        output[nextKey] = source[nextKey];
	                    }
	                }
	            }
	        }
	        return output;
	    };
	} else {
	    assign = Object.assign;
	}

	/**
	 * extend object.
	 * means that properties in dest will be overwritten by the ones in src.
	 * @param {Object} dest
	 * @param {Object} src
	 * @param {Boolean} [merge=false]
	 * @returns {Object} dest
	 */
	var extend = deprecate(function extend(dest, src, merge) {
	    var keys = Object.keys(src);
	    var i = 0;
	    while (i < keys.length) {
	        if (!merge || (merge && dest[keys[i]] === undefined$1)) {
	            dest[keys[i]] = src[keys[i]];
	        }
	        i++;
	    }
	    return dest;
	}, 'extend', 'Use `assign`.');

	/**
	 * merge the values from src in the dest.
	 * means that properties that exist in dest will not be overwritten by src
	 * @param {Object} dest
	 * @param {Object} src
	 * @returns {Object} dest
	 */
	var merge = deprecate(function merge(dest, src) {
	    return extend(dest, src, true);
	}, 'merge', 'Use `assign`.');

	/**
	 * simple class inheritance
	 * @param {Function} child
	 * @param {Function} base
	 * @param {Object} [properties]
	 */
	function inherit(child, base, properties) {
	    var baseP = base.prototype,
	        childP;

	    childP = child.prototype = Object.create(baseP);
	    childP.constructor = child;
	    childP._super = baseP;

	    if (properties) {
	        assign(childP, properties);
	    }
	}

	/**
	 * simple function bind
	 * @param {Function} fn
	 * @param {Object} context
	 * @returns {Function}
	 */
	function bindFn(fn, context) {
	    return function boundFn() {
	        return fn.apply(context, arguments);
	    };
	}

	/**
	 * let a boolean value also be a function that must return a boolean
	 * this first item in args will be used as the context
	 * @param {Boolean|Function} val
	 * @param {Array} [args]
	 * @returns {Boolean}
	 */
	function boolOrFn(val, args) {
	    if (typeof val == TYPE_FUNCTION) {
	        return val.apply(args ? args[0] || undefined$1 : undefined$1, args);
	    }
	    return val;
	}

	/**
	 * use the val2 when val1 is undefined
	 * @param {*} val1
	 * @param {*} val2
	 * @returns {*}
	 */
	function ifUndefined(val1, val2) {
	    return (val1 === undefined$1) ? val2 : val1;
	}

	/**
	 * addEventListener with multiple events at once
	 * @param {EventTarget} target
	 * @param {String} types
	 * @param {Function} handler
	 */
	function addEventListeners(target, types, handler) {
	    each(splitStr(types), function(type) {
	        target.addEventListener(type, handler, false);
	    });
	}

	/**
	 * removeEventListener with multiple events at once
	 * @param {EventTarget} target
	 * @param {String} types
	 * @param {Function} handler
	 */
	function removeEventListeners(target, types, handler) {
	    each(splitStr(types), function(type) {
	        target.removeEventListener(type, handler, false);
	    });
	}

	/**
	 * find if a node is in the given parent
	 * @method hasParent
	 * @param {HTMLElement} node
	 * @param {HTMLElement} parent
	 * @return {Boolean} found
	 */
	function hasParent(node, parent) {
	    while (node) {
	        if (node == parent) {
	            return true;
	        }
	        node = node.parentNode;
	    }
	    return false;
	}

	/**
	 * small indexOf wrapper
	 * @param {String} str
	 * @param {String} find
	 * @returns {Boolean} found
	 */
	function inStr(str, find) {
	    return str.indexOf(find) > -1;
	}

	/**
	 * split string on whitespace
	 * @param {String} str
	 * @returns {Array} words
	 */
	function splitStr(str) {
	    return str.trim().split(/\s+/g);
	}

	/**
	 * find if a array contains the object using indexOf or a simple polyFill
	 * @param {Array} src
	 * @param {String} find
	 * @param {String} [findByKey]
	 * @return {Boolean|Number} false when not found, or the index
	 */
	function inArray(src, find, findByKey) {
	    if (src.indexOf && !findByKey) {
	        return src.indexOf(find);
	    } else {
	        var i = 0;
	        while (i < src.length) {
	            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
	                return i;
	            }
	            i++;
	        }
	        return -1;
	    }
	}

	/**
	 * convert array-like objects to real arrays
	 * @param {Object} obj
	 * @returns {Array}
	 */
	function toArray(obj) {
	    return Array.prototype.slice.call(obj, 0);
	}

	/**
	 * unique array with objects based on a key (like 'id') or just by the array's value
	 * @param {Array} src [{id:1},{id:2},{id:1}]
	 * @param {String} [key]
	 * @param {Boolean} [sort=False]
	 * @returns {Array} [{id:1},{id:2}]
	 */
	function uniqueArray(src, key, sort) {
	    var results = [];
	    var values = [];
	    var i = 0;

	    while (i < src.length) {
	        var val = key ? src[i][key] : src[i];
	        if (inArray(values, val) < 0) {
	            results.push(src[i]);
	        }
	        values[i] = val;
	        i++;
	    }

	    if (sort) {
	        if (!key) {
	            results = results.sort();
	        } else {
	            results = results.sort(function sortUniqueArray(a, b) {
	                return a[key] > b[key];
	            });
	        }
	    }

	    return results;
	}

	/**
	 * get the prefixed property
	 * @param {Object} obj
	 * @param {String} property
	 * @returns {String|Undefined} prefixed
	 */
	function prefixed(obj, property) {
	    var prefix, prop;
	    var camelProp = property[0].toUpperCase() + property.slice(1);

	    var i = 0;
	    while (i < VENDOR_PREFIXES.length) {
	        prefix = VENDOR_PREFIXES[i];
	        prop = (prefix) ? prefix + camelProp : property;

	        if (prop in obj) {
	            return prop;
	        }
	        i++;
	    }
	    return undefined$1;
	}

	/**
	 * get a unique id
	 * @returns {number} uniqueId
	 */
	var _uniqueId = 1;
	function uniqueId() {
	    return _uniqueId++;
	}

	/**
	 * get the window object of an element
	 * @param {HTMLElement} element
	 * @returns {DocumentView|Window}
	 */
	function getWindowForElement(element) {
	    var doc = element.ownerDocument || element;
	    return (doc.defaultView || doc.parentWindow || window);
	}

	var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

	var SUPPORT_TOUCH = ('ontouchstart' in window);
	var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined$1;
	var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

	var INPUT_TYPE_TOUCH = 'touch';
	var INPUT_TYPE_PEN = 'pen';
	var INPUT_TYPE_MOUSE = 'mouse';
	var INPUT_TYPE_KINECT = 'kinect';

	var COMPUTE_INTERVAL = 25;

	var INPUT_START = 1;
	var INPUT_MOVE = 2;
	var INPUT_END = 4;
	var INPUT_CANCEL = 8;

	var DIRECTION_NONE = 1;
	var DIRECTION_LEFT = 2;
	var DIRECTION_RIGHT = 4;
	var DIRECTION_UP = 8;
	var DIRECTION_DOWN = 16;

	var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
	var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
	var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

	var PROPS_XY = ['x', 'y'];
	var PROPS_CLIENT_XY = ['clientX', 'clientY'];

	/**
	 * create new input type manager
	 * @param {Manager} manager
	 * @param {Function} callback
	 * @returns {Input}
	 * @constructor
	 */
	function Input(manager, callback) {
	    var self = this;
	    this.manager = manager;
	    this.callback = callback;
	    this.element = manager.element;
	    this.target = manager.options.inputTarget;

	    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
	    // so when disabled the input events are completely bypassed.
	    this.domHandler = function(ev) {
	        if (boolOrFn(manager.options.enable, [manager])) {
	            self.handler(ev);
	        }
	    };

	    this.init();

	}

	Input.prototype = {
	    /**
	     * should handle the inputEvent data and trigger the callback
	     * @virtual
	     */
	    handler: function() { },

	    /**
	     * bind the events
	     */
	    init: function() {
	        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
	        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
	        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
	    },

	    /**
	     * unbind the events
	     */
	    destroy: function() {
	        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
	        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
	        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
	    }
	};

	/**
	 * create new input type manager
	 * called by the Manager constructor
	 * @param {Hammer} manager
	 * @returns {Input}
	 */
	function createInputInstance(manager) {
	    var Type;
	    var inputClass = manager.options.inputClass;

	    if (inputClass) {
	        Type = inputClass;
	    } else if (SUPPORT_POINTER_EVENTS) {
	        Type = PointerEventInput;
	    } else if (SUPPORT_ONLY_TOUCH) {
	        Type = TouchInput;
	    } else if (!SUPPORT_TOUCH) {
	        Type = MouseInput;
	    } else {
	        Type = TouchMouseInput;
	    }
	    return new (Type)(manager, inputHandler);
	}

	/**
	 * handle input events
	 * @param {Manager} manager
	 * @param {String} eventType
	 * @param {Object} input
	 */
	function inputHandler(manager, eventType, input) {
	    var pointersLen = input.pointers.length;
	    var changedPointersLen = input.changedPointers.length;
	    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
	    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

	    input.isFirst = !!isFirst;
	    input.isFinal = !!isFinal;

	    if (isFirst) {
	        manager.session = {};
	    }

	    // source event is the normalized value of the domEvents
	    // like 'touchstart, mouseup, pointerdown'
	    input.eventType = eventType;

	    // compute scale, rotation etc
	    computeInputData(manager, input);

	    // emit secret event
	    manager.emit('hammer.input', input);

	    manager.recognize(input);
	    manager.session.prevInput = input;
	}

	/**
	 * extend the data with some usable properties like scale, rotate, velocity etc
	 * @param {Object} manager
	 * @param {Object} input
	 */
	function computeInputData(manager, input) {
	    var session = manager.session;
	    var pointers = input.pointers;
	    var pointersLength = pointers.length;

	    // store the first input to calculate the distance and direction
	    if (!session.firstInput) {
	        session.firstInput = simpleCloneInputData(input);
	    }

	    // to compute scale and rotation we need to store the multiple touches
	    if (pointersLength > 1 && !session.firstMultiple) {
	        session.firstMultiple = simpleCloneInputData(input);
	    } else if (pointersLength === 1) {
	        session.firstMultiple = false;
	    }

	    var firstInput = session.firstInput;
	    var firstMultiple = session.firstMultiple;
	    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

	    var center = input.center = getCenter(pointers);
	    input.timeStamp = now();
	    input.deltaTime = input.timeStamp - firstInput.timeStamp;

	    input.angle = getAngle(offsetCenter, center);
	    input.distance = getDistance(offsetCenter, center);

	    computeDeltaXY(session, input);
	    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

	    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
	    input.overallVelocityX = overallVelocity.x;
	    input.overallVelocityY = overallVelocity.y;
	    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;

	    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
	    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

	    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >
	        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);

	    computeIntervalInputData(session, input);

	    // find the correct target
	    var target = manager.element;
	    if (hasParent(input.srcEvent.target, target)) {
	        target = input.srcEvent.target;
	    }
	    input.target = target;
	}

	function computeDeltaXY(session, input) {
	    var center = input.center;
	    var offset = session.offsetDelta || {};
	    var prevDelta = session.prevDelta || {};
	    var prevInput = session.prevInput || {};

	    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
	        prevDelta = session.prevDelta = {
	            x: prevInput.deltaX || 0,
	            y: prevInput.deltaY || 0
	        };

	        offset = session.offsetDelta = {
	            x: center.x,
	            y: center.y
	        };
	    }

	    input.deltaX = prevDelta.x + (center.x - offset.x);
	    input.deltaY = prevDelta.y + (center.y - offset.y);
	}

	/**
	 * velocity is calculated every x ms
	 * @param {Object} session
	 * @param {Object} input
	 */
	function computeIntervalInputData(session, input) {
	    var last = session.lastInterval || input,
	        deltaTime = input.timeStamp - last.timeStamp,
	        velocity, velocityX, velocityY, direction;

	    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined$1)) {
	        var deltaX = input.deltaX - last.deltaX;
	        var deltaY = input.deltaY - last.deltaY;

	        var v = getVelocity(deltaTime, deltaX, deltaY);
	        velocityX = v.x;
	        velocityY = v.y;
	        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
	        direction = getDirection(deltaX, deltaY);

	        session.lastInterval = input;
	    } else {
	        // use latest velocity info if it doesn't overtake a minimum period
	        velocity = last.velocity;
	        velocityX = last.velocityX;
	        velocityY = last.velocityY;
	        direction = last.direction;
	    }

	    input.velocity = velocity;
	    input.velocityX = velocityX;
	    input.velocityY = velocityY;
	    input.direction = direction;
	}

	/**
	 * create a simple clone from the input used for storage of firstInput and firstMultiple
	 * @param {Object} input
	 * @returns {Object} clonedInputData
	 */
	function simpleCloneInputData(input) {
	    // make a simple copy of the pointers because we will get a reference if we don't
	    // we only need clientXY for the calculations
	    var pointers = [];
	    var i = 0;
	    while (i < input.pointers.length) {
	        pointers[i] = {
	            clientX: round(input.pointers[i].clientX),
	            clientY: round(input.pointers[i].clientY)
	        };
	        i++;
	    }

	    return {
	        timeStamp: now(),
	        pointers: pointers,
	        center: getCenter(pointers),
	        deltaX: input.deltaX,
	        deltaY: input.deltaY
	    };
	}

	/**
	 * get the center of all the pointers
	 * @param {Array} pointers
	 * @return {Object} center contains `x` and `y` properties
	 */
	function getCenter(pointers) {
	    var pointersLength = pointers.length;

	    // no need to loop when only one touch
	    if (pointersLength === 1) {
	        return {
	            x: round(pointers[0].clientX),
	            y: round(pointers[0].clientY)
	        };
	    }

	    var x = 0, y = 0, i = 0;
	    while (i < pointersLength) {
	        x += pointers[i].clientX;
	        y += pointers[i].clientY;
	        i++;
	    }

	    return {
	        x: round(x / pointersLength),
	        y: round(y / pointersLength)
	    };
	}

	/**
	 * calculate the velocity between two points. unit is in px per ms.
	 * @param {Number} deltaTime
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Object} velocity `x` and `y`
	 */
	function getVelocity(deltaTime, x, y) {
	    return {
	        x: x / deltaTime || 0,
	        y: y / deltaTime || 0
	    };
	}

	/**
	 * get the direction between two points
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Number} direction
	 */
	function getDirection(x, y) {
	    if (x === y) {
	        return DIRECTION_NONE;
	    }

	    if (abs(x) >= abs(y)) {
	        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
	    }
	    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
	}

	/**
	 * calculate the absolute distance between two points
	 * @param {Object} p1 {x, y}
	 * @param {Object} p2 {x, y}
	 * @param {Array} [props] containing x and y keys
	 * @return {Number} distance
	 */
	function getDistance(p1, p2, props) {
	    if (!props) {
	        props = PROPS_XY;
	    }
	    var x = p2[props[0]] - p1[props[0]],
	        y = p2[props[1]] - p1[props[1]];

	    return Math.sqrt((x * x) + (y * y));
	}

	/**
	 * calculate the angle between two coordinates
	 * @param {Object} p1
	 * @param {Object} p2
	 * @param {Array} [props] containing x and y keys
	 * @return {Number} angle
	 */
	function getAngle(p1, p2, props) {
	    if (!props) {
	        props = PROPS_XY;
	    }
	    var x = p2[props[0]] - p1[props[0]],
	        y = p2[props[1]] - p1[props[1]];
	    return Math.atan2(y, x) * 180 / Math.PI;
	}

	/**
	 * calculate the rotation degrees between two pointersets
	 * @param {Array} start array of pointers
	 * @param {Array} end array of pointers
	 * @return {Number} rotation
	 */
	function getRotation(start, end) {
	    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
	}

	/**
	 * calculate the scale factor between two pointersets
	 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
	 * @param {Array} start array of pointers
	 * @param {Array} end array of pointers
	 * @return {Number} scale
	 */
	function getScale(start, end) {
	    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
	}

	var MOUSE_INPUT_MAP = {
	    mousedown: INPUT_START,
	    mousemove: INPUT_MOVE,
	    mouseup: INPUT_END
	};

	var MOUSE_ELEMENT_EVENTS = 'mousedown';
	var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

	/**
	 * Mouse events input
	 * @constructor
	 * @extends Input
	 */
	function MouseInput() {
	    this.evEl = MOUSE_ELEMENT_EVENTS;
	    this.evWin = MOUSE_WINDOW_EVENTS;

	    this.pressed = false; // mousedown state

	    Input.apply(this, arguments);
	}

	inherit(MouseInput, Input, {
	    /**
	     * handle mouse events
	     * @param {Object} ev
	     */
	    handler: function MEhandler(ev) {
	        var eventType = MOUSE_INPUT_MAP[ev.type];

	        // on start we want to have the left mouse button down
	        if (eventType & INPUT_START && ev.button === 0) {
	            this.pressed = true;
	        }

	        if (eventType & INPUT_MOVE && ev.which !== 1) {
	            eventType = INPUT_END;
	        }

	        // mouse must be down
	        if (!this.pressed) {
	            return;
	        }

	        if (eventType & INPUT_END) {
	            this.pressed = false;
	        }

	        this.callback(this.manager, eventType, {
	            pointers: [ev],
	            changedPointers: [ev],
	            pointerType: INPUT_TYPE_MOUSE,
	            srcEvent: ev
	        });
	    }
	});

	var POINTER_INPUT_MAP = {
	    pointerdown: INPUT_START,
	    pointermove: INPUT_MOVE,
	    pointerup: INPUT_END,
	    pointercancel: INPUT_CANCEL,
	    pointerout: INPUT_CANCEL
	};

	// in IE10 the pointer types is defined as an enum
	var IE10_POINTER_TYPE_ENUM = {
	    2: INPUT_TYPE_TOUCH,
	    3: INPUT_TYPE_PEN,
	    4: INPUT_TYPE_MOUSE,
	    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
	};

	var POINTER_ELEMENT_EVENTS = 'pointerdown';
	var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

	// IE10 has prefixed support, and case-sensitive
	if (window.MSPointerEvent && !window.PointerEvent) {
	    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
	    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
	}

	/**
	 * Pointer events input
	 * @constructor
	 * @extends Input
	 */
	function PointerEventInput() {
	    this.evEl = POINTER_ELEMENT_EVENTS;
	    this.evWin = POINTER_WINDOW_EVENTS;

	    Input.apply(this, arguments);

	    this.store = (this.manager.session.pointerEvents = []);
	}

	inherit(PointerEventInput, Input, {
	    /**
	     * handle mouse events
	     * @param {Object} ev
	     */
	    handler: function PEhandler(ev) {
	        var store = this.store;
	        var removePointer = false;

	        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
	        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
	        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

	        var isTouch = (pointerType == INPUT_TYPE_TOUCH);

	        // get index of the event in the store
	        var storeIndex = inArray(store, ev.pointerId, 'pointerId');

	        // start and mouse must be down
	        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
	            if (storeIndex < 0) {
	                store.push(ev);
	                storeIndex = store.length - 1;
	            }
	        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
	            removePointer = true;
	        }

	        // it not found, so the pointer hasn't been down (so it's probably a hover)
	        if (storeIndex < 0) {
	            return;
	        }

	        // update the event in the store
	        store[storeIndex] = ev;

	        this.callback(this.manager, eventType, {
	            pointers: store,
	            changedPointers: [ev],
	            pointerType: pointerType,
	            srcEvent: ev
	        });

	        if (removePointer) {
	            // remove from the store
	            store.splice(storeIndex, 1);
	        }
	    }
	});

	var SINGLE_TOUCH_INPUT_MAP = {
	    touchstart: INPUT_START,
	    touchmove: INPUT_MOVE,
	    touchend: INPUT_END,
	    touchcancel: INPUT_CANCEL
	};

	var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
	var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

	/**
	 * Touch events input
	 * @constructor
	 * @extends Input
	 */
	function SingleTouchInput() {
	    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
	    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
	    this.started = false;

	    Input.apply(this, arguments);
	}

	inherit(SingleTouchInput, Input, {
	    handler: function TEhandler(ev) {
	        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

	        // should we handle the touch events?
	        if (type === INPUT_START) {
	            this.started = true;
	        }

	        if (!this.started) {
	            return;
	        }

	        var touches = normalizeSingleTouches.call(this, ev, type);

	        // when done, reset the started state
	        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
	            this.started = false;
	        }

	        this.callback(this.manager, type, {
	            pointers: touches[0],
	            changedPointers: touches[1],
	            pointerType: INPUT_TYPE_TOUCH,
	            srcEvent: ev
	        });
	    }
	});

	/**
	 * @this {TouchInput}
	 * @param {Object} ev
	 * @param {Number} type flag
	 * @returns {undefined|Array} [all, changed]
	 */
	function normalizeSingleTouches(ev, type) {
	    var all = toArray(ev.touches);
	    var changed = toArray(ev.changedTouches);

	    if (type & (INPUT_END | INPUT_CANCEL)) {
	        all = uniqueArray(all.concat(changed), 'identifier', true);
	    }

	    return [all, changed];
	}

	var TOUCH_INPUT_MAP = {
	    touchstart: INPUT_START,
	    touchmove: INPUT_MOVE,
	    touchend: INPUT_END,
	    touchcancel: INPUT_CANCEL
	};

	var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

	/**
	 * Multi-user touch events input
	 * @constructor
	 * @extends Input
	 */
	function TouchInput() {
	    this.evTarget = TOUCH_TARGET_EVENTS;
	    this.targetIds = {};

	    Input.apply(this, arguments);
	}

	inherit(TouchInput, Input, {
	    handler: function MTEhandler(ev) {
	        var type = TOUCH_INPUT_MAP[ev.type];
	        var touches = getTouches.call(this, ev, type);
	        if (!touches) {
	            return;
	        }

	        this.callback(this.manager, type, {
	            pointers: touches[0],
	            changedPointers: touches[1],
	            pointerType: INPUT_TYPE_TOUCH,
	            srcEvent: ev
	        });
	    }
	});

	/**
	 * @this {TouchInput}
	 * @param {Object} ev
	 * @param {Number} type flag
	 * @returns {undefined|Array} [all, changed]
	 */
	function getTouches(ev, type) {
	    var allTouches = toArray(ev.touches);
	    var targetIds = this.targetIds;

	    // when there is only one touch, the process can be simplified
	    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
	        targetIds[allTouches[0].identifier] = true;
	        return [allTouches, allTouches];
	    }

	    var i,
	        targetTouches,
	        changedTouches = toArray(ev.changedTouches),
	        changedTargetTouches = [],
	        target = this.target;

	    // get target touches from touches
	    targetTouches = allTouches.filter(function(touch) {
	        return hasParent(touch.target, target);
	    });

	    // collect touches
	    if (type === INPUT_START) {
	        i = 0;
	        while (i < targetTouches.length) {
	            targetIds[targetTouches[i].identifier] = true;
	            i++;
	        }
	    }

	    // filter changed touches to only contain touches that exist in the collected target ids
	    i = 0;
	    while (i < changedTouches.length) {
	        if (targetIds[changedTouches[i].identifier]) {
	            changedTargetTouches.push(changedTouches[i]);
	        }

	        // cleanup removed touches
	        if (type & (INPUT_END | INPUT_CANCEL)) {
	            delete targetIds[changedTouches[i].identifier];
	        }
	        i++;
	    }

	    if (!changedTargetTouches.length) {
	        return;
	    }

	    return [
	        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
	        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
	        changedTargetTouches
	    ];
	}

	/**
	 * Combined touch and mouse input
	 *
	 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
	 * This because touch devices also emit mouse events while doing a touch.
	 *
	 * @constructor
	 * @extends Input
	 */

	var DEDUP_TIMEOUT = 2500;
	var DEDUP_DISTANCE = 25;

	function TouchMouseInput() {
	    Input.apply(this, arguments);

	    var handler = bindFn(this.handler, this);
	    this.touch = new TouchInput(this.manager, handler);
	    this.mouse = new MouseInput(this.manager, handler);

	    this.primaryTouch = null;
	    this.lastTouches = [];
	}

	inherit(TouchMouseInput, Input, {
	    /**
	     * handle mouse and touch events
	     * @param {Hammer} manager
	     * @param {String} inputEvent
	     * @param {Object} inputData
	     */
	    handler: function TMEhandler(manager, inputEvent, inputData) {
	        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
	            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

	        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
	            return;
	        }

	        // when we're in a touch event, record touches to  de-dupe synthetic mouse event
	        if (isTouch) {
	            recordTouches.call(this, inputEvent, inputData);
	        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
	            return;
	        }

	        this.callback(manager, inputEvent, inputData);
	    },

	    /**
	     * remove the event listeners
	     */
	    destroy: function destroy() {
	        this.touch.destroy();
	        this.mouse.destroy();
	    }
	});

	function recordTouches(eventType, eventData) {
	    if (eventType & INPUT_START) {
	        this.primaryTouch = eventData.changedPointers[0].identifier;
	        setLastTouch.call(this, eventData);
	    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
	        setLastTouch.call(this, eventData);
	    }
	}

	function setLastTouch(eventData) {
	    var touch = eventData.changedPointers[0];

	    if (touch.identifier === this.primaryTouch) {
	        var lastTouch = {x: touch.clientX, y: touch.clientY};
	        this.lastTouches.push(lastTouch);
	        var lts = this.lastTouches;
	        var removeLastTouch = function() {
	            var i = lts.indexOf(lastTouch);
	            if (i > -1) {
	                lts.splice(i, 1);
	            }
	        };
	        setTimeout(removeLastTouch, DEDUP_TIMEOUT);
	    }
	}

	function isSyntheticEvent(eventData) {
	    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
	    for (var i = 0; i < this.lastTouches.length; i++) {
	        var t = this.lastTouches[i];
	        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
	        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
	            return true;
	        }
	    }
	    return false;
	}

	var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
	var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined$1;

	// magical touchAction value
	var TOUCH_ACTION_COMPUTE = 'compute';
	var TOUCH_ACTION_AUTO = 'auto';
	var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
	var TOUCH_ACTION_NONE = 'none';
	var TOUCH_ACTION_PAN_X = 'pan-x';
	var TOUCH_ACTION_PAN_Y = 'pan-y';
	var TOUCH_ACTION_MAP = getTouchActionProps();

	/**
	 * Touch Action
	 * sets the touchAction property or uses the js alternative
	 * @param {Manager} manager
	 * @param {String} value
	 * @constructor
	 */
	function TouchAction(manager, value) {
	    this.manager = manager;
	    this.set(value);
	}

	TouchAction.prototype = {
	    /**
	     * set the touchAction value on the element or enable the polyfill
	     * @param {String} value
	     */
	    set: function(value) {
	        // find out the touch-action by the event handlers
	        if (value == TOUCH_ACTION_COMPUTE) {
	            value = this.compute();
	        }

	        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
	            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
	        }
	        this.actions = value.toLowerCase().trim();
	    },

	    /**
	     * just re-set the touchAction value
	     */
	    update: function() {
	        this.set(this.manager.options.touchAction);
	    },

	    /**
	     * compute the value for the touchAction property based on the recognizer's settings
	     * @returns {String} value
	     */
	    compute: function() {
	        var actions = [];
	        each(this.manager.recognizers, function(recognizer) {
	            if (boolOrFn(recognizer.options.enable, [recognizer])) {
	                actions = actions.concat(recognizer.getTouchAction());
	            }
	        });
	        return cleanTouchActions(actions.join(' '));
	    },

	    /**
	     * this method is called on each input cycle and provides the preventing of the browser behavior
	     * @param {Object} input
	     */
	    preventDefaults: function(input) {
	        var srcEvent = input.srcEvent;
	        var direction = input.offsetDirection;

	        // if the touch action did prevented once this session
	        if (this.manager.session.prevented) {
	            srcEvent.preventDefault();
	            return;
	        }

	        var actions = this.actions;
	        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
	        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
	        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

	        if (hasNone) {
	            //do not prevent defaults if this is a tap gesture

	            var isTapPointer = input.pointers.length === 1;
	            var isTapMovement = input.distance < 2;
	            var isTapTouchTime = input.deltaTime < 250;

	            if (isTapPointer && isTapMovement && isTapTouchTime) {
	                return;
	            }
	        }

	        if (hasPanX && hasPanY) {
	            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
	            return;
	        }

	        if (hasNone ||
	            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
	            (hasPanX && direction & DIRECTION_VERTICAL)) {
	            return this.preventSrc(srcEvent);
	        }
	    },

	    /**
	     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
	     * @param {Object} srcEvent
	     */
	    preventSrc: function(srcEvent) {
	        this.manager.session.prevented = true;
	        srcEvent.preventDefault();
	    }
	};

	/**
	 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
	 * @param {String} actions
	 * @returns {*}
	 */
	function cleanTouchActions(actions) {
	    // none
	    if (inStr(actions, TOUCH_ACTION_NONE)) {
	        return TOUCH_ACTION_NONE;
	    }

	    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
	    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

	    // if both pan-x and pan-y are set (different recognizers
	    // for different directions, e.g. horizontal pan but vertical swipe?)
	    // we need none (as otherwise with pan-x pan-y combined none of these
	    // recognizers will work, since the browser would handle all panning
	    if (hasPanX && hasPanY) {
	        return TOUCH_ACTION_NONE;
	    }

	    // pan-x OR pan-y
	    if (hasPanX || hasPanY) {
	        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
	    }

	    // manipulation
	    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
	        return TOUCH_ACTION_MANIPULATION;
	    }

	    return TOUCH_ACTION_AUTO;
	}

	function getTouchActionProps() {
	    if (!NATIVE_TOUCH_ACTION) {
	        return false;
	    }
	    var touchMap = {};
	    var cssSupports = window.CSS && window.CSS.supports;
	    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {

	        // If css.supports is not supported but there is native touch-action assume it supports
	        // all values. This is the case for IE 10 and 11.
	        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
	    });
	    return touchMap;
	}

	/**
	 * Recognizer flow explained; *
	 * All recognizers have the initial state of POSSIBLE when a input session starts.
	 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
	 * Example session for mouse-input: mousedown -> mousemove -> mouseup
	 *
	 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
	 * which determines with state it should be.
	 *
	 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
	 * POSSIBLE to give it another change on the next cycle.
	 *
	 *               Possible
	 *                  |
	 *            +-----+---------------+
	 *            |                     |
	 *      +-----+-----+               |
	 *      |           |               |
	 *   Failed      Cancelled          |
	 *                          +-------+------+
	 *                          |              |
	 *                      Recognized       Began
	 *                                         |
	 *                                      Changed
	 *                                         |
	 *                                  Ended/Recognized
	 */
	var STATE_POSSIBLE = 1;
	var STATE_BEGAN = 2;
	var STATE_CHANGED = 4;
	var STATE_ENDED = 8;
	var STATE_RECOGNIZED = STATE_ENDED;
	var STATE_CANCELLED = 16;
	var STATE_FAILED = 32;

	/**
	 * Recognizer
	 * Every recognizer needs to extend from this class.
	 * @constructor
	 * @param {Object} options
	 */
	function Recognizer(options) {
	    this.options = assign({}, this.defaults, options || {});

	    this.id = uniqueId();

	    this.manager = null;

	    // default is enable true
	    this.options.enable = ifUndefined(this.options.enable, true);

	    this.state = STATE_POSSIBLE;

	    this.simultaneous = {};
	    this.requireFail = [];
	}

	Recognizer.prototype = {
	    /**
	     * @virtual
	     * @type {Object}
	     */
	    defaults: {},

	    /**
	     * set options
	     * @param {Object} options
	     * @return {Recognizer}
	     */
	    set: function(options) {
	        assign(this.options, options);

	        // also update the touchAction, in case something changed about the directions/enabled state
	        this.manager && this.manager.touchAction.update();
	        return this;
	    },

	    /**
	     * recognize simultaneous with an other recognizer.
	     * @param {Recognizer} otherRecognizer
	     * @returns {Recognizer} this
	     */
	    recognizeWith: function(otherRecognizer) {
	        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
	            return this;
	        }

	        var simultaneous = this.simultaneous;
	        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
	        if (!simultaneous[otherRecognizer.id]) {
	            simultaneous[otherRecognizer.id] = otherRecognizer;
	            otherRecognizer.recognizeWith(this);
	        }
	        return this;
	    },

	    /**
	     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
	     * @param {Recognizer} otherRecognizer
	     * @returns {Recognizer} this
	     */
	    dropRecognizeWith: function(otherRecognizer) {
	        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
	            return this;
	        }

	        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
	        delete this.simultaneous[otherRecognizer.id];
	        return this;
	    },

	    /**
	     * recognizer can only run when an other is failing
	     * @param {Recognizer} otherRecognizer
	     * @returns {Recognizer} this
	     */
	    requireFailure: function(otherRecognizer) {
	        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
	            return this;
	        }

	        var requireFail = this.requireFail;
	        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
	        if (inArray(requireFail, otherRecognizer) === -1) {
	            requireFail.push(otherRecognizer);
	            otherRecognizer.requireFailure(this);
	        }
	        return this;
	    },

	    /**
	     * drop the requireFailure link. it does not remove the link on the other recognizer.
	     * @param {Recognizer} otherRecognizer
	     * @returns {Recognizer} this
	     */
	    dropRequireFailure: function(otherRecognizer) {
	        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
	            return this;
	        }

	        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
	        var index = inArray(this.requireFail, otherRecognizer);
	        if (index > -1) {
	            this.requireFail.splice(index, 1);
	        }
	        return this;
	    },

	    /**
	     * has require failures boolean
	     * @returns {boolean}
	     */
	    hasRequireFailures: function() {
	        return this.requireFail.length > 0;
	    },

	    /**
	     * if the recognizer can recognize simultaneous with an other recognizer
	     * @param {Recognizer} otherRecognizer
	     * @returns {Boolean}
	     */
	    canRecognizeWith: function(otherRecognizer) {
	        return !!this.simultaneous[otherRecognizer.id];
	    },

	    /**
	     * You should use `tryEmit` instead of `emit` directly to check
	     * that all the needed recognizers has failed before emitting.
	     * @param {Object} input
	     */
	    emit: function(input) {
	        var self = this;
	        var state = this.state;

	        function emit(event) {
	            self.manager.emit(event, input);
	        }

	        // 'panstart' and 'panmove'
	        if (state < STATE_ENDED) {
	            emit(self.options.event + stateStr(state));
	        }

	        emit(self.options.event); // simple 'eventName' events

	        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)
	            emit(input.additionalEvent);
	        }

	        // panend and pancancel
	        if (state >= STATE_ENDED) {
	            emit(self.options.event + stateStr(state));
	        }
	    },

	    /**
	     * Check that all the require failure recognizers has failed,
	     * if true, it emits a gesture event,
	     * otherwise, setup the state to FAILED.
	     * @param {Object} input
	     */
	    tryEmit: function(input) {
	        if (this.canEmit()) {
	            return this.emit(input);
	        }
	        // it's failing anyway
	        this.state = STATE_FAILED;
	    },

	    /**
	     * can we emit?
	     * @returns {boolean}
	     */
	    canEmit: function() {
	        var i = 0;
	        while (i < this.requireFail.length) {
	            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
	                return false;
	            }
	            i++;
	        }
	        return true;
	    },

	    /**
	     * update the recognizer
	     * @param {Object} inputData
	     */
	    recognize: function(inputData) {
	        // make a new copy of the inputData
	        // so we can change the inputData without messing up the other recognizers
	        var inputDataClone = assign({}, inputData);

	        // is is enabled and allow recognizing?
	        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
	            this.reset();
	            this.state = STATE_FAILED;
	            return;
	        }

	        // reset when we've reached the end
	        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
	            this.state = STATE_POSSIBLE;
	        }

	        this.state = this.process(inputDataClone);

	        // the recognizer has recognized a gesture
	        // so trigger an event
	        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
	            this.tryEmit(inputDataClone);
	        }
	    },

	    /**
	     * return the state of the recognizer
	     * the actual recognizing happens in this method
	     * @virtual
	     * @param {Object} inputData
	     * @returns {Const} STATE
	     */
	    process: function(inputData) { }, // jshint ignore:line

	    /**
	     * return the preferred touch-action
	     * @virtual
	     * @returns {Array}
	     */
	    getTouchAction: function() { },

	    /**
	     * called when the gesture isn't allowed to recognize
	     * like when another is being recognized or it is disabled
	     * @virtual
	     */
	    reset: function() { }
	};

	/**
	 * get a usable string, used as event postfix
	 * @param {Const} state
	 * @returns {String} state
	 */
	function stateStr(state) {
	    if (state & STATE_CANCELLED) {
	        return 'cancel';
	    } else if (state & STATE_ENDED) {
	        return 'end';
	    } else if (state & STATE_CHANGED) {
	        return 'move';
	    } else if (state & STATE_BEGAN) {
	        return 'start';
	    }
	    return '';
	}

	/**
	 * direction cons to string
	 * @param {Const} direction
	 * @returns {String}
	 */
	function directionStr(direction) {
	    if (direction == DIRECTION_DOWN) {
	        return 'down';
	    } else if (direction == DIRECTION_UP) {
	        return 'up';
	    } else if (direction == DIRECTION_LEFT) {
	        return 'left';
	    } else if (direction == DIRECTION_RIGHT) {
	        return 'right';
	    }
	    return '';
	}

	/**
	 * get a recognizer by name if it is bound to a manager
	 * @param {Recognizer|String} otherRecognizer
	 * @param {Recognizer} recognizer
	 * @returns {Recognizer}
	 */
	function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
	    var manager = recognizer.manager;
	    if (manager) {
	        return manager.get(otherRecognizer);
	    }
	    return otherRecognizer;
	}

	/**
	 * This recognizer is just used as a base for the simple attribute recognizers.
	 * @constructor
	 * @extends Recognizer
	 */
	function AttrRecognizer() {
	    Recognizer.apply(this, arguments);
	}

	inherit(AttrRecognizer, Recognizer, {
	    /**
	     * @namespace
	     * @memberof AttrRecognizer
	     */
	    defaults: {
	        /**
	         * @type {Number}
	         * @default 1
	         */
	        pointers: 1
	    },

	    /**
	     * Used to check if it the recognizer receives valid input, like input.distance > 10.
	     * @memberof AttrRecognizer
	     * @param {Object} input
	     * @returns {Boolean} recognized
	     */
	    attrTest: function(input) {
	        var optionPointers = this.options.pointers;
	        return optionPointers === 0 || input.pointers.length === optionPointers;
	    },

	    /**
	     * Process the input and return the state for the recognizer
	     * @memberof AttrRecognizer
	     * @param {Object} input
	     * @returns {*} State
	     */
	    process: function(input) {
	        var state = this.state;
	        var eventType = input.eventType;

	        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
	        var isValid = this.attrTest(input);

	        // on cancel input and we've recognized before, return STATE_CANCELLED
	        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
	            return state | STATE_CANCELLED;
	        } else if (isRecognized || isValid) {
	            if (eventType & INPUT_END) {
	                return state | STATE_ENDED;
	            } else if (!(state & STATE_BEGAN)) {
	                return STATE_BEGAN;
	            }
	            return state | STATE_CHANGED;
	        }
	        return STATE_FAILED;
	    }
	});

	/**
	 * Pan
	 * Recognized when the pointer is down and moved in the allowed direction.
	 * @constructor
	 * @extends AttrRecognizer
	 */
	function PanRecognizer() {
	    AttrRecognizer.apply(this, arguments);

	    this.pX = null;
	    this.pY = null;
	}

	inherit(PanRecognizer, AttrRecognizer, {
	    /**
	     * @namespace
	     * @memberof PanRecognizer
	     */
	    defaults: {
	        event: 'pan',
	        threshold: 10,
	        pointers: 1,
	        direction: DIRECTION_ALL
	    },

	    getTouchAction: function() {
	        var direction = this.options.direction;
	        var actions = [];
	        if (direction & DIRECTION_HORIZONTAL) {
	            actions.push(TOUCH_ACTION_PAN_Y);
	        }
	        if (direction & DIRECTION_VERTICAL) {
	            actions.push(TOUCH_ACTION_PAN_X);
	        }
	        return actions;
	    },

	    directionTest: function(input) {
	        var options = this.options;
	        var hasMoved = true;
	        var distance = input.distance;
	        var direction = input.direction;
	        var x = input.deltaX;
	        var y = input.deltaY;

	        // lock to axis?
	        if (!(direction & options.direction)) {
	            if (options.direction & DIRECTION_HORIZONTAL) {
	                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
	                hasMoved = x != this.pX;
	                distance = Math.abs(input.deltaX);
	            } else {
	                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
	                hasMoved = y != this.pY;
	                distance = Math.abs(input.deltaY);
	            }
	        }
	        input.direction = direction;
	        return hasMoved && distance > options.threshold && direction & options.direction;
	    },

	    attrTest: function(input) {
	        return AttrRecognizer.prototype.attrTest.call(this, input) &&
	            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
	    },

	    emit: function(input) {

	        this.pX = input.deltaX;
	        this.pY = input.deltaY;

	        var direction = directionStr(input.direction);

	        if (direction) {
	            input.additionalEvent = this.options.event + direction;
	        }
	        this._super.emit.call(this, input);
	    }
	});

	/**
	 * Pinch
	 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
	 * @constructor
	 * @extends AttrRecognizer
	 */
	function PinchRecognizer() {
	    AttrRecognizer.apply(this, arguments);
	}

	inherit(PinchRecognizer, AttrRecognizer, {
	    /**
	     * @namespace
	     * @memberof PinchRecognizer
	     */
	    defaults: {
	        event: 'pinch',
	        threshold: 0,
	        pointers: 2
	    },

	    getTouchAction: function() {
	        return [TOUCH_ACTION_NONE];
	    },

	    attrTest: function(input) {
	        return this._super.attrTest.call(this, input) &&
	            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
	    },

	    emit: function(input) {
	        if (input.scale !== 1) {
	            var inOut = input.scale < 1 ? 'in' : 'out';
	            input.additionalEvent = this.options.event + inOut;
	        }
	        this._super.emit.call(this, input);
	    }
	});

	/**
	 * Press
	 * Recognized when the pointer is down for x ms without any movement.
	 * @constructor
	 * @extends Recognizer
	 */
	function PressRecognizer() {
	    Recognizer.apply(this, arguments);

	    this._timer = null;
	    this._input = null;
	}

	inherit(PressRecognizer, Recognizer, {
	    /**
	     * @namespace
	     * @memberof PressRecognizer
	     */
	    defaults: {
	        event: 'press',
	        pointers: 1,
	        time: 251, // minimal time of the pointer to be pressed
	        threshold: 9 // a minimal movement is ok, but keep it low
	    },

	    getTouchAction: function() {
	        return [TOUCH_ACTION_AUTO];
	    },

	    process: function(input) {
	        var options = this.options;
	        var validPointers = input.pointers.length === options.pointers;
	        var validMovement = input.distance < options.threshold;
	        var validTime = input.deltaTime > options.time;

	        this._input = input;

	        // we only allow little movement
	        // and we've reached an end event, so a tap is possible
	        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
	            this.reset();
	        } else if (input.eventType & INPUT_START) {
	            this.reset();
	            this._timer = setTimeoutContext(function() {
	                this.state = STATE_RECOGNIZED;
	                this.tryEmit();
	            }, options.time, this);
	        } else if (input.eventType & INPUT_END) {
	            return STATE_RECOGNIZED;
	        }
	        return STATE_FAILED;
	    },

	    reset: function() {
	        clearTimeout(this._timer);
	    },

	    emit: function(input) {
	        if (this.state !== STATE_RECOGNIZED) {
	            return;
	        }

	        if (input && (input.eventType & INPUT_END)) {
	            this.manager.emit(this.options.event + 'up', input);
	        } else {
	            this._input.timeStamp = now();
	            this.manager.emit(this.options.event, this._input);
	        }
	    }
	});

	/**
	 * Rotate
	 * Recognized when two or more pointer are moving in a circular motion.
	 * @constructor
	 * @extends AttrRecognizer
	 */
	function RotateRecognizer() {
	    AttrRecognizer.apply(this, arguments);
	}

	inherit(RotateRecognizer, AttrRecognizer, {
	    /**
	     * @namespace
	     * @memberof RotateRecognizer
	     */
	    defaults: {
	        event: 'rotate',
	        threshold: 0,
	        pointers: 2
	    },

	    getTouchAction: function() {
	        return [TOUCH_ACTION_NONE];
	    },

	    attrTest: function(input) {
	        return this._super.attrTest.call(this, input) &&
	            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
	    }
	});

	/**
	 * Swipe
	 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
	 * @constructor
	 * @extends AttrRecognizer
	 */
	function SwipeRecognizer() {
	    AttrRecognizer.apply(this, arguments);
	}

	inherit(SwipeRecognizer, AttrRecognizer, {
	    /**
	     * @namespace
	     * @memberof SwipeRecognizer
	     */
	    defaults: {
	        event: 'swipe',
	        threshold: 10,
	        velocity: 0.3,
	        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
	        pointers: 1
	    },

	    getTouchAction: function() {
	        return PanRecognizer.prototype.getTouchAction.call(this);
	    },

	    attrTest: function(input) {
	        var direction = this.options.direction;
	        var velocity;

	        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
	            velocity = input.overallVelocity;
	        } else if (direction & DIRECTION_HORIZONTAL) {
	            velocity = input.overallVelocityX;
	        } else if (direction & DIRECTION_VERTICAL) {
	            velocity = input.overallVelocityY;
	        }

	        return this._super.attrTest.call(this, input) &&
	            direction & input.offsetDirection &&
	            input.distance > this.options.threshold &&
	            input.maxPointers == this.options.pointers &&
	            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
	    },

	    emit: function(input) {
	        var direction = directionStr(input.offsetDirection);
	        if (direction) {
	            this.manager.emit(this.options.event + direction, input);
	        }

	        this.manager.emit(this.options.event, input);
	    }
	});

	/**
	 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
	 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
	 * a single tap.
	 *
	 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
	 * multi-taps being recognized.
	 * @constructor
	 * @extends Recognizer
	 */
	function TapRecognizer() {
	    Recognizer.apply(this, arguments);

	    // previous time and center,
	    // used for tap counting
	    this.pTime = false;
	    this.pCenter = false;

	    this._timer = null;
	    this._input = null;
	    this.count = 0;
	}

	inherit(TapRecognizer, Recognizer, {
	    /**
	     * @namespace
	     * @memberof PinchRecognizer
	     */
	    defaults: {
	        event: 'tap',
	        pointers: 1,
	        taps: 1,
	        interval: 300, // max time between the multi-tap taps
	        time: 250, // max time of the pointer to be down (like finger on the screen)
	        threshold: 9, // a minimal movement is ok, but keep it low
	        posThreshold: 10 // a multi-tap can be a bit off the initial position
	    },

	    getTouchAction: function() {
	        return [TOUCH_ACTION_MANIPULATION];
	    },

	    process: function(input) {
	        var options = this.options;

	        var validPointers = input.pointers.length === options.pointers;
	        var validMovement = input.distance < options.threshold;
	        var validTouchTime = input.deltaTime < options.time;

	        this.reset();

	        if ((input.eventType & INPUT_START) && (this.count === 0)) {
	            return this.failTimeout();
	        }

	        // we only allow little movement
	        // and we've reached an end event, so a tap is possible
	        if (validMovement && validTouchTime && validPointers) {
	            if (input.eventType != INPUT_END) {
	                return this.failTimeout();
	            }

	            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
	            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

	            this.pTime = input.timeStamp;
	            this.pCenter = input.center;

	            if (!validMultiTap || !validInterval) {
	                this.count = 1;
	            } else {
	                this.count += 1;
	            }

	            this._input = input;

	            // if tap count matches we have recognized it,
	            // else it has began recognizing...
	            var tapCount = this.count % options.taps;
	            if (tapCount === 0) {
	                // no failing requirements, immediately trigger the tap event
	                // or wait as long as the multitap interval to trigger
	                if (!this.hasRequireFailures()) {
	                    return STATE_RECOGNIZED;
	                } else {
	                    this._timer = setTimeoutContext(function() {
	                        this.state = STATE_RECOGNIZED;
	                        this.tryEmit();
	                    }, options.interval, this);
	                    return STATE_BEGAN;
	                }
	            }
	        }
	        return STATE_FAILED;
	    },

	    failTimeout: function() {
	        this._timer = setTimeoutContext(function() {
	            this.state = STATE_FAILED;
	        }, this.options.interval, this);
	        return STATE_FAILED;
	    },

	    reset: function() {
	        clearTimeout(this._timer);
	    },

	    emit: function() {
	        if (this.state == STATE_RECOGNIZED) {
	            this._input.tapCount = this.count;
	            this.manager.emit(this.options.event, this._input);
	        }
	    }
	});

	/**
	 * Simple way to create a manager with a default set of recognizers.
	 * @param {HTMLElement} element
	 * @param {Object} [options]
	 * @constructor
	 */
	function Hammer(element, options) {
	    options = options || {};
	    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
	    return new Manager(element, options);
	}

	/**
	 * @const {string}
	 */
	Hammer.VERSION = '2.0.7';

	/**
	 * default settings
	 * @namespace
	 */
	Hammer.defaults = {
	    /**
	     * set if DOM events are being triggered.
	     * But this is slower and unused by simple implementations, so disabled by default.
	     * @type {Boolean}
	     * @default false
	     */
	    domEvents: false,

	    /**
	     * The value for the touchAction property/fallback.
	     * When set to `compute` it will magically set the correct value based on the added recognizers.
	     * @type {String}
	     * @default compute
	     */
	    touchAction: TOUCH_ACTION_COMPUTE,

	    /**
	     * @type {Boolean}
	     * @default true
	     */
	    enable: true,

	    /**
	     * EXPERIMENTAL FEATURE -- can be removed/changed
	     * Change the parent input target element.
	     * If Null, then it is being set the to main element.
	     * @type {Null|EventTarget}
	     * @default null
	     */
	    inputTarget: null,

	    /**
	     * force an input class
	     * @type {Null|Function}
	     * @default null
	     */
	    inputClass: null,

	    /**
	     * Default recognizer setup when calling `Hammer()`
	     * When creating a new Manager these will be skipped.
	     * @type {Array}
	     */
	    preset: [
	        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
	        [RotateRecognizer, {enable: false}],
	        [PinchRecognizer, {enable: false}, ['rotate']],
	        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],
	        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],
	        [TapRecognizer],
	        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],
	        [PressRecognizer]
	    ],

	    /**
	     * Some CSS properties can be used to improve the working of Hammer.
	     * Add them to this method and they will be set when creating a new Manager.
	     * @namespace
	     */
	    cssProps: {
	        /**
	         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
	         * @type {String}
	         * @default 'none'
	         */
	        userSelect: 'none',

	        /**
	         * Disable the Windows Phone grippers when pressing an element.
	         * @type {String}
	         * @default 'none'
	         */
	        touchSelect: 'none',

	        /**
	         * Disables the default callout shown when you touch and hold a touch target.
	         * On iOS, when you touch and hold a touch target such as a link, Safari displays
	         * a callout containing information about the link. This property allows you to disable that callout.
	         * @type {String}
	         * @default 'none'
	         */
	        touchCallout: 'none',

	        /**
	         * Specifies whether zooming is enabled. Used by IE10>
	         * @type {String}
	         * @default 'none'
	         */
	        contentZooming: 'none',

	        /**
	         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
	         * @type {String}
	         * @default 'none'
	         */
	        userDrag: 'none',

	        /**
	         * Overrides the highlight color shown when the user taps a link or a JavaScript
	         * clickable element in iOS. This property obeys the alpha value, if specified.
	         * @type {String}
	         * @default 'rgba(0,0,0,0)'
	         */
	        tapHighlightColor: 'rgba(0,0,0,0)'
	    }
	};

	var STOP = 1;
	var FORCED_STOP = 2;

	/**
	 * Manager
	 * @param {HTMLElement} element
	 * @param {Object} [options]
	 * @constructor
	 */
	function Manager(element, options) {
	    this.options = assign({}, Hammer.defaults, options || {});

	    this.options.inputTarget = this.options.inputTarget || element;

	    this.handlers = {};
	    this.session = {};
	    this.recognizers = [];
	    this.oldCssProps = {};

	    this.element = element;
	    this.input = createInputInstance(this);
	    this.touchAction = new TouchAction(this, this.options.touchAction);

	    toggleCssProps(this, true);

	    each(this.options.recognizers, function(item) {
	        var recognizer = this.add(new (item[0])(item[1]));
	        item[2] && recognizer.recognizeWith(item[2]);
	        item[3] && recognizer.requireFailure(item[3]);
	    }, this);
	}

	Manager.prototype = {
	    /**
	     * set options
	     * @param {Object} options
	     * @returns {Manager}
	     */
	    set: function(options) {
	        assign(this.options, options);

	        // Options that need a little more setup
	        if (options.touchAction) {
	            this.touchAction.update();
	        }
	        if (options.inputTarget) {
	            // Clean up existing event listeners and reinitialize
	            this.input.destroy();
	            this.input.target = options.inputTarget;
	            this.input.init();
	        }
	        return this;
	    },

	    /**
	     * stop recognizing for this session.
	     * This session will be discarded, when a new [input]start event is fired.
	     * When forced, the recognizer cycle is stopped immediately.
	     * @param {Boolean} [force]
	     */
	    stop: function(force) {
	        this.session.stopped = force ? FORCED_STOP : STOP;
	    },

	    /**
	     * run the recognizers!
	     * called by the inputHandler function on every movement of the pointers (touches)
	     * it walks through all the recognizers and tries to detect the gesture that is being made
	     * @param {Object} inputData
	     */
	    recognize: function(inputData) {
	        var session = this.session;
	        if (session.stopped) {
	            return;
	        }

	        // run the touch-action polyfill
	        this.touchAction.preventDefaults(inputData);

	        var recognizer;
	        var recognizers = this.recognizers;

	        // this holds the recognizer that is being recognized.
	        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
	        // if no recognizer is detecting a thing, it is set to `null`
	        var curRecognizer = session.curRecognizer;

	        // reset when the last recognizer is recognized
	        // or when we're in a new session
	        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
	            curRecognizer = session.curRecognizer = null;
	        }

	        var i = 0;
	        while (i < recognizers.length) {
	            recognizer = recognizers[i];

	            // find out if we are allowed try to recognize the input for this one.
	            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
	            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
	            //      that is being recognized.
	            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
	            //      this can be setup with the `recognizeWith()` method on the recognizer.
	            if (session.stopped !== FORCED_STOP && ( // 1
	                    !curRecognizer || recognizer == curRecognizer || // 2
	                    recognizer.canRecognizeWith(curRecognizer))) { // 3
	                recognizer.recognize(inputData);
	            } else {
	                recognizer.reset();
	            }

	            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
	            // current active recognizer. but only if we don't already have an active recognizer
	            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
	                curRecognizer = session.curRecognizer = recognizer;
	            }
	            i++;
	        }
	    },

	    /**
	     * get a recognizer by its event name.
	     * @param {Recognizer|String} recognizer
	     * @returns {Recognizer|Null}
	     */
	    get: function(recognizer) {
	        if (recognizer instanceof Recognizer) {
	            return recognizer;
	        }

	        var recognizers = this.recognizers;
	        for (var i = 0; i < recognizers.length; i++) {
	            if (recognizers[i].options.event == recognizer) {
	                return recognizers[i];
	            }
	        }
	        return null;
	    },

	    /**
	     * add a recognizer to the manager
	     * existing recognizers with the same event name will be removed
	     * @param {Recognizer} recognizer
	     * @returns {Recognizer|Manager}
	     */
	    add: function(recognizer) {
	        if (invokeArrayArg(recognizer, 'add', this)) {
	            return this;
	        }

	        // remove existing
	        var existing = this.get(recognizer.options.event);
	        if (existing) {
	            this.remove(existing);
	        }

	        this.recognizers.push(recognizer);
	        recognizer.manager = this;

	        this.touchAction.update();
	        return recognizer;
	    },

	    /**
	     * remove a recognizer by name or instance
	     * @param {Recognizer|String} recognizer
	     * @returns {Manager}
	     */
	    remove: function(recognizer) {
	        if (invokeArrayArg(recognizer, 'remove', this)) {
	            return this;
	        }

	        recognizer = this.get(recognizer);

	        // let's make sure this recognizer exists
	        if (recognizer) {
	            var recognizers = this.recognizers;
	            var index = inArray(recognizers, recognizer);

	            if (index !== -1) {
	                recognizers.splice(index, 1);
	                this.touchAction.update();
	            }
	        }

	        return this;
	    },

	    /**
	     * bind event
	     * @param {String} events
	     * @param {Function} handler
	     * @returns {EventEmitter} this
	     */
	    on: function(events, handler) {
	        if (events === undefined$1) {
	            return;
	        }
	        if (handler === undefined$1) {
	            return;
	        }

	        var handlers = this.handlers;
	        each(splitStr(events), function(event) {
	            handlers[event] = handlers[event] || [];
	            handlers[event].push(handler);
	        });
	        return this;
	    },

	    /**
	     * unbind event, leave emit blank to remove all handlers
	     * @param {String} events
	     * @param {Function} [handler]
	     * @returns {EventEmitter} this
	     */
	    off: function(events, handler) {
	        if (events === undefined$1) {
	            return;
	        }

	        var handlers = this.handlers;
	        each(splitStr(events), function(event) {
	            if (!handler) {
	                delete handlers[event];
	            } else {
	                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
	            }
	        });
	        return this;
	    },

	    /**
	     * emit event to the listeners
	     * @param {String} event
	     * @param {Object} data
	     */
	    emit: function(event, data) {
	        // we also want to trigger dom events
	        if (this.options.domEvents) {
	            triggerDomEvent(event, data);
	        }

	        // no handlers, so skip it all
	        var handlers = this.handlers[event] && this.handlers[event].slice();
	        if (!handlers || !handlers.length) {
	            return;
	        }

	        data.type = event;
	        data.preventDefault = function() {
	            data.srcEvent.preventDefault();
	        };

	        var i = 0;
	        while (i < handlers.length) {
	            handlers[i](data);
	            i++;
	        }
	    },

	    /**
	     * destroy the manager and unbinds all events
	     * it doesn't unbind dom events, that is the user own responsibility
	     */
	    destroy: function() {
	        this.element && toggleCssProps(this, false);

	        this.handlers = {};
	        this.session = {};
	        this.input.destroy();
	        this.element = null;
	    }
	};

	/**
	 * add/remove the css properties as defined in manager.options.cssProps
	 * @param {Manager} manager
	 * @param {Boolean} add
	 */
	function toggleCssProps(manager, add) {
	    var element = manager.element;
	    if (!element.style) {
	        return;
	    }
	    var prop;
	    each(manager.options.cssProps, function(value, name) {
	        prop = prefixed(element.style, name);
	        if (add) {
	            manager.oldCssProps[prop] = element.style[prop];
	            element.style[prop] = value;
	        } else {
	            element.style[prop] = manager.oldCssProps[prop] || '';
	        }
	    });
	    if (!add) {
	        manager.oldCssProps = {};
	    }
	}

	/**
	 * trigger dom event
	 * @param {String} event
	 * @param {Object} data
	 */
	function triggerDomEvent(event, data) {
	    var gestureEvent = document.createEvent('Event');
	    gestureEvent.initEvent(event, true, true);
	    gestureEvent.gesture = data;
	    data.target.dispatchEvent(gestureEvent);
	}

	assign(Hammer, {
	    INPUT_START: INPUT_START,
	    INPUT_MOVE: INPUT_MOVE,
	    INPUT_END: INPUT_END,
	    INPUT_CANCEL: INPUT_CANCEL,

	    STATE_POSSIBLE: STATE_POSSIBLE,
	    STATE_BEGAN: STATE_BEGAN,
	    STATE_CHANGED: STATE_CHANGED,
	    STATE_ENDED: STATE_ENDED,
	    STATE_RECOGNIZED: STATE_RECOGNIZED,
	    STATE_CANCELLED: STATE_CANCELLED,
	    STATE_FAILED: STATE_FAILED,

	    DIRECTION_NONE: DIRECTION_NONE,
	    DIRECTION_LEFT: DIRECTION_LEFT,
	    DIRECTION_RIGHT: DIRECTION_RIGHT,
	    DIRECTION_UP: DIRECTION_UP,
	    DIRECTION_DOWN: DIRECTION_DOWN,
	    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
	    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
	    DIRECTION_ALL: DIRECTION_ALL,

	    Manager: Manager,
	    Input: Input,
	    TouchAction: TouchAction,

	    TouchInput: TouchInput,
	    MouseInput: MouseInput,
	    PointerEventInput: PointerEventInput,
	    TouchMouseInput: TouchMouseInput,
	    SingleTouchInput: SingleTouchInput,

	    Recognizer: Recognizer,
	    AttrRecognizer: AttrRecognizer,
	    Tap: TapRecognizer,
	    Pan: PanRecognizer,
	    Swipe: SwipeRecognizer,
	    Pinch: PinchRecognizer,
	    Rotate: RotateRecognizer,
	    Press: PressRecognizer,

	    on: addEventListeners,
	    off: removeEventListeners,
	    each: each,
	    merge: merge,
	    extend: extend,
	    assign: assign,
	    inherit: inherit,
	    bindFn: bindFn,
	    prefixed: prefixed
	});

	// this prevents errors when Hammer is loaded in the presence of an AMD
	//  style loader but by script tag, not by the loader.
	var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line
	freeGlobal.Hammer = Hammer;

	if (typeof undefined$1 === 'function' && undefined$1.amd) {
	    undefined$1(function() {
	        return Hammer;
	    });
	} else if (module.exports) {
	    module.exports = Hammer;
	} else {
	    window[exportName] = Hammer;
	}

	})(window, document, 'Hammer');
} (hammer));

const DEFAULT_SLIDER_THRESHOLD = 10;
const getSliderThreshold = (element) => {
    const thresholdValue = window.getComputedStyle(element).getPropertyValue("--slider-threshold");
    const threshold = parseFloat(thresholdValue);
    return isNaN(threshold) ? DEFAULT_SLIDER_THRESHOLD : threshold;
};
function throttle$1(cb, delay = 0) {
    let shouldWait = false;
    return (...args) => {
        if (shouldWait)
            return;
        cb(...args);
        shouldWait = true;
        setTimeout(() => {
            shouldWait = false;
        }, delay);
    };
}
let SliderItem = class SliderItem extends s$1 {
    constructor() {
        super(...arguments);
        this.disabled = false;
        this.inactive = false;
        this.step = 1;
        this.min = 0;
        this.max = 100;
        this.controlled = false;
    }
    valueToPercentage(value) {
        return (value - this.min) / (this.max - this.min);
    }
    percentageToValue(value) {
        return (this.max - this.min) * value + this.min;
    }
    firstUpdated(changedProperties) {
        super.firstUpdated(changedProperties);
        this.setupListeners();
    }
    connectedCallback() {
        super.connectedCallback();
        this.setupListeners();
    }
    disconnectedCallback() {
        super.disconnectedCallback();
        this.destroyListeners();
    }
    setupListeners() {
        const getPercentageFromEvent = (e) => {
            const x = e.center.x;
            const offset = e.target.getBoundingClientRect().left;
            const total = e.target.clientWidth;
            return (x - offset) / total;
        };
        if (this.slider && !this._mc) {
            const threshold = getSliderThreshold(this.slider);
            this._mc = new Hammer.Manager(this.slider, { touchAction: "pan-y" });
            this._mc.add(new Hammer.Pan({
                threshold,
                direction: Hammer.DIRECTION_ALL,
                enable: true,
            }));
            this._mc.add(new Hammer.Tap({ event: "singletap" }));
            let savedValue;
            let panstartPercentage = 0;
            const getPanTargetValue = (e) => {
                const percentage = getPercentageFromEvent(e);
                const deltaPercentage = (percentage - panstartPercentage) * 0.5;
                const deltaValue = (this.max - this.min) * deltaPercentage;
                return Math.max(Math.min(savedValue + deltaValue, this.max), this.min);
            };
            const throttledChange = throttle$1((value) => {
                this.dispatchEvent(new CustomEvent("change", {
                    detail: {
                        value,
                    },
                }));
            }, 130);
            this._mc.on("panstart", (e) => {
                if (this.disabled)
                    return;
                this.controlled = true;
                savedValue = this.value || this.min;
                panstartPercentage = getPercentageFromEvent(e);
            });
            this._mc.on("pancancel", () => {
                if (this.disabled)
                    return;
                this.controlled = false;
                this.value = savedValue;
            });
            this._mc.on("panmove", (e) => {
                if (this.disabled)
                    return;
                this.value = getPanTargetValue(e);
                const discreteValue = Math.round(this.value / this.step) * this.step;
                this.dispatchEvent(new CustomEvent("current-change", {
                    detail: {
                        value: discreteValue,
                    },
                }));
                throttledChange(discreteValue);
            });
            this._mc.on("panend", (e) => {
                if (this.disabled)
                    return;
                this.controlled = false;
                const targetValue = getPanTargetValue(e);
                // Prevent from input releasing on a value that doesn't lie on a step
                this.value = Math.round(targetValue / this.step) * this.step;
                this.dispatchEvent(new CustomEvent("current-change", {
                    detail: {
                        value: undefined,
                    },
                }));
                this.dispatchEvent(new CustomEvent("change", {
                    detail: {
                        value: this.value,
                    },
                }));
            });
            this._mc.on("singletap", (e) => {
                if (this.disabled)
                    return;
                const percentage = getPercentageFromEvent(e);
                // Prevent from input selecting a value that doesn't lie on a step
                this.value = Math.round(this.percentageToValue(percentage) / this.step) * this.step;
                this.dispatchEvent(new CustomEvent("change", {
                    detail: {
                        value: this.value,
                    },
                }));
            });
        }
    }
    destroyListeners() {
        if (this._mc) {
            this._mc.destroy();
            this._mc = undefined;
        }
    }
    render() {
        var _a;
        return $ `
            <div
                class=${o({
            container: true,
            inactive: this.inactive || this.disabled,
            controlled: this.controlled,
        })}
            >
                <div
                    id="slider"
                    class="slider"
                    style=${i$2({
            "--value": `${this.valueToPercentage((_a = this.value) !== null && _a !== void 0 ? _a : 0)}`,
        })}
                >
                    <div class="slider-track-background"></div>
                    ${this.showActive ? $ `<div class="slider-track-active"></div>` : null}
                    ${this.showIndicator ? $ `<div class="slider-track-indicator"></div>` : null}
                </div>
            </div>
        `;
    }
    static get styles() {
        return r$3 `
            :host {
                --main-color: rgba(var(--rgb-secondary-text-color), 1);
                --bg-gradient: none;
                --bg-color: rgba(var(--rgb-secondary-text-color), 0.2);
                --main-color-inactive: rgb(var(--rgb-disabled));
                --bg-color-inactive: rgba(var(--rgb-disabled), 0.2);
            }
            .container {
                display: flex;
                flex-direction: row;
                height: var(--control-height);
            }
            .slider {
                position: relative;
                height: 100%;
                width: 100%;
                border-radius: var(--control-border-radius);
                transform: translateZ(0);
                overflow: hidden;
                cursor: pointer;
            }
            .slider * {
                pointer-events: none;
            }
            .slider .slider-track-background {
                position: absolute;
                top: 0;
                left: 0;
                height: 100%;
                width: 100%;
                background-color: var(--bg-color);
                background-image: var(--gradient);
            }
            .slider .slider-track-active {
                position: absolute;
                top: 0;
                left: 0;
                height: 100%;
                width: 100%;
                transform: scale3d(var(--value, 0), 1, 1);
                transform-origin: left;
                background-color: var(--main-color);
                transition: transform 180ms ease-in-out;
            }
            .slider .slider-track-indicator {
                position: absolute;
                top: 0;
                bottom: 0;
                left: calc(var(--value, 0) * (100% - 10px));
                width: 10px;
                border-radius: 3px;
                background-color: white;
                box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12);
                transition: left 180ms ease-in-out;
            }
            .slider .slider-track-indicator:after {
                display: block;
                content: "";
                background-color: var(--main-color);
                position: absolute;
                top: 0;
                left: 0;
                bottom: 0;
                right: 0;
                margin: auto;
                height: 20px;
                width: 2px;
                border-radius: 1px;
            }
            .inactive .slider .slider-track-background {
                background-color: var(--bg-color-inactive);
                background-image: none;
            }
            .inactive .slider .slider-track-indicator:after {
                background-color: var(--main-color-inactive);
            }
            .inactive .slider .slider-track-active {
                background-color: var(--main-color-inactive);
            }
            .controlled .slider .slider-track-active {
                transition: none;
            }
            .controlled .slider .slider-track-indicator {
                transition: none;
            }
        `;
    }
};
__decorate([
    e$3({ type: Boolean })
], SliderItem.prototype, "disabled", void 0);
__decorate([
    e$3({ type: Boolean })
], SliderItem.prototype, "inactive", void 0);
__decorate([
    e$3({ type: Boolean, attribute: "show-active" })
], SliderItem.prototype, "showActive", void 0);
__decorate([
    e$3({ type: Boolean, attribute: "show-indicator" })
], SliderItem.prototype, "showIndicator", void 0);
__decorate([
    e$3({ attribute: false, type: Number, reflect: true })
], SliderItem.prototype, "value", void 0);
__decorate([
    e$3({ type: Number })
], SliderItem.prototype, "step", void 0);
__decorate([
    e$3({ type: Number })
], SliderItem.prototype, "min", void 0);
__decorate([
    e$3({ type: Number })
], SliderItem.prototype, "max", void 0);
__decorate([
    t$1()
], SliderItem.prototype, "controlled", void 0);
__decorate([
    i$4("#slider")
], SliderItem.prototype, "slider", void 0);
SliderItem = __decorate([
    n$1("mushroom-slider")
], SliderItem);

function getPosition(entity) {
    return entity.attributes.current_position != null
        ? Math.round(entity.attributes.current_position)
        : undefined;
}
function getTiltPosition(entity) {
    return entity.attributes.current_tilt_position != null
        ? Math.round(entity.attributes.current_tilt_position)
        : undefined;
}
function getStateColor$2(entity) {
    const state = entity.state;
    if (state === "open" || state === "opening") {
        return "var(--rgb-state-cover-open)";
    }
    if (state === "closed" || state === "closing") {
        return "var(--rgb-state-cover-closed)";
    }
    return "var(--rgb-disabled)";
}

let CoverPositionControl = class CoverPositionControl extends s$1 {
    onChange(e) {
        const value = e.detail.value;
        this.hass.callService("cover", "set_cover_position", {
            entity_id: this.entity.entity_id,
            position: value,
        });
    }
    onCurrentChange(e) {
        const value = e.detail.value;
        this.dispatchEvent(new CustomEvent("current-change", {
            detail: {
                value,
            },
        }));
    }
    render() {
        const position = getPosition(this.entity);
        return $ `
            <mushroom-slider
                .value=${position}
                .disabled=${!isAvailable(this.entity)}
                .showActive=${true}
                @change=${this.onChange}
                @current-change=${this.onCurrentChange}
            />
        `;
    }
    static get styles() {
        return r$3 `
            mushroom-slider {
                --main-color: var(--slider-color);
                --bg-color: var(--slider-bg-color);
            }
        `;
    }
};
__decorate([
    e$3({ attribute: false })
], CoverPositionControl.prototype, "hass", void 0);
__decorate([
    e$3({ attribute: false })
], CoverPositionControl.prototype, "entity", void 0);
CoverPositionControl = __decorate([
    n$1("mushroom-cover-position-control")
], CoverPositionControl);

function createTiltSliderTrackBackgroundGradient(count = 24, minStrokeWidth = 0.2) {
    const gradient = [];
    for (let i = 0; i < count; i++) {
        const stopOffset1 = i / count;
        const stopOffset2 = stopOffset1 + (i / count ** 2) * (1 - minStrokeWidth) + minStrokeWidth / count;
        if (i !== 0) {
            gradient.push([stopOffset1, "transparent"]);
        }
        gradient.push([stopOffset1, "var(--slider-bg-color)"]);
        gradient.push([stopOffset2, "var(--slider-bg-color)"]);
        gradient.push([stopOffset2, "transparent"]);
    }
    return gradient;
}
const GRADIENT$1 = createTiltSliderTrackBackgroundGradient();
let CoverTiltPositionControl = class CoverTiltPositionControl extends s$1 {
    onChange(e) {
        const value = e.detail.value;
        this.hass.callService("cover", "set_cover_tilt_position", {
            entity_id: this.entity.entity_id,
            tilt_position: value,
        });
    }
    onCurrentChange(e) {
        const value = e.detail.value;
        this.dispatchEvent(new CustomEvent("current-change", {
            detail: {
                value,
            },
        }));
    }
    render() {
        const tilt = getTiltPosition(this.entity);
        return $ `
            <mushroom-slider
                .value=${tilt}
                .disabled=${!isAvailable(this.entity)}
                .showIndicator=${true}
                @change=${this.onChange}
                @current-change=${this.onCurrentChange}
            />
        `;
    }
    static get styles() {
        const gradient = GRADIENT$1.map(([stop, color]) => `${color} ${stop * 100}%`).join(", ");
        return r$3 `
            mushroom-slider {
                --main-color: var(--slider-color);
                --bg-color: var(--slider-bg-color);
                --gradient: -webkit-linear-gradient(left, ${o$5(gradient)});
            }
        `;
    }
};
__decorate([
    e$3({ attribute: false })
], CoverTiltPositionControl.prototype, "hass", void 0);
__decorate([
    e$3({ attribute: false })
], CoverTiltPositionControl.prototype, "entity", void 0);
CoverTiltPositionControl = __decorate([
    n$1("mushroom-cover-tilt-position-control")
], CoverTiltPositionControl);

const CONTROLS_ICONS$2 = {
    buttons_control: "mdi:gesture-tap-button",
    position_control: "mdi:gesture-swipe-horizontal",
    tilt_position_control: "mdi:rotate-right",
};
registerCustomCard({
    type: COVER_CARD_NAME,
    name: "Mushroom Cover Card",
    description: "Card for cover entity",
});
let CoverCard = class CoverCard extends MushroomBaseCard {
    constructor() {
        super(...arguments);
        this._controls = [];
    }
    static async getConfigElement() {
        await Promise.resolve().then(function () { return coverCardEditor; });
        return document.createElement(COVER_CARD_EDITOR_NAME);
    }
    static async getStubConfig(hass) {
        const entities = Object.keys(hass.states);
        const covers = entities.filter((e) => COVER_ENTITY_DOMAINS.includes(e.split(".")[0]));
        return {
            type: `custom:${COVER_CARD_NAME}`,
            entity: covers[0],
        };
    }
    get _nextControl() {
        var _a;
        if (this._activeControl) {
            return ((_a = this._controls[this._controls.indexOf(this._activeControl) + 1]) !== null && _a !== void 0 ? _a : this._controls[0]);
        }
        return undefined;
    }
    _onNextControlTap(e) {
        e.stopPropagation();
        this._activeControl = this._nextControl;
    }
    getCardSize() {
        return 1;
    }
    setConfig(config) {
        var _a, _b, _c;
        this._config = Object.assign({ tap_action: {
                action: "toggle",
            }, hold_action: {
                action: "more-info",
            } }, config);
        const controls = [];
        if ((_a = this._config) === null || _a === void 0 ? void 0 : _a.show_buttons_control) {
            controls.push("buttons_control");
        }
        if ((_b = this._config) === null || _b === void 0 ? void 0 : _b.show_position_control) {
            controls.push("position_control");
        }
        if ((_c = this._config) === null || _c === void 0 ? void 0 : _c.show_tilt_position_control) {
            controls.push("tilt_position_control");
        }
        this._controls = controls;
        this._activeControl = controls[0];
        this.updatePosition();
    }
    updated(changedProperties) {
        super.updated(changedProperties);
        if (this.hass && changedProperties.has("hass")) {
            this.updatePosition();
        }
    }
    updatePosition() {
        this.position = undefined;
        if (!this._config || !this.hass || !this._config.entity)
            return;
        const entity_id = this._config.entity;
        const entity = this.hass.states[entity_id];
        if (!entity)
            return;
        this.position = getPosition(entity);
    }
    onCurrentPositionChange(e) {
        if (e.detail.value != null) {
            this.position = e.detail.value;
        }
    }
    _handleAction(ev) {
        handleAction(this, this.hass, this._config, ev.detail.action);
    }
    render() {
        if (!this.hass || !this._config || !this._config.entity) {
            return $ ``;
        }
        const entity_id = this._config.entity;
        const entity = this.hass.states[entity_id];
        const name = this._config.name || entity.attributes.friendly_name || "";
        const icon = this._config.icon || stateIcon(entity);
        const appearance = computeAppearance(this._config);
        const picture = computeEntityPicture(entity, appearance.icon_type);
        let stateDisplay = computeStateDisplay(this.hass.localize, entity, this.hass.locale, this.hass.entities);
        if (this.position) {
            stateDisplay += ` - ${this.position}%`;
        }
        const rtl = computeRTL(this.hass);
        return $ `
            <ha-card class=${o({ "fill-container": appearance.fill_container })}>
                <mushroom-card .appearance=${appearance} ?rtl=${rtl}>
                    <mushroom-state-item
                        ?rtl=${rtl}
                        .appearance=${appearance}
                        @action=${this._handleAction}
                        .actionHandler=${actionHandler({
            hasHold: hasAction(this._config.hold_action),
            hasDoubleClick: hasAction(this._config.double_tap_action),
        })}
                    >
                        ${picture ? this.renderPicture(picture) : this.renderIcon(entity, icon)}
                        ${this.renderBadge(entity)}
                        ${this.renderStateInfo(entity, appearance, name, stateDisplay)};
                    </mushroom-state-item>
                    ${this._controls.length > 0
            ? $ `
                              <div class="actions" ?rtl=${rtl}>
                                  ${this.renderActiveControl(entity, appearance.layout)}
                                  ${this.renderNextControlButton()}
                              </div>
                          `
            : null}
                </mushroom-card>
            </ha-card>
        `;
    }
    renderIcon(entity, icon) {
        const iconStyle = {};
        const available = isAvailable(entity);
        const color = getStateColor$2(entity);
        iconStyle["--icon-color"] = `rgb(${color})`;
        iconStyle["--shape-color"] = `rgba(${color}, 0.2)`;
        return $ `
            <mushroom-shape-icon
                slot="icon"
                .disabled=${!available}
                .icon=${icon}
                style=${i$2(iconStyle)}
            ></mushroom-shape-icon>
        `;
    }
    renderNextControlButton() {
        if (!this._nextControl || this._nextControl == this._activeControl)
            return null;
        return $ `
            <mushroom-button
                .icon=${CONTROLS_ICONS$2[this._nextControl]}
                @click=${this._onNextControlTap}
            />
        `;
    }
    renderActiveControl(entity, layout) {
        switch (this._activeControl) {
            case "buttons_control":
                return $ `
                    <mushroom-cover-buttons-control
                        .hass=${this.hass}
                        .entity=${entity}
                        .fill=${layout !== "horizontal"}
                    />
                `;
            case "position_control": {
                const color = getStateColor$2(entity);
                const sliderStyle = {};
                sliderStyle["--slider-color"] = `rgb(${color})`;
                sliderStyle["--slider-bg-color"] = `rgba(${color}, 0.2)`;
                return $ `
                    <mushroom-cover-position-control
                        .hass=${this.hass}
                        .entity=${entity}
                        @current-change=${this.onCurrentPositionChange}
                        style=${i$2(sliderStyle)}
                    />
                `;
            }
            case "tilt_position_control": {
                const color = getStateColor$2(entity);
                const sliderStyle = {};
                sliderStyle["--slider-color"] = `rgb(${color})`;
                sliderStyle["--slider-bg-color"] = `rgba(${color}, 0.2)`;
                return $ `
                    <mushroom-cover-tilt-position-control
                        .hass=${this.hass}
                        .entity=${entity}
                        style=${i$2(sliderStyle)}
                    />
                `;
            }
            default:
                return null;
        }
    }
    static get styles() {
        return [
            super.styles,
            cardStyle,
            r$3 `
                mushroom-state-item {
                    cursor: pointer;
                }
                mushroom-shape-icon {
                    --icon-color: rgb(var(--rgb-state-cover));
                    --shape-color: rgba(var(--rgb-state-cover), 0.2);
                }
                mushroom-cover-buttons-control,
                mushroom-cover-position-control {
                    flex: 1;
                }
                mushroom-cover-tilt-position-control {
                    flex: 1;
                }
            `,
        ];
    }
};
__decorate([
    t$1()
], CoverCard.prototype, "_config", void 0);
__decorate([
    t$1()
], CoverCard.prototype, "_activeControl", void 0);
__decorate([
    t$1()
], CoverCard.prototype, "_controls", void 0);
__decorate([
    t$1()
], CoverCard.prototype, "position", void 0);
CoverCard = __decorate([
    n$1(COVER_CARD_NAME)
], CoverCard);

const ENTITY_CARD_NAME = `${PREFIX_NAME}-entity-card`;
const ENTITY_CARD_EDITOR_NAME = `${ENTITY_CARD_NAME}-editor`;

registerCustomCard({
    type: ENTITY_CARD_NAME,
    name: "Mushroom Entity Card",
    description: "Card for all entities",
});
let EntityCard = class EntityCard extends MushroomBaseCard {
    static async getConfigElement() {
        await Promise.resolve().then(function () { return entityCardEditor; });
        return document.createElement(ENTITY_CARD_EDITOR_NAME);
    }
    static async getStubConfig(hass) {
        const entities = Object.keys(hass.states);
        return {
            type: `custom:${ENTITY_CARD_NAME}`,
            entity: entities[0],
        };
    }
    getCardSize() {
        return 1;
    }
    setConfig(config) {
        this._config = Object.assign({ tap_action: {
                action: "more-info",
            }, hold_action: {
                action: "more-info",
            } }, config);
    }
    _handleAction(ev) {
        handleAction(this, this.hass, this._config, ev.detail.action);
    }
    render() {
        if (!this._config || !this.hass || !this._config.entity) {
            return $ ``;
        }
        const entityId = this._config.entity;
        const entity = this.hass.states[entityId];
        const name = this._config.name || entity.attributes.friendly_name || "";
        const icon = this._config.icon || stateIcon(entity);
        const appearance = computeAppearance(this._config);
        const picture = computeEntityPicture(entity, appearance.icon_type);
        const rtl = computeRTL(this.hass);
        return $ `
            <ha-card class=${o({ "fill-container": appearance.fill_container })}>
                <mushroom-card .appearance=${appearance} ?rtl=${rtl}>
                    <mushroom-state-item
                        ?rtl=${rtl}
                        .appearance=${appearance}
                        @action=${this._handleAction}
                        .actionHandler=${actionHandler({
            hasHold: hasAction(this._config.hold_action),
            hasDoubleClick: hasAction(this._config.double_tap_action),
        })}
                    >
                        ${picture ? this.renderPicture(picture) : this.renderIcon(entity, icon)}
                        ${this.renderBadge(entity)}
                        ${this.renderStateInfo(entity, appearance, name)};
                    </mushroom-state-item>
                </mushroom-card>
            </ha-card>
        `;
    }
    renderIcon(entity, icon) {
        var _a;
        const active = isActive(entity);
        const iconStyle = {};
        const iconColor = (_a = this._config) === null || _a === void 0 ? void 0 : _a.icon_color;
        if (iconColor) {
            const iconRgbColor = computeRgbColor(iconColor);
            iconStyle["--icon-color"] = `rgb(${iconRgbColor})`;
            iconStyle["--shape-color"] = `rgba(${iconRgbColor}, 0.2)`;
        }
        return $ `
            <mushroom-shape-icon
                slot="icon"
                .disabled=${!active}
                .icon=${icon}
                style=${i$2(iconStyle)}
            ></mushroom-shape-icon>
        `;
    }
    static get styles() {
        return [
            super.styles,
            cardStyle,
            r$3 `
                mushroom-state-item {
                    cursor: pointer;
                }
                mushroom-shape-icon {
                    --icon-color: rgb(var(--rgb-state-entity));
                    --shape-color: rgba(var(--rgb-state-entity), 0.2);
                }
            `,
        ];
    }
};
__decorate([
    t$1()
], EntityCard.prototype, "_config", void 0);
EntityCard = __decorate([
    n$1(ENTITY_CARD_NAME)
], EntityCard);

const FAN_CARD_NAME = `${PREFIX_NAME}-fan-card`;
const FAN_CARD_EDITOR_NAME = `${FAN_CARD_NAME}-editor`;
const FAN_ENTITY_DOMAINS = ["fan"];

function getPercentage(entity) {
    return entity.attributes.percentage != null
        ? Math.round(entity.attributes.percentage)
        : undefined;
}
function isOscillating(entity) {
    return entity.attributes.oscillating != null ? Boolean(entity.attributes.oscillating) : false;
}
function computePercentageStep(entity) {
    if (entity.attributes.percentage_step) {
        return entity.attributes.percentage_step;
    }
    return 1;
}

let FanPercentageControl$1 = class FanPercentageControl extends s$1 {
    _onTap(e) {
        e.stopPropagation();
        const oscillating = isOscillating(this.entity);
        this.hass.callService("fan", "oscillate", {
            entity_id: this.entity.entity_id,
            oscillating: !oscillating,
        });
    }
    render() {
        const oscillating = isOscillating(this.entity);
        const active = isActive(this.entity);
        return $ `
            <mushroom-button
                class=${o({ active: oscillating })}
                .icon=${"mdi:sync"}
                @click=${this._onTap}
                .disabled=${!active}
            />
        `;
    }
    static get styles() {
        return r$3 `
            :host {
                display: flex;
            }
            mushroom-button.active {
                --icon-color: rgb(var(--rgb-state-fan));
                --bg-color: rgba(var(--rgb-state-fan), 0.2);
            }
        `;
    }
};
__decorate([
    e$3({ attribute: false })
], FanPercentageControl$1.prototype, "hass", void 0);
__decorate([
    e$3({ attribute: false })
], FanPercentageControl$1.prototype, "entity", void 0);
FanPercentageControl$1 = __decorate([
    n$1("mushroom-fan-oscillate-control")
], FanPercentageControl$1);

let FanPercentageControl = class FanPercentageControl extends s$1 {
    onChange(e) {
        const value = e.detail.value;
        this.hass.callService("fan", "set_percentage", {
            entity_id: this.entity.entity_id,
            percentage: value,
        });
    }
    onCurrentChange(e) {
        const value = e.detail.value;
        this.dispatchEvent(new CustomEvent("current-change", {
            detail: {
                value,
            },
        }));
    }
    render() {
        const percentage = getPercentage(this.entity);
        return $ `
            <mushroom-slider
                .value=${percentage}
                .disabled=${!isAvailable(this.entity)}
                .inactive=${!isActive(this.entity)}
                .showActive=${true}
                @change=${this.onChange}
                @current-change=${this.onCurrentChange}
                step=${computePercentageStep(this.entity)}
            />
        `;
    }
    static get styles() {
        return r$3 `
            mushroom-slider {
                --main-color: rgb(var(--rgb-state-fan));
                --bg-color: rgba(var(--rgb-state-fan), 0.2);
            }
        `;
    }
};
__decorate([
    e$3({ attribute: false })
], FanPercentageControl.prototype, "hass", void 0);
__decorate([
    e$3({ attribute: false })
], FanPercentageControl.prototype, "entity", void 0);
FanPercentageControl = __decorate([
    n$1("mushroom-fan-percentage-control")
], FanPercentageControl);

registerCustomCard({
    type: FAN_CARD_NAME,
    name: "Mushroom Fan Card",
    description: "Card for fan entity",
});
let FanCard = class FanCard extends MushroomBaseCard {
    static async getConfigElement() {
        await Promise.resolve().then(function () { return fanCardEditor; });
        return document.createElement(FAN_CARD_EDITOR_NAME);
    }
    static async getStubConfig(hass) {
        const entities = Object.keys(hass.states);
        const fans = entities.filter((e) => FAN_ENTITY_DOMAINS.includes(e.split(".")[0]));
        return {
            type: `custom:${FAN_CARD_NAME}`,
            entity: fans[0],
        };
    }
    getCardSize() {
        return 1;
    }
    setConfig(config) {
        this._config = Object.assign({ tap_action: {
                action: "toggle",
            }, hold_action: {
                action: "more-info",
            } }, config);
        this.updatePercentage();
    }
    updated(changedProperties) {
        super.updated(changedProperties);
        if (this.hass && changedProperties.has("hass")) {
            this.updatePercentage();
        }
    }
    updatePercentage() {
        this.percentage = undefined;
        if (!this._config || !this.hass || !this._config.entity)
            return;
        const entity_id = this._config.entity;
        const entity = this.hass.states[entity_id];
        if (!entity)
            return;
        this.percentage = getPercentage(entity);
    }
    onCurrentPercentageChange(e) {
        if (e.detail.value != null) {
            this.percentage = Math.round(e.detail.value);
        }
    }
    _handleAction(ev) {
        handleAction(this, this.hass, this._config, ev.detail.action);
    }
    render() {
        if (!this._config || !this.hass || !this._config.entity) {
            return $ ``;
        }
        const entity_id = this._config.entity;
        const entity = this.hass.states[entity_id];
        const name = this._config.name || entity.attributes.friendly_name || "";
        const icon = this._config.icon || stateIcon(entity);
        const appearance = computeAppearance(this._config);
        const picture = computeEntityPicture(entity, appearance.icon_type);
        let stateDisplay = computeStateDisplay(this.hass.localize, entity, this.hass.locale, this.hass.entities);
        if (this.percentage != null) {
            stateDisplay = `${this.percentage}%`;
        }
        const rtl = computeRTL(this.hass);
        const displayControls = (!this._config.collapsible_controls || isActive(entity)) &&
            (this._config.show_percentage_control || this._config.show_oscillate_control);
        return $ `
            <ha-card class=${o({ "fill-container": appearance.fill_container })}>
                <mushroom-card .appearance=${appearance} ?rtl=${rtl}>
                    <mushroom-state-item
                        ?rtl=${rtl}
                        .appearance=${appearance}
                        @action=${this._handleAction}
                        .actionHandler=${actionHandler({
            hasHold: hasAction(this._config.hold_action),
            hasDoubleClick: hasAction(this._config.double_tap_action),
        })}
                    >
                        ${picture ? this.renderPicture(picture) : this.renderIcon(entity, icon)}
                        ${this.renderBadge(entity)}
                        ${this.renderStateInfo(entity, appearance, name, stateDisplay)};
                    </mushroom-state-item>
                    ${displayControls
            ? $ `
                              <div class="actions" ?rtl=${rtl}>
                                  ${this._config.show_percentage_control
                ? $ `
                                            <mushroom-fan-percentage-control
                                                .hass=${this.hass}
                                                .entity=${entity}
                                                @current-change=${this.onCurrentPercentageChange}
                                            ></mushroom-fan-percentage-control>
                                        `
                : null}
                                  ${this._config.show_oscillate_control
                ? $ `
                                            <mushroom-fan-oscillate-control
                                                .hass=${this.hass}
                                                .entity=${entity}
                                            ></mushroom-fan-oscillate-control>
                                        `
                : null}
                              </div>
                          `
            : null}
                </mushroom-card>
            </ha-card>
        `;
    }
    renderIcon(entity, icon) {
        var _a;
        let iconStyle = {};
        const percentage = getPercentage(entity);
        const active = isActive(entity);
        if (active) {
            if (percentage) {
                const speed = 1.5 * (percentage / 100) ** 0.5;
                iconStyle["--animation-duration"] = `${1 / speed}s`;
            }
            else {
                iconStyle["--animation-duration"] = `1s`;
            }
        }
        return $ `
            <mushroom-shape-icon
                slot="icon"
                class=${o({
            spin: active && Boolean((_a = this._config) === null || _a === void 0 ? void 0 : _a.icon_animation),
        })}
                style=${i$2(iconStyle)}
                .disabled=${!active}
                .icon=${icon}
            ></mushroom-shape-icon>
        `;
    }
    static get styles() {
        return [
            super.styles,
            cardStyle,
            r$3 `
                mushroom-state-item {
                    cursor: pointer;
                }
                mushroom-shape-icon {
                    --icon-color: rgb(var(--rgb-state-fan));
                    --shape-color: rgba(var(--rgb-state-fan), 0.2);
                }
                mushroom-shape-icon.spin {
                    --icon-animation: var(--animation-duration) infinite linear spin;
                }
                mushroom-shape-icon ha-icon {
                    color: red !important;
                }
                mushroom-fan-percentage-control {
                    flex: 1;
                }
            `,
        ];
    }
};
__decorate([
    t$1()
], FanCard.prototype, "_config", void 0);
__decorate([
    t$1()
], FanCard.prototype, "percentage", void 0);
FanCard = __decorate([
    n$1(FAN_CARD_NAME)
], FanCard);

const HUMIDIFIER_CARD_NAME = `${PREFIX_NAME}-humidifier-card`;
const HUMIDIFIER_CARD_EDITOR_NAME = `${HUMIDIFIER_CARD_NAME}-editor`;
const HUMIDIFIER_ENTITY_DOMAINS = ["humidifier"];

let HumidifierHumidityControl = class HumidifierHumidityControl extends s$1 {
    onChange(e) {
        const value = e.detail.value;
        this.hass.callService("humidifier", "set_humidity", {
            entity_id: this.entity.entity_id,
            humidity: value,
        });
    }
    onCurrentChange(e) {
        const value = e.detail.value;
        this.dispatchEvent(new CustomEvent("current-change", {
            detail: {
                value,
            },
        }));
    }
    render() {
        const max = this.entity.attributes.max_humidity || 100;
        const min = this.entity.attributes.min_humidity || 0;
        return $ `<mushroom-slider
            .value=${this.entity.attributes.humidity}
            .disabled=${!isAvailable(this.entity)}
            .inactive=${!isActive(this.entity)}
            .showActive=${true}
            .min=${min}
            .max=${max}
            @change=${this.onChange}
            @current-change=${this.onCurrentChange}
        />`;
    }
    static get styles() {
        return r$3 `
            mushroom-slider {
                --main-color: rgb(var(--rgb-state-humidifier));
                --bg-color: rgba(var(--rgb-state-humidifier), 0.2);
            }
        `;
    }
};
__decorate([
    e$3({ attribute: false })
], HumidifierHumidityControl.prototype, "hass", void 0);
__decorate([
    e$3({ attribute: false })
], HumidifierHumidityControl.prototype, "entity", void 0);
__decorate([
    e$3({ attribute: false })
], HumidifierHumidityControl.prototype, "color", void 0);
HumidifierHumidityControl = __decorate([
    n$1("mushroom-humidifier-humidity-control")
], HumidifierHumidityControl);

registerCustomCard({
    type: HUMIDIFIER_CARD_NAME,
    name: "Mushroom Humidifier Card",
    description: "Card for humidifier entity",
});
let HumidifierCard = class HumidifierCard extends MushroomBaseCard {
    static async getConfigElement() {
        await Promise.resolve().then(function () { return humidifierCardEditor; });
        return document.createElement(HUMIDIFIER_CARD_EDITOR_NAME);
    }
    static async getStubConfig(hass) {
        const entities = Object.keys(hass.states);
        const humidifiers = entities.filter((e) => HUMIDIFIER_ENTITY_DOMAINS.includes(e.split(".")[0]));
        return {
            type: `custom:${HUMIDIFIER_CARD_NAME}`,
            entity: humidifiers[0],
        };
    }
    getCardSize() {
        return 1;
    }
    setConfig(config) {
        this._config = Object.assign({ tap_action: {
                action: "toggle",
            }, hold_action: {
                action: "more-info",
            } }, config);
    }
    _handleAction(ev) {
        handleAction(this, this.hass, this._config, ev.detail.action);
    }
    onCurrentHumidityChange(e) {
        if (e.detail.value != null) {
            this.humidity = e.detail.value;
        }
    }
    render() {
        if (!this._config || !this.hass || !this._config.entity) {
            return $ ``;
        }
        const entity_id = this._config.entity;
        const entity = this.hass.states[entity_id];
        const name = this._config.name || entity.attributes.friendly_name || "";
        const icon = this._config.icon || stateIcon(entity);
        const appearance = computeAppearance(this._config);
        const picture = computeEntityPicture(entity, appearance.icon_type);
        let stateDisplay = computeStateDisplay(this.hass.localize, entity, this.hass.locale, this.hass.entities);
        if (this.humidity) {
            stateDisplay = `${this.humidity} %`;
        }
        const rtl = computeRTL(this.hass);
        const displayControls = (!this._config.collapsible_controls || isActive(entity)) &&
            this._config.show_target_humidity_control;
        return $ `
            <ha-card class=${o({ "fill-container": appearance.fill_container })}>
                <mushroom-card .appearance=${appearance} ?rtl=${rtl}>
                    <mushroom-state-item
                        ?rtl=${rtl}
                        .appearance=${appearance}
                        @action=${this._handleAction}
                        .actionHandler=${actionHandler({
            hasHold: hasAction(this._config.hold_action),
            hasDoubleClick: hasAction(this._config.double_tap_action),
        })}
                    >
                        ${picture ? this.renderPicture(picture) : this.renderIcon(entity, icon)}
                        ${this.renderBadge(entity)}
                        ${this.renderStateInfo(entity, appearance, name, stateDisplay)};
                    </mushroom-state-item>
                    ${displayControls
            ? $ `
                              <div class="actions" ?rtl=${rtl}>
                                  <mushroom-humidifier-humidity-control
                                      .hass=${this.hass}
                                      .entity=${entity}
                                      @current-change=${this.onCurrentHumidityChange}
                                  ></mushroom-humidifier-humidity-control>
                              </div>
                          `
            : null}
                </mushroom-card>
            </ha-card>
        `;
    }
    static get styles() {
        return [
            super.styles,
            cardStyle,
            r$3 `
                mushroom-state-item {
                    cursor: pointer;
                }
                mushroom-shape-icon {
                    --icon-color: rgb(var(--rgb-state-humidifier));
                    --shape-color: rgba(var(--rgb-state-humidifier), 0.2);
                }
                mushroom-humidifier-humidity-control {
                    flex: 1;
                }
            `,
        ];
    }
};
__decorate([
    t$1()
], HumidifierCard.prototype, "_config", void 0);
__decorate([
    t$1()
], HumidifierCard.prototype, "humidity", void 0);
HumidifierCard = __decorate([
    n$1(HUMIDIFIER_CARD_NAME)
], HumidifierCard);

const LIGHT_CARD_NAME = `${PREFIX_NAME}-light-card`;
const LIGHT_CARD_EDITOR_NAME = `${LIGHT_CARD_NAME}-editor`;
const LIGHT_ENTITY_DOMAINS = ["light"];

let LightBrighnessControl = class LightBrighnessControl extends s$1 {
    onChange(e) {
        const value = e.detail.value;
        this.hass.callService("light", "turn_on", {
            entity_id: this.entity.entity_id,
            brightness_pct: value,
        });
    }
    onCurrentChange(e) {
        const value = e.detail.value;
        this.dispatchEvent(new CustomEvent("current-change", {
            detail: {
                value,
            },
        }));
    }
    render() {
        const brightness = getBrightness(this.entity);
        return $ `
            <mushroom-slider
                .value=${brightness}
                .disabled=${!isAvailable(this.entity)}
                .inactive=${!isActive(this.entity)}
                .showActive=${true}
                @change=${this.onChange}
                @current-change=${this.onCurrentChange}
            />
        `;
    }
    static get styles() {
        return r$3 `
            :host {
                --slider-color: rgb(var(--rgb-state-light));
                --slider-outline-color: transparent;
                --slider-bg-color: rgba(var(--rgb-state-light), 0.2);
            }
            mushroom-slider {
                --main-color: var(--slider-color);
                --bg-color: var(--slider-bg-color);
                --main-outline-color: var(--slider-outline-color);
            }
        `;
    }
};
__decorate([
    e$3({ attribute: false })
], LightBrighnessControl.prototype, "hass", void 0);
__decorate([
    e$3({ attribute: false })
], LightBrighnessControl.prototype, "entity", void 0);
LightBrighnessControl = __decorate([
    n$1("mushroom-light-brightness-control")
], LightBrighnessControl);

const GRADIENT = [
    [0, "#f00"],
    [0.17, "#ff0"],
    [0.33, "#0f0"],
    [0.5, "#0ff"],
    [0.66, "#00f"],
    [0.83, "#f0f"],
    [1, "#f00"],
];
let LightColorControl = class LightColorControl extends s$1 {
    constructor() {
        super(...arguments);
        this._percent = 0;
    }
    _percentToRGB(percent) {
        const color$1 = color.hsv(360 * percent, 100, 100);
        return color$1.rgb().array();
    }
    _rgbToPercent(rgb) {
        const color$1 = color.rgb(rgb);
        return color$1.hsv().hue() / 360;
    }
    onChange(e) {
        const value = e.detail.value;
        this._percent = value;
        const rgb_color = this._percentToRGB(value / 100);
        if (rgb_color.length === 3) {
            this.hass.callService("light", "turn_on", {
                entity_id: this.entity.entity_id,
                rgb_color,
            });
        }
    }
    render() {
        const colorPercent = this._percent || this._rgbToPercent(this.entity.attributes.rgb_color) * 100;
        return $ `
            <mushroom-slider
                .value=${colorPercent}
                .disabled=${!isAvailable(this.entity)}
                .inactive=${!isActive(this.entity)}
                .min=${0}
                .max=${100}
                .showIndicator=${true}
                @change=${this.onChange}
            />
        `;
    }
    static get styles() {
        const gradient = GRADIENT.map(([stop, color]) => `${color} ${stop * 100}%`).join(", ");
        return r$3 `
            mushroom-slider {
                --gradient: -webkit-linear-gradient(left, ${o$5(gradient)});
            }
        `;
    }
};
__decorate([
    e$3({ attribute: false })
], LightColorControl.prototype, "hass", void 0);
__decorate([
    e$3({ attribute: false })
], LightColorControl.prototype, "entity", void 0);
LightColorControl = __decorate([
    n$1("mushroom-light-color-control")
], LightColorControl);

let LightColorTempControl = class LightColorTempControl extends s$1 {
    onChange(e) {
        const value = e.detail.value;
        this.hass.callService("light", "turn_on", {
            entity_id: this.entity.entity_id,
            color_temp: value,
        });
    }
    render() {
        var _a, _b;
        const colorTemp = getColorTemp(this.entity);
        return $ `
            <mushroom-slider
                .value=${colorTemp}
                .disabled=${!isAvailable(this.entity)}
                .inactive=${!isActive(this.entity)}
                .min=${(_a = this.entity.attributes.min_mireds) !== null && _a !== void 0 ? _a : 0}
                .max=${(_b = this.entity.attributes.max_mireds) !== null && _b !== void 0 ? _b : 100}
                .showIndicator=${true}
                @change=${this.onChange}
            />
        `;
    }
    static get styles() {
        return r$3 `
            mushroom-slider {
                --gradient: -webkit-linear-gradient(right, rgb(255, 160, 0) 0%, white 100%);
            }
        `;
    }
};
__decorate([
    e$3({ attribute: false })
], LightColorTempControl.prototype, "hass", void 0);
__decorate([
    e$3({ attribute: false })
], LightColorTempControl.prototype, "entity", void 0);
LightColorTempControl = __decorate([
    n$1("mushroom-light-color-temp-control")
], LightColorTempControl);

const CONTROLS_ICONS$1 = {
    brightness_control: "mdi:brightness-4",
    color_temp_control: "mdi:thermometer",
    color_control: "mdi:palette",
};
registerCustomCard({
    type: LIGHT_CARD_NAME,
    name: "Mushroom Light Card",
    description: "Card for light entity",
});
let LightCard = class LightCard extends MushroomBaseCard {
    constructor() {
        super(...arguments);
        this._controls = [];
    }
    static async getConfigElement() {
        await Promise.resolve().then(function () { return lightCardEditor; });
        return document.createElement(LIGHT_CARD_EDITOR_NAME);
    }
    static async getStubConfig(hass) {
        const entities = Object.keys(hass.states);
        const lights = entities.filter((e) => LIGHT_ENTITY_DOMAINS.includes(e.split(".")[0]));
        return {
            type: `custom:${LIGHT_CARD_NAME}`,
            entity: lights[0],
        };
    }
    _onControlTap(ctrl, e) {
        e.stopPropagation();
        this._activeControl = ctrl;
    }
    getCardSize() {
        return 1;
    }
    setConfig(config) {
        this._config = Object.assign({ tap_action: {
                action: "toggle",
            }, hold_action: {
                action: "more-info",
            } }, config);
        this.updateControls();
        this.updateBrightness();
    }
    updated(changedProperties) {
        super.updated(changedProperties);
        if (this.hass && changedProperties.has("hass")) {
            this.updateControls();
            this.updateBrightness();
        }
    }
    updateBrightness() {
        this.brightness = undefined;
        if (!this._config || !this.hass || !this._config.entity)
            return;
        const entity_id = this._config.entity;
        const entity = this.hass.states[entity_id];
        if (!entity)
            return;
        this.brightness = getBrightness(entity);
    }
    onCurrentBrightnessChange(e) {
        if (e.detail.value != null) {
            this.brightness = e.detail.value;
        }
    }
    updateControls() {
        if (!this._config || !this.hass || !this._config.entity)
            return;
        const entity_id = this._config.entity;
        const entity = this.hass.states[entity_id];
        if (!entity)
            return;
        const controls = [];
        if (!this._config.collapsible_controls || isActive(entity)) {
            if (this._config.show_brightness_control && supportsBrightnessControl(entity)) {
                controls.push("brightness_control");
            }
            if (this._config.show_color_temp_control && supportsColorTempControl(entity)) {
                controls.push("color_temp_control");
            }
            if (this._config.show_color_control && supportsColorControl(entity)) {
                controls.push("color_control");
            }
        }
        this._controls = controls;
        const isActiveControlSupported = this._activeControl
            ? controls.includes(this._activeControl)
            : false;
        this._activeControl = isActiveControlSupported ? this._activeControl : controls[0];
    }
    _handleAction(ev) {
        handleAction(this, this.hass, this._config, ev.detail.action);
    }
    render() {
        if (!this._config || !this.hass || !this._config.entity) {
            return $ ``;
        }
        const entity_id = this._config.entity;
        const entity = this.hass.states[entity_id];
        const name = this._config.name || entity.attributes.friendly_name || "";
        const icon = this._config.icon || stateIcon(entity);
        const appearance = computeAppearance(this._config);
        const picture = computeEntityPicture(entity, appearance.icon_type);
        let stateDisplay = computeStateDisplay(this.hass.localize, entity, this.hass.locale, this.hass.entities);
        if (this.brightness != null) {
            stateDisplay = `${this.brightness}%`;
        }
        const rtl = computeRTL(this.hass);
        return $ `
            <ha-card class=${o({ "fill-container": appearance.fill_container })}>
                <mushroom-card .appearance=${appearance} ?rtl=${rtl}>
                    <mushroom-state-item
                        ?rtl=${rtl}
                        .appearance=${appearance}
                        @action=${this._handleAction}
                        .actionHandler=${actionHandler({
            hasHold: hasAction(this._config.hold_action),
            hasDoubleClick: hasAction(this._config.double_tap_action),
        })}
                    >
                        ${picture ? this.renderPicture(picture) : this.renderIcon(entity, icon)}
                        ${this.renderBadge(entity)}
                        ${this.renderStateInfo(entity, appearance, name, stateDisplay)};
                    </mushroom-state-item>
                    ${this._controls.length > 0
            ? $ `
                              <div class="actions" ?rtl=${rtl}>
                                  ${this.renderActiveControl(entity)} ${this.renderOtherControls()}
                              </div>
                          `
            : null}
                </mushroom-card>
            </ha-card>
        `;
    }
    renderIcon(entity, icon) {
        var _a, _b;
        const lightRgbColor = getRGBColor(entity);
        const active = isActive(entity);
        const iconStyle = {};
        const iconColor = (_a = this._config) === null || _a === void 0 ? void 0 : _a.icon_color;
        if (lightRgbColor && ((_b = this._config) === null || _b === void 0 ? void 0 : _b.use_light_color)) {
            const color = lightRgbColor.join(",");
            iconStyle["--icon-color"] = `rgb(${color})`;
            iconStyle["--shape-color"] = `rgba(${color}, 0.25)`;
            if (isColorLight(lightRgbColor) && !this.hass.themes.darkMode) {
                iconStyle["--shape-outline-color"] = `rgba(var(--rgb-primary-text-color), 0.05)`;
                if (isColorSuperLight(lightRgbColor)) {
                    iconStyle["--icon-color"] = `rgba(var(--rgb-primary-text-color), 0.2)`;
                }
            }
        }
        else if (iconColor) {
            const iconRgbColor = computeRgbColor(iconColor);
            iconStyle["--icon-color"] = `rgb(${iconRgbColor})`;
            iconStyle["--shape-color"] = `rgba(${iconRgbColor}, 0.2)`;
        }
        return $ `
            <mushroom-shape-icon
                slot="icon"
                .disabled=${!active}
                .icon=${icon}
                style=${i$2(iconStyle)}
            ></mushroom-shape-icon>
        `;
    }
    renderOtherControls() {
        const otherControls = this._controls.filter((control) => control != this._activeControl);
        return $ `
            ${otherControls.map((ctrl) => $ `
                    <mushroom-button
                        .icon=${CONTROLS_ICONS$1[ctrl]}
                        @click=${(e) => this._onControlTap(ctrl, e)}
                    />
                `)}
        `;
    }
    renderActiveControl(entity) {
        var _a, _b;
        switch (this._activeControl) {
            case "brightness_control":
                const lightRgbColor = getRGBColor(entity);
                const sliderStyle = {};
                const iconColor = (_a = this._config) === null || _a === void 0 ? void 0 : _a.icon_color;
                if (lightRgbColor && ((_b = this._config) === null || _b === void 0 ? void 0 : _b.use_light_color)) {
                    const color = lightRgbColor.join(",");
                    sliderStyle["--slider-color"] = `rgb(${color})`;
                    sliderStyle["--slider-bg-color"] = `rgba(${color}, 0.2)`;
                    if (isColorLight(lightRgbColor) && !this.hass.themes.darkMode) {
                        sliderStyle["--slider-bg-color"] = `rgba(var(--rgb-primary-text-color), 0.05)`;
                        sliderStyle["--slider-color"] = `rgba(var(--rgb-primary-text-color), 0.15)`;
                    }
                }
                else if (iconColor) {
                    const iconRgbColor = computeRgbColor(iconColor);
                    sliderStyle["--slider-color"] = `rgb(${iconRgbColor})`;
                    sliderStyle["--slider-bg-color"] = `rgba(${iconRgbColor}, 0.2)`;
                }
                return $ `
                    <mushroom-light-brightness-control
                        .hass=${this.hass}
                        .entity=${entity}
                        style=${i$2(sliderStyle)}
                        @current-change=${this.onCurrentBrightnessChange}
                    />
                `;
            case "color_temp_control":
                return $ `
                    <mushroom-light-color-temp-control .hass=${this.hass} .entity=${entity} />
                `;
            case "color_control":
                return $ `
                    <mushroom-light-color-control .hass=${this.hass} .entity=${entity} />
                `;
            default:
                return null;
        }
    }
    static get styles() {
        return [
            super.styles,
            cardStyle,
            r$3 `
                mushroom-state-item {
                    cursor: pointer;
                }
                mushroom-shape-icon {
                    --icon-color: rgb(var(--rgb-state-light));
                    --shape-color: rgba(var(--rgb-state-light), 0.2);
                }
                mushroom-light-brightness-control,
                mushroom-light-color-temp-control,
                mushroom-light-color-control {
                    flex: 1;
                }
            `,
        ];
    }
};
__decorate([
    t$1()
], LightCard.prototype, "_config", void 0);
__decorate([
    t$1()
], LightCard.prototype, "_activeControl", void 0);
__decorate([
    t$1()
], LightCard.prototype, "_controls", void 0);
__decorate([
    t$1()
], LightCard.prototype, "brightness", void 0);
LightCard = __decorate([
    n$1(LIGHT_CARD_NAME)
], LightCard);

const LOCK_CARD_NAME = `${PREFIX_NAME}-lock-card`;
const LOCK_CARD_EDITOR_NAME = `${LOCK_CARD_NAME}-editor`;
const LOCK_ENTITY_DOMAINS = ["lock"];

function isUnlocked(entity) {
    return entity.state === LOCK_STATE_UNLOCKED;
}
function isLocked(entity) {
    return entity.state === LOCK_STATE_LOCKED;
}
function isActionPending(entity) {
    switch (entity.state) {
        case LOCK_STATE_LOCKING:
        case LOCK_STATE_UNLOCKING:
            return true;
        default:
            return false;
    }
}

const LOCK_BUTTONS = [
    {
        icon: "mdi:lock",
        title: "lock",
        serviceName: "lock",
        isVisible: (entity) => isUnlocked(entity),
        isDisabled: () => false,
    },
    {
        icon: "mdi:lock-open",
        title: "unlock",
        serviceName: "unlock",
        isVisible: (entity) => isLocked(entity),
        isDisabled: () => false,
    },
    {
        icon: "mdi:lock-clock",
        isVisible: (entity) => isActionPending(entity),
        isDisabled: () => true,
    },
    {
        icon: "mdi:door-open",
        title: "open",
        serviceName: "open",
        isVisible: (entity) => supportsFeature(entity, LOCK_SUPPORT_OPEN) && isUnlocked(entity),
        isDisabled: (entity) => isActionPending(entity),
    },
];
let LockButtonsControl = class LockButtonsControl extends s$1 {
    constructor() {
        super(...arguments);
        this.fill = false;
    }
    callService(e) {
        e.stopPropagation();
        const entry = e.target.entry;
        this.hass.callService("lock", entry.serviceName, {
            entity_id: this.entity.entity_id,
        });
    }
    render() {
        const rtl = computeRTL(this.hass);
        const customLocalize = setupCustomlocalize(this.hass);
        return $ `
            <mushroom-button-group .fill=${this.fill} ?rtl=${rtl}
                >${LOCK_BUTTONS.filter((item) => item.isVisible(this.entity)).map((item) => $ `
                        <mushroom-button
                            .icon=${item.icon}
                            .entry=${item}
                            .title=${item.title
            ? customLocalize(`editor.card.lock.${item.title}`)
            : ""}
                            .disabled=${!isAvailable(this.entity) || item.isDisabled(this.entity)}
                            @click=${this.callService}
                        ></mushroom-button>
                    `)}</mushroom-button-group
            >
        `;
    }
};
__decorate([
    e$3({ attribute: false })
], LockButtonsControl.prototype, "hass", void 0);
__decorate([
    e$3({ attribute: false })
], LockButtonsControl.prototype, "entity", void 0);
__decorate([
    e$3()
], LockButtonsControl.prototype, "fill", void 0);
LockButtonsControl = __decorate([
    n$1("mushroom-lock-buttons-control")
], LockButtonsControl);

registerCustomCard({
    type: LOCK_CARD_NAME,
    name: "Mushroom Lock Card",
    description: "Card for all lock entities",
});
let LockCard = class LockCard extends MushroomBaseCard {
    static async getConfigElement() {
        await Promise.resolve().then(function () { return lockCardEditor; });
        return document.createElement(LOCK_CARD_EDITOR_NAME);
    }
    static async getStubConfig(hass) {
        const entities = Object.keys(hass.states);
        const locks = entities.filter((e) => LOCK_ENTITY_DOMAINS.includes(e.split(".")[0]));
        return {
            type: `custom:${LOCK_CARD_NAME}`,
            entity: locks[0],
        };
    }
    getCardSize() {
        return 1;
    }
    setConfig(config) {
        this._config = Object.assign({ tap_action: {
                action: "more-info",
            }, hold_action: {
                action: "more-info",
            } }, config);
    }
    _handleAction(ev) {
        handleAction(this, this.hass, this._config, ev.detail.action);
    }
    render() {
        if (!this._config || !this.hass || !this._config.entity) {
            return $ ``;
        }
        const entityId = this._config.entity;
        const entity = this.hass.states[entityId];
        const name = this._config.name || entity.attributes.friendly_name || "";
        const icon = this._config.icon || stateIcon(entity);
        const appearance = computeAppearance(this._config);
        const picture = computeEntityPicture(entity, appearance.icon_type);
        const rtl = computeRTL(this.hass);
        return $ `
            <ha-card class=${o({ "fill-container": appearance.fill_container })}>
                <mushroom-card .appearance=${appearance} ?rtl=${rtl}>
                    <mushroom-state-item
                        ?rtl=${rtl}
                        .appearance=${appearance}
                        @action=${this._handleAction}
                        .actionHandler=${actionHandler({
            hasHold: hasAction(this._config.hold_action),
            hasDoubleClick: hasAction(this._config.double_tap_action),
        })}
                    >
                        ${picture ? this.renderPicture(picture) : this.renderIcon(entity, icon)}
                        ${this.renderBadge(entity)}
                        ${this.renderStateInfo(entity, appearance, name)};
                    </mushroom-state-item>
                    <div class="actions" ?rtl=${rtl}>
                        <mushroom-lock-buttons-control
                            .hass=${this.hass}
                            .entity=${entity}
                            .fill=${appearance.layout !== "horizontal"}
                        >
                        </mushroom-lock-buttons-control>
                    </div>
                </mushroom-card>
            </ha-card>
        `;
    }
    renderIcon(entity, icon) {
        const available = isAvailable(entity);
        const iconStyle = {
            "--icon-color": "rgb(var(--rgb-state-lock))",
            "--shape-color": "rgba(var(--rgb-state-lock), 0.2)",
        };
        if (isLocked(entity)) {
            iconStyle["--icon-color"] = `rgb(var(--rgb-state-lock-locked))`;
            iconStyle["--shape-color"] = `rgba(var(--rgb-state-lock-locked), 0.2)`;
        }
        else if (isUnlocked(entity)) {
            iconStyle["--icon-color"] = `rgb(var(--rgb-state-lock-unlocked))`;
            iconStyle["--shape-color"] = `rgba(var(--rgb-state-lock-unlocked), 0.2)`;
        }
        else if (isActionPending(entity)) {
            iconStyle["--icon-color"] = `rgb(var(--rgb-state-lock-pending))`;
            iconStyle["--shape-color"] = `rgba(var(--rgb-state-lock-pending), 0.2)`;
        }
        return $ `
            <mushroom-shape-icon
                slot="icon"
                .disabled=${!available}
                .icon=${icon}
                style=${i$2(iconStyle)}
            ></mushroom-shape-icon>
        `;
    }
    static get styles() {
        return [
            super.styles,
            cardStyle,
            r$3 `
                mushroom-state-item {
                    cursor: pointer;
                }
                mushroom-lock-buttons-control {
                    flex: 1;
                }
            `,
        ];
    }
};
__decorate([
    t$1()
], LockCard.prototype, "_config", void 0);
LockCard = __decorate([
    n$1(LOCK_CARD_NAME)
], LockCard);

const MEDIA_PLAYER_CARD_NAME = `${PREFIX_NAME}-media-player-card`;
const MEDIA_PLAYER_CARD_EDITOR_NAME = `${MEDIA_PLAYER_CARD_NAME}-editor`;
const MEDIA_PLAYER_ENTITY_DOMAINS = ["media_player"];

function computeMediaNameDisplay(config, entity) {
    let name = config.name || entity.attributes.friendly_name || "";
    if (![UNAVAILABLE, UNKNOWN, OFF].includes(entity.state) && config.use_media_info) {
        if (entity.attributes.media_title) {
            name = entity.attributes.media_title;
        }
    }
    return name;
}
function computeMediaStateDisplay(config, entity, hass) {
    let state = computeStateDisplay(hass.localize, entity, hass.locale, hass.entities);
    if (![UNAVAILABLE, UNKNOWN, OFF].includes(entity.state) && config.use_media_info) {
        return computeMediaDescription(entity) || state;
    }
    return state;
}
function getVolumeLevel(entity) {
    return entity.attributes.volume_level != null
        ? entity.attributes.volume_level * 100
        : undefined;
}
function computeMediaIcon(config, entity) {
    var _a;
    var icon = config.icon || stateIcon(entity);
    if (![UNAVAILABLE, UNKNOWN, OFF].includes(entity.state) && config.use_media_info) {
        var app = (_a = entity.attributes.app_name) === null || _a === void 0 ? void 0 : _a.toLowerCase();
        switch (app) {
            case "spotify":
                return "mdi:spotify";
            case "google podcasts":
                return "mdi:google-podcast";
            case "plex":
                return "mdi:plex";
            case "soundcloud":
                return "mdi:soundcloud";
            case "youtube":
                return "mdi:youtube";
            case "oto music":
                return "mdi:music-circle";
            case "netflix":
                return "mdi:netflix";
            default:
                return icon;
        }
    }
    return icon;
}
const computeMediaControls = (stateObj, controls) => {
    if (!stateObj) {
        return [];
    }
    const state = stateObj.state;
    if (state === "off") {
        return supportsFeature(stateObj, MEDIA_PLAYER_SUPPORT_TURN_ON) &&
            controls.includes("on_off")
            ? [
                {
                    icon: "mdi:power",
                    action: "turn_on",
                },
            ]
            : [];
    }
    const buttons = [];
    if (supportsFeature(stateObj, MEDIA_PLAYER_SUPPORT_TURN_OFF) && controls.includes("on_off")) {
        buttons.push({
            icon: "mdi:power",
            action: "turn_off",
        });
    }
    const assumedState = stateObj.attributes.assumed_state === true;
    const stateAttr = stateObj.attributes;
    if ((state === "playing" || state === "paused" || assumedState) &&
        supportsFeature(stateObj, MEDIA_PLAYER_SUPPORT_SHUFFLE_SET) &&
        controls.includes("shuffle")) {
        buttons.push({
            icon: stateAttr.shuffle === true ? "mdi:shuffle" : "mdi:shuffle-disabled",
            action: "shuffle_set",
        });
    }
    if ((state === "playing" || state === "paused" || assumedState) &&
        supportsFeature(stateObj, MEDIA_PLAYER_SUPPORT_PREVIOUS_TRACK) &&
        controls.includes("previous")) {
        buttons.push({
            icon: "mdi:skip-previous",
            action: "media_previous_track",
        });
    }
    if (!assumedState &&
        ((state === "playing" &&
            (supportsFeature(stateObj, MEDIA_PLAYER_SUPPORT_PAUSE) ||
                supportsFeature(stateObj, MEDIA_PLAYER_SUPPORT_STOP))) ||
            ((state === "paused" || state === "idle") &&
                supportsFeature(stateObj, MEDIA_PLAYER_SUPPORT_PLAY)) ||
            (state === "on" &&
                (supportsFeature(stateObj, MEDIA_PLAYER_SUPPORT_PLAY) ||
                    supportsFeature(stateObj, MEDIA_PLAYER_SUPPORT_PAUSE)))) &&
        controls.includes("play_pause_stop")) {
        buttons.push({
            icon: state === "on"
                ? "mdi:play-pause"
                : state !== "playing"
                    ? "mdi:play"
                    : supportsFeature(stateObj, MEDIA_PLAYER_SUPPORT_PAUSE)
                        ? "mdi:pause"
                        : "mdi:stop",
            action: state !== "playing"
                ? "media_play"
                : supportsFeature(stateObj, MEDIA_PLAYER_SUPPORT_PAUSE)
                    ? "media_pause"
                    : "media_stop",
        });
    }
    if (assumedState &&
        supportsFeature(stateObj, MEDIA_PLAYER_SUPPORT_PLAY) &&
        controls.includes("play_pause_stop")) {
        buttons.push({
            icon: "mdi:play",
            action: "media_play",
        });
    }
    if (assumedState &&
        supportsFeature(stateObj, MEDIA_PLAYER_SUPPORT_PAUSE) &&
        controls.includes("play_pause_stop")) {
        buttons.push({
            icon: "mdi:pause",
            action: "media_pause",
        });
    }
    if (assumedState &&
        supportsFeature(stateObj, MEDIA_PLAYER_SUPPORT_STOP) &&
        controls.includes("play_pause_stop")) {
        buttons.push({
            icon: "mdi:stop",
            action: "media_stop",
        });
    }
    if ((state === "playing" || state === "paused" || assumedState) &&
        supportsFeature(stateObj, MEDIA_PLAYER_SUPPORT_NEXT_TRACK) &&
        controls.includes("next")) {
        buttons.push({
            icon: "mdi:skip-next",
            action: "media_next_track",
        });
    }
    if ((state === "playing" || state === "paused" || assumedState) &&
        supportsFeature(stateObj, MEDIA_PLAYER_SUPPORT_REPEAT_SET) &&
        controls.includes("repeat")) {
        buttons.push({
            icon: stateAttr.repeat === "all"
                ? "mdi:repeat"
                : stateAttr.repeat === "one"
                    ? "mdi:repeat-once"
                    : "mdi:repeat-off",
            action: "repeat_set",
        });
    }
    return buttons.length > 0 ? buttons : [];
};
const handleMediaControlClick = (hass, stateObj, action) => {
    let parameters = {};
    if (action === "shuffle_set") {
        parameters = {
            shuffle: !stateObj.attributes.shuffle,
        };
    }
    else if (action === "repeat_set") {
        parameters = {
            repeat: stateObj.attributes.repeat === "all"
                ? "one"
                : stateObj.attributes.repeat === "off"
                    ? "all"
                    : "off",
        };
    }
    else if (action === "volume_mute") {
        parameters = {
            is_volume_muted: !stateObj.attributes.is_volume_muted,
        };
    }
    hass.callService("media_player", action, Object.assign({ entity_id: stateObj.entity_id }, parameters));
};

const isMediaControlVisible = (entity, controls) => computeMediaControls(entity, controls !== null && controls !== void 0 ? controls : []).length > 0;
let MediaPlayerMediaControls = class MediaPlayerMediaControls extends s$1 {
    constructor() {
        super(...arguments);
        this.fill = false;
    }
    _handleClick(e) {
        e.stopPropagation();
        const action = e.target.action;
        handleMediaControlClick(this.hass, this.entity, action);
    }
    render() {
        const rtl = computeRTL(this.hass);
        const controls = computeMediaControls(this.entity, this.controls);
        return $ `
            <mushroom-button-group .fill=${this.fill} ?rtl=${rtl}>
                ${controls.map((control) => $ `
                        <mushroom-button
                            .icon=${control.icon}
                            .action=${control.action}
                            @click=${this._handleClick}
                        ></mushroom-button>
                    `)}
            </mushroom-button-group>
        `;
    }
};
__decorate([
    e$3({ attribute: false })
], MediaPlayerMediaControls.prototype, "hass", void 0);
__decorate([
    e$3({ attribute: false })
], MediaPlayerMediaControls.prototype, "entity", void 0);
__decorate([
    e$3({ attribute: false })
], MediaPlayerMediaControls.prototype, "controls", void 0);
__decorate([
    e$3()
], MediaPlayerMediaControls.prototype, "fill", void 0);
MediaPlayerMediaControls = __decorate([
    n$1("mushroom-media-player-media-control")
], MediaPlayerMediaControls);

const isVolumeControlVisible = (entity, controls) => ((controls === null || controls === void 0 ? void 0 : controls.includes("volume_buttons")) &&
    supportsFeature(entity, MEDIA_PLAYER_SUPPORT_VOLUME_BUTTONS)) ||
    ((controls === null || controls === void 0 ? void 0 : controls.includes("volume_mute")) &&
        supportsFeature(entity, MEDIA_PLAYER_SUPPORT_VOLUME_MUTE)) ||
    ((controls === null || controls === void 0 ? void 0 : controls.includes("volume_set")) && supportsFeature(entity, MEDIA_PLAYER_SUPPORT_VOLUME_SET));
let MediaPlayerVolumeControls = class MediaPlayerVolumeControls extends s$1 {
    constructor() {
        super(...arguments);
        this.fill = false;
    }
    handleSliderChange(e) {
        const value = e.detail.value;
        this.hass.callService("media_player", "volume_set", {
            entity_id: this.entity.entity_id,
            volume_level: value / 100,
        });
    }
    handleSliderCurrentChange(e) {
        let value = e.detail.value;
        this.dispatchEvent(new CustomEvent("current-change", {
            detail: {
                value,
            },
        }));
    }
    handleClick(e) {
        e.stopPropagation();
        const action = e.target.action;
        handleMediaControlClick(this.hass, this.entity, action);
    }
    render() {
        var _a, _b, _c;
        if (!this.entity)
            return null;
        const value = getVolumeLevel(this.entity);
        const rtl = computeRTL(this.hass);
        const displayVolumeSet = ((_a = this.controls) === null || _a === void 0 ? void 0 : _a.includes("volume_set")) &&
            supportsFeature(this.entity, MEDIA_PLAYER_SUPPORT_VOLUME_SET);
        const displayVolumeMute = ((_b = this.controls) === null || _b === void 0 ? void 0 : _b.includes("volume_mute")) &&
            supportsFeature(this.entity, MEDIA_PLAYER_SUPPORT_VOLUME_MUTE);
        const displayVolumeButtons = ((_c = this.controls) === null || _c === void 0 ? void 0 : _c.includes("volume_buttons")) &&
            supportsFeature(this.entity, MEDIA_PLAYER_SUPPORT_VOLUME_BUTTONS);
        return $ `
            <mushroom-button-group .fill=${this.fill && !displayVolumeSet} ?rtl=${rtl}>
                ${displayVolumeSet
            ? $ ` <mushroom-slider
                          .value=${value}
                          .disabled=${!isAvailable(this.entity) || isOff(this.entity)}
                          .inactive=${!isActive(this.entity)}
                          .showActive=${true}
                          .min=${0}
                          .max=${100}
                          @change=${this.handleSliderChange}
                          @current-change=${this.handleSliderCurrentChange}
                      />`
            : null}
                ${displayVolumeMute
            ? $ `
                          <mushroom-button
                              .action=${"volume_mute"}
                              .icon=${this.entity.attributes.is_volume_muted
                ? "mdi:volume-off"
                : "mdi:volume-high"}
                              .disabled=${!isAvailable(this.entity) || isOff(this.entity)}
                              @click=${this.handleClick}
                          ></mushroom-button>
                      `
            : undefined}
                ${displayVolumeButtons
            ? $ `
                          <mushroom-button
                              .action=${"volume_down"}
                              icon="mdi:volume-minus"
                              .disabled=${!isAvailable(this.entity) || isOff(this.entity)}
                              @click=${this.handleClick}
                          ></mushroom-button>
                      `
            : undefined}
                ${displayVolumeButtons
            ? $ `
                          <mushroom-button
                              .action=${"volume_up"}
                              icon="mdi:volume-plus"
                              .disabled=${!isAvailable(this.entity) || isOff(this.entity)}
                              @click=${this.handleClick}
                          ></mushroom-button>
                      `
            : undefined}
            </mushroom-button-group>
        `;
    }
    static get styles() {
        return r$3 `
            mushroom-slider {
                flex: 1;
                --main-color: rgb(var(--rgb-state-media-player));
                --bg-color: rgba(var(--rgb-state-media-player), 0.2);
            }
        `;
    }
};
__decorate([
    e$3({ attribute: false })
], MediaPlayerVolumeControls.prototype, "hass", void 0);
__decorate([
    e$3({ attribute: false })
], MediaPlayerVolumeControls.prototype, "entity", void 0);
__decorate([
    e$3()
], MediaPlayerVolumeControls.prototype, "fill", void 0);
__decorate([
    e$3({ attribute: false })
], MediaPlayerVolumeControls.prototype, "controls", void 0);
MediaPlayerVolumeControls = __decorate([
    n$1("mushroom-media-player-volume-control")
], MediaPlayerVolumeControls);

const CONTROLS_ICONS = {
    media_control: "mdi:play-pause",
    volume_control: "mdi:volume-high",
};
registerCustomCard({
    type: MEDIA_PLAYER_CARD_NAME,
    name: "Mushroom Media Card",
    description: "Card for media player entity",
});
let MediaPlayerCard = class MediaPlayerCard extends MushroomBaseCard {
    constructor() {
        super(...arguments);
        this._controls = [];
    }
    static async getConfigElement() {
        await Promise.resolve().then(function () { return mediaPlayerCardEditor; });
        return document.createElement(MEDIA_PLAYER_CARD_EDITOR_NAME);
    }
    static async getStubConfig(hass) {
        const entities = Object.keys(hass.states);
        const mediaPlayers = entities.filter((e) => MEDIA_PLAYER_ENTITY_DOMAINS.includes(e.split(".")[0]));
        return {
            type: `custom:${MEDIA_PLAYER_CARD_NAME}`,
            entity: mediaPlayers[0],
        };
    }
    _onControlTap(ctrl, e) {
        e.stopPropagation();
        this._activeControl = ctrl;
    }
    getCardSize() {
        return 1;
    }
    setConfig(config) {
        this._config = Object.assign({ tap_action: {
                action: "more-info",
            }, hold_action: {
                action: "more-info",
            } }, config);
        this.updateControls();
        this.updateVolume();
    }
    updated(changedProperties) {
        super.updated(changedProperties);
        if (this.hass && changedProperties.has("hass")) {
            this.updateControls();
            this.updateVolume();
        }
    }
    updateVolume() {
        this.volume = undefined;
        if (!this._config || !this.hass || !this._config.entity)
            return;
        const entity_id = this._config.entity;
        const entity = this.hass.states[entity_id];
        if (!entity)
            return;
        const volume = getVolumeLevel(entity);
        this.volume = volume != null ? Math.round(volume) : volume;
    }
    onCurrentVolumeChange(e) {
        if (e.detail.value != null) {
            this.volume = e.detail.value;
        }
    }
    updateControls() {
        var _a;
        if (!this._config || !this.hass || !this._config.entity)
            return;
        const entity_id = this._config.entity;
        const entity = this.hass.states[entity_id];
        if (!entity)
            return;
        const controls = [];
        if (!this._config.collapsible_controls || isActive(entity)) {
            if (isMediaControlVisible(entity, (_a = this._config) === null || _a === void 0 ? void 0 : _a.media_controls)) {
                controls.push("media_control");
            }
            if (isVolumeControlVisible(entity, this._config.volume_controls)) {
                controls.push("volume_control");
            }
        }
        this._controls = controls;
        const isActiveControlSupported = this._activeControl
            ? controls.includes(this._activeControl)
            : false;
        this._activeControl = isActiveControlSupported ? this._activeControl : controls[0];
    }
    _handleAction(ev) {
        handleAction(this, this.hass, this._config, ev.detail.action);
    }
    render() {
        if (!this._config || !this.hass || !this._config.entity) {
            return $ ``;
        }
        const entity_id = this._config.entity;
        const entity = this.hass.states[entity_id];
        const icon = computeMediaIcon(this._config, entity);
        const nameDisplay = computeMediaNameDisplay(this._config, entity);
        const stateDisplay = computeMediaStateDisplay(this._config, entity, this.hass);
        const appearance = computeAppearance(this._config);
        const picture = computeEntityPicture(entity, appearance.icon_type);
        const stateValue = this.volume != null && this._config.show_volume_level
            ? `${stateDisplay} - ${this.volume}%`
            : stateDisplay;
        const rtl = computeRTL(this.hass);
        return $ `
            <ha-card class=${o({ "fill-container": appearance.fill_container })}>
                <mushroom-card .appearance=${appearance} ?rtl=${rtl}>
                    <mushroom-state-item
                        ?rtl=${rtl}
                        .appearance=${appearance}
                        @action=${this._handleAction}
                        .actionHandler=${actionHandler({
            hasHold: hasAction(this._config.hold_action),
            hasDoubleClick: hasAction(this._config.double_tap_action),
        })}
                    >
                        ${picture ? this.renderPicture(picture) : this.renderIcon(entity, icon)}
                        ${this.renderBadge(entity)}
                        ${this.renderStateInfo(entity, appearance, nameDisplay, stateValue)};
                    </mushroom-state-item>
                    ${this._controls.length > 0
            ? $ `
                              <div class="actions" ?rtl=${rtl}>
                                  ${this.renderActiveControl(entity, appearance.layout)}
                                  ${this.renderOtherControls()}
                              </div>
                          `
            : null}
                </mushroom-card>
            </ha-card>
        `;
    }
    renderOtherControls() {
        const otherControls = this._controls.filter((control) => control != this._activeControl);
        return $ `
            ${otherControls.map((ctrl) => $ `
                    <mushroom-button
                        .icon=${CONTROLS_ICONS[ctrl]}
                        @click=${(e) => this._onControlTap(ctrl, e)}
                    />
                `)}
        `;
    }
    renderActiveControl(entity, layout) {
        var _a, _b, _c, _d;
        const media_controls = (_b = (_a = this._config) === null || _a === void 0 ? void 0 : _a.media_controls) !== null && _b !== void 0 ? _b : [];
        const volume_controls = (_d = (_c = this._config) === null || _c === void 0 ? void 0 : _c.volume_controls) !== null && _d !== void 0 ? _d : [];
        switch (this._activeControl) {
            case "media_control":
                return $ `
                    <mushroom-media-player-media-control
                        .hass=${this.hass}
                        .entity=${entity}
                        .controls=${media_controls}
                        .fill=${layout !== "horizontal"}
                    >
                    </mushroom-media-player-media-control>
                `;
            case "volume_control":
                return $ `
                    <mushroom-media-player-volume-control
                        .hass=${this.hass}
                        .entity=${entity}
                        .controls=${volume_controls}
                        .fill=${layout !== "horizontal"}
                        @current-change=${this.onCurrentVolumeChange}
                    />
                `;
            default:
                return null;
        }
    }
    static get styles() {
        return [
            super.styles,
            cardStyle,
            r$3 `
                mushroom-state-item {
                    cursor: pointer;
                }
                mushroom-shape-icon {
                    --icon-color: rgb(var(--rgb-state-media-player));
                    --shape-color: rgba(var(--rgb-state-media-player), 0.2);
                }
                mushroom-media-player-media-control,
                mushroom-media-player-volume-control {
                    flex: 1;
                }
            `,
        ];
    }
};
__decorate([
    t$1()
], MediaPlayerCard.prototype, "_config", void 0);
__decorate([
    t$1()
], MediaPlayerCard.prototype, "_activeControl", void 0);
__decorate([
    t$1()
], MediaPlayerCard.prototype, "_controls", void 0);
__decorate([
    t$1()
], MediaPlayerCard.prototype, "volume", void 0);
MediaPlayerCard = __decorate([
    n$1(MEDIA_PLAYER_CARD_NAME)
], MediaPlayerCard);

const PERSON_CARD_NAME = `${PREFIX_NAME}-person-card`;
const PERSON_CARD_EDITOR_NAME = `${PERSON_CARD_NAME}-editor`;
const PERSON_ENTITY_DOMAINS = ["person", "device_tracker"];

function getStateIcon(entity, zones) {
    const state = entity.state;
    if (state === UNKNOWN) {
        return "mdi:help";
    }
    else if (state === "not_home") {
        return "mdi:home-export-outline";
    }
    else if (state === "home") {
        return "mdi:home";
    }
    const zone = zones.find((z) => state === z.attributes.friendly_name);
    if (zone && zone.attributes.icon) {
        return zone.attributes.icon;
    }
    return "mdi:home";
}
function getStateColor$1(entity, zones) {
    const state = entity.state;
    if (state === UNKNOWN) {
        return "var(--rgb-state-person-unknown)";
    }
    else if (state === "not_home") {
        return "var(--rgb-state-person-not-home)";
    }
    else if (state === "home") {
        return "var(--rgb-state-person-home)";
    }
    const isInZone = zones.some((z) => state === z.attributes.friendly_name);
    if (isInZone) {
        return "var(--rgb-state-person-zone)";
    }
    return "var(--rgb-state-person-home)";
}

registerCustomCard({
    type: PERSON_CARD_NAME,
    name: "Mushroom Person Card",
    description: "Card for person entity",
});
let PersonCard = class PersonCard extends MushroomBaseCard {
    static async getConfigElement() {
        await Promise.resolve().then(function () { return personCardEditor; });
        return document.createElement(PERSON_CARD_EDITOR_NAME);
    }
    static async getStubConfig(hass) {
        const entities = Object.keys(hass.states);
        const people = entities.filter((e) => PERSON_ENTITY_DOMAINS.includes(e.split(".")[0]));
        return {
            type: `custom:${PERSON_CARD_NAME}`,
            entity: people[0],
        };
    }
    getCardSize() {
        return 1;
    }
    setConfig(config) {
        this._config = Object.assign({ tap_action: {
                action: "more-info",
            }, hold_action: {
                action: "more-info",
            } }, config);
    }
    _handleAction(ev) {
        handleAction(this, this.hass, this._config, ev.detail.action);
    }
    render() {
        if (!this._config || !this.hass || !this._config.entity) {
            return $ ``;
        }
        const entity_id = this._config.entity;
        const entity = this.hass.states[entity_id];
        const name = this._config.name || entity.attributes.friendly_name || "";
        const icon = this._config.icon || stateIcon(entity);
        const appearance = computeAppearance(this._config);
        const picture = computeEntityPicture(entity, appearance.icon_type);
        const rtl = computeRTL(this.hass);
        return $ `
            <ha-card class=${o({ "fill-container": appearance.fill_container })}>
                <mushroom-card .appearance=${appearance} ?rtl=${rtl}>
                    <mushroom-state-item
                        ?rtl=${rtl}
                        .appearance=${appearance}
                        @action=${this._handleAction}
                        .actionHandler=${actionHandler({
            hasHold: hasAction(this._config.hold_action),
            hasDoubleClick: hasAction(this._config.double_tap_action),
        })}
                    >
                        ${picture ? this.renderPicture(picture) : this.renderIcon(entity, icon)}
                        ${this.renderBadge(entity)}
                        ${this.renderStateInfo(entity, appearance, name)};
                    </mushroom-state-item>
                </mushroom-card>
            </ha-card>
        `;
    }
    renderStateBadge(entity) {
        const zones = Object.values(this.hass.states).filter((entity) => entity.entity_id.startsWith("zone."));
        const icon = getStateIcon(entity, zones);
        const color = getStateColor$1(entity, zones);
        return $ `
            <mushroom-badge-icon
                slot="badge"
                .icon=${icon}
                style=${i$2({
            "--main-color": `rgb(${color})`,
        })}
            ></mushroom-badge-icon>
        `;
    }
    renderBadge(entity) {
        const unavailable = !isAvailable(entity);
        if (unavailable) {
            return super.renderBadge(entity);
        }
        else {
            return this.renderStateBadge(entity);
        }
    }
    static get styles() {
        return [
            super.styles,
            cardStyle,
            r$3 `
                mushroom-state-item {
                    cursor: pointer;
                }
            `,
        ];
    }
};
__decorate([
    t$1()
], PersonCard.prototype, "_config", void 0);
PersonCard = __decorate([
    n$1(PERSON_CARD_NAME)
], PersonCard);

const TEMPLATE_CARD_NAME = `${PREFIX_NAME}-template-card`;
const TEMPLATE_CARD_EDITOR_NAME = `${TEMPLATE_CARD_NAME}-editor`;

registerCustomCard({
    type: TEMPLATE_CARD_NAME,
    name: "Mushroom Template Card",
    description: "Card for custom rendering with templates",
});
const TEMPLATE_KEYS$1 = [
    "icon",
    "icon_color",
    "badge_color",
    "badge_icon",
    "primary",
    "secondary",
    "picture",
];
let TemplateCard = class TemplateCard extends MushroomBaseElement {
    constructor() {
        super(...arguments);
        this._templateResults = {};
        this._unsubRenderTemplates = new Map();
    }
    static async getConfigElement() {
        await Promise.resolve().then(function () { return templateCardEditor; });
        return document.createElement(TEMPLATE_CARD_EDITOR_NAME);
    }
    static async getStubConfig(_hass) {
        return {
            type: `custom:${TEMPLATE_CARD_NAME}`,
            primary: "Hello, {{user}}",
            secondary: "How are you?",
            icon: "mdi:home",
        };
    }
    getCardSize() {
        return 1;
    }
    setConfig(config) {
        TEMPLATE_KEYS$1.forEach((key) => {
            var _a, _b;
            if (((_a = this._config) === null || _a === void 0 ? void 0 : _a[key]) !== config[key] || ((_b = this._config) === null || _b === void 0 ? void 0 : _b.entity) != config.entity) {
                this._tryDisconnectKey(key);
            }
        });
        this._config = Object.assign({ tap_action: {
                action: "toggle",
            }, hold_action: {
                action: "more-info",
            } }, config);
    }
    connectedCallback() {
        super.connectedCallback();
        this._tryConnect();
    }
    disconnectedCallback() {
        this._tryDisconnect();
    }
    _handleAction(ev) {
        handleAction(this, this.hass, this._config, ev.detail.action);
    }
    isTemplate(key) {
        var _a;
        const value = (_a = this._config) === null || _a === void 0 ? void 0 : _a[key];
        return value === null || value === void 0 ? void 0 : value.includes("{");
    }
    getValue(key) {
        var _a, _b;
        return this.isTemplate(key) ? (_a = this._templateResults[key]) === null || _a === void 0 ? void 0 : _a.result : (_b = this._config) === null || _b === void 0 ? void 0 : _b[key];
    }
    render() {
        if (!this._config || !this.hass) {
            return $ ``;
        }
        const icon = this.getValue("icon");
        const iconColor = this.getValue("icon_color");
        const badgeIcon = this.getValue("badge_icon");
        const badgeColor = this.getValue("badge_color");
        const primary = this.getValue("primary");
        const secondary = this.getValue("secondary");
        const picture = this.getValue("picture");
        const multiline_secondary = this._config.multiline_secondary;
        const rtl = computeRTL(this.hass);
        const appearance = computeAppearance({
            fill_container: this._config.fill_container,
            layout: this._config.layout,
            icon_type: Boolean(picture) ? "entity-picture" : Boolean(icon) ? "icon" : "none",
            primary_info: Boolean(primary) ? "name" : "none",
            secondary_info: Boolean(secondary) ? "state" : "none",
        });
        return $ `
            <ha-card class=${o({ "fill-container": appearance.fill_container })}>
                <mushroom-card .appearance=${appearance} ?rtl=${rtl}>
                    <mushroom-state-item
                        ?rtl=${rtl}
                        .appearance=${appearance}
                        @action=${this._handleAction}
                        .actionHandler=${actionHandler({
            hasHold: hasAction(this._config.hold_action),
            hasDoubleClick: hasAction(this._config.double_tap_action),
        })}
                    >
                        ${picture
            ? this.renderPicture(picture)
            : icon
                ? this.renderIcon(icon, iconColor)
                : null}
                        ${(icon || picture) && badgeIcon
            ? this.renderBadgeIcon(badgeIcon, badgeColor)
            : undefined}
                        <mushroom-state-info
                            slot="info"
                            .primary=${primary}
                            .secondary=${secondary}
                            .multiline_secondary=${multiline_secondary}
                        ></mushroom-state-info>
                    </mushroom-state-item>
                </mushroom-card>
            </ha-card>
        `;
    }
    renderPicture(picture) {
        return $ `
            <mushroom-shape-avatar
                slot="icon"
                .picture_url=${this.hass.hassUrl(picture)}
            ></mushroom-shape-avatar>
        `;
    }
    renderIcon(icon, iconColor) {
        const iconStyle = {};
        if (iconColor) {
            const iconRgbColor = computeRgbColor(iconColor);
            iconStyle["--icon-color"] = `rgb(${iconRgbColor})`;
            iconStyle["--shape-color"] = `rgba(${iconRgbColor}, 0.2)`;
        }
        return $ `
            <mushroom-shape-icon
                style=${i$2(iconStyle)}
                slot="icon"
                .icon=${icon}
            ></mushroom-shape-icon>
        `;
    }
    renderBadgeIcon(badge, badgeColor) {
        const badgeStyle = {};
        if (badgeColor) {
            const iconRgbColor = computeRgbColor(badgeColor);
            badgeStyle["--main-color"] = `rgba(${iconRgbColor})`;
        }
        return $ `
            <mushroom-badge-icon
                slot="badge"
                .icon=${badge}
                style=${i$2(badgeStyle)}
            ></mushroom-badge-icon>
        `;
    }
    updated(changedProps) {
        super.updated(changedProps);
        if (!this._config || !this.hass) {
            return;
        }
        this._tryConnect();
    }
    async _tryConnect() {
        TEMPLATE_KEYS$1.forEach((key) => {
            this._tryConnectKey(key);
        });
    }
    async _tryConnectKey(key) {
        var _a, _b;
        if (this._unsubRenderTemplates.get(key) !== undefined ||
            !this.hass ||
            !this._config ||
            !this.isTemplate(key)) {
            return;
        }
        try {
            const sub = subscribeRenderTemplate(this.hass.connection, (result) => {
                this._templateResults = Object.assign(Object.assign({}, this._templateResults), { [key]: result });
            }, {
                template: (_a = this._config[key]) !== null && _a !== void 0 ? _a : "",
                entity_ids: this._config.entity_id,
                variables: {
                    config: this._config,
                    user: this.hass.user.name,
                    entity: this._config.entity,
                },
                strict: true,
            });
            this._unsubRenderTemplates.set(key, sub);
            await sub;
        }
        catch (_err) {
            const result = {
                result: (_b = this._config[key]) !== null && _b !== void 0 ? _b : "",
                listeners: {
                    all: false,
                    domains: [],
                    entities: [],
                    time: false,
                },
            };
            this._templateResults = Object.assign(Object.assign({}, this._templateResults), { [key]: result });
            this._unsubRenderTemplates.delete(key);
        }
    }
    async _tryDisconnect() {
        TEMPLATE_KEYS$1.forEach((key) => {
            this._tryDisconnectKey(key);
        });
    }
    async _tryDisconnectKey(key) {
        const unsubRenderTemplate = this._unsubRenderTemplates.get(key);
        if (!unsubRenderTemplate) {
            return;
        }
        try {
            const unsub = await unsubRenderTemplate;
            unsub();
            this._unsubRenderTemplates.delete(key);
        }
        catch (err) {
            if (err.code === "not_found" || err.code === "template_error") ;
            else {
                throw err;
            }
        }
    }
    static get styles() {
        return [
            super.styles,
            cardStyle,
            r$3 `
                mushroom-state-item {
                    cursor: pointer;
                }
                mushroom-shape-icon {
                    --icon-color: rgb(var(--rgb-disabled));
                    --shape-color: rgba(var(--rgb-disabled), 0.2);
                }
            `,
        ];
    }
};
__decorate([
    t$1()
], TemplateCard.prototype, "_config", void 0);
__decorate([
    t$1()
], TemplateCard.prototype, "_templateResults", void 0);
__decorate([
    t$1()
], TemplateCard.prototype, "_unsubRenderTemplates", void 0);
TemplateCard = __decorate([
    n$1(TEMPLATE_CARD_NAME)
], TemplateCard);

const TITLE_CARD_NAME = `${PREFIX_NAME}-title-card`;
const TITLE_CARD_EDITOR_NAME = `${TITLE_CARD_NAME}-editor`;

registerCustomCard({
    type: TITLE_CARD_NAME,
    name: "Mushroom Title Card",
    description: "Title and subtitle to separate sections",
});
const TEMPLATE_KEYS = ["title", "subtitle"];
let TitleCard = class TitleCard extends MushroomBaseElement {
    constructor() {
        super(...arguments);
        this._templateResults = {};
        this._unsubRenderTemplates = new Map();
    }
    static async getConfigElement() {
        await Promise.resolve().then(function () { return titleCardEditor; });
        return document.createElement(TITLE_CARD_EDITOR_NAME);
    }
    static async getStubConfig(_hass) {
        return {
            type: `custom:${TITLE_CARD_NAME}`,
            title: "Hello, {{ user }} !",
        };
    }
    getCardSize() {
        return 1;
    }
    setConfig(config) {
        TEMPLATE_KEYS.forEach((key) => {
            var _a;
            if (((_a = this._config) === null || _a === void 0 ? void 0 : _a[key]) !== config[key]) {
                this._tryDisconnectKey(key);
            }
        });
        this._config = config;
    }
    connectedCallback() {
        super.connectedCallback();
        this._tryConnect();
    }
    disconnectedCallback() {
        this._tryDisconnect();
    }
    isTemplate(key) {
        var _a;
        const value = (_a = this._config) === null || _a === void 0 ? void 0 : _a[key];
        return value === null || value === void 0 ? void 0 : value.includes("{");
    }
    getValue(key) {
        var _a, _b;
        return this.isTemplate(key) ? (_a = this._templateResults[key]) === null || _a === void 0 ? void 0 : _a.result : (_b = this._config) === null || _b === void 0 ? void 0 : _b[key];
    }
    render() {
        if (!this._config || !this.hass) {
            return $ ``;
        }
        const title = this.getValue("title");
        const subtitle = this.getValue("subtitle");
        let alignment = "";
        if (this._config.alignment) {
            alignment = `align-${this._config.alignment}`;
        }
        return $ `
            <div class="header ${alignment}">
                ${title ? $ `<h1 class="title">${title}</h1>` : null}
                ${subtitle ? $ `<h2 class="subtitle">${subtitle}</h2>` : null}
            </div>
        `;
    }
    updated(changedProps) {
        super.updated(changedProps);
        if (!this._config || !this.hass) {
            return;
        }
        this._tryConnect();
    }
    async _tryConnect() {
        TEMPLATE_KEYS.forEach((key) => {
            this._tryConnectKey(key);
        });
    }
    async _tryConnectKey(key) {
        var _a, _b;
        if (this._unsubRenderTemplates.get(key) !== undefined ||
            !this.hass ||
            !this._config ||
            !this.isTemplate(key)) {
            return;
        }
        try {
            const sub = subscribeRenderTemplate(this.hass.connection, (result) => {
                this._templateResults = Object.assign(Object.assign({}, this._templateResults), { [key]: result });
            }, {
                template: (_a = this._config[key]) !== null && _a !== void 0 ? _a : "",
                entity_ids: this._config.entity_id,
                variables: {
                    config: this._config,
                    user: this.hass.user.name,
                },
                strict: true,
            });
            this._unsubRenderTemplates.set(key, sub);
            await sub;
        }
        catch (_err) {
            const result = {
                result: (_b = this._config[key]) !== null && _b !== void 0 ? _b : "",
                listeners: {
                    all: false,
                    domains: [],
                    entities: [],
                    time: false,
                },
            };
            this._templateResults = Object.assign(Object.assign({}, this._templateResults), { [key]: result });
            this._unsubRenderTemplates.delete(key);
        }
    }
    async _tryDisconnect() {
        TEMPLATE_KEYS.forEach((key) => {
            this._tryDisconnectKey(key);
        });
    }
    async _tryDisconnectKey(key) {
        const unsubRenderTemplate = this._unsubRenderTemplates.get(key);
        if (!unsubRenderTemplate) {
            return;
        }
        try {
            const unsub = await unsubRenderTemplate;
            unsub();
            this._unsubRenderTemplates.delete(key);
        }
        catch (err) {
            if (err.code === "not_found" || err.code === "template_error") ;
            else {
                throw err;
            }
        }
    }
    static get styles() {
        return [
            super.styles,
            cardStyle,
            r$3 `
                .header {
                    display: block;
                    padding: var(--title-padding);
                }
                .header * {
                    margin: 0;
                    white-space: pre-wrap;
                }
                .header *:not(:last-child) {
                    margin-bottom: var(--title-spacing);
                }
                .title {
                    color: var(--primary-text-color);
                    font-size: var(--title-font-size);
                    font-weight: var(--title-font-weight);
                    line-height: var(--title-line-height);
                }
                .subtitle {
                    color: var(--secondary-text-color);
                    font-size: var(--subtitle-font-size);
                    font-weight: var(--subtitle-font-weight);
                    line-height: var(--subtitle-line-height);
                }
                .align-start {
                    text-align: start;
                }
                .align-end {
                    text-align: end;
                }
                .align-center {
                    text-align: center;
                }
                .align-justify {
                    text-align: justify;
                }
            `,
        ];
    }
};
__decorate([
    t$1()
], TitleCard.prototype, "_config", void 0);
__decorate([
    t$1()
], TitleCard.prototype, "_templateResults", void 0);
__decorate([
    t$1()
], TitleCard.prototype, "_unsubRenderTemplates", void 0);
TitleCard = __decorate([
    n$1(TITLE_CARD_NAME)
], TitleCard);

const UPDATE_CARD_NAME = `${PREFIX_NAME}-update-card`;
const UPDATE_CARD_EDITOR_NAME = `${UPDATE_CARD_NAME}-editor`;
const UPDATE_ENTITY_DOMAINS = ["update"];
const UPDATE_CARD_DEFAULT_STATE_COLOR = "var(--rgb-grey)";
const UPDATE_CARD_STATE_COLOR = {
    on: "var(--rgb-state-update-on)",
    off: "var(--rgb-state-update-off)",
    installing: "var(--rgb-state-update-installing)",
};

let UpdateButtonsControl = class UpdateButtonsControl extends s$1 {
    constructor() {
        super(...arguments);
        this.fill = false;
    }
    _handleInstall() {
        this.hass.callService("update", "install", {
            entity_id: this.entity.entity_id,
        });
    }
    _handleSkip(e) {
        e.stopPropagation();
        this.hass.callService("update", "skip", {
            entity_id: this.entity.entity_id,
        });
    }
    get installDisabled() {
        if (!isAvailable(this.entity))
            return true;
        const skippedVersion = this.entity.attributes.latest_version &&
            this.entity.attributes.skipped_version === this.entity.attributes.latest_version;
        return (!isActive(this.entity) && !skippedVersion) || updateIsInstalling(this.entity);
    }
    get skipDisabled() {
        if (!isAvailable(this.entity))
            return true;
        const skippedVersion = this.entity.attributes.latest_version &&
            this.entity.attributes.skipped_version === this.entity.attributes.latest_version;
        return skippedVersion || !isActive(this.entity) || updateIsInstalling(this.entity);
    }
    render() {
        const rtl = computeRTL(this.hass);
        return $ `
            <mushroom-button-group .fill=${this.fill} ?rtl=${rtl}>
                <mushroom-button
                    icon="mdi:cancel"
                    .disabled=${this.skipDisabled}
                    @click=${this._handleSkip}
                ></mushroom-button>
                <mushroom-button
                    icon="mdi:cellphone-arrow-down"
                    .disabled=${this.installDisabled}
                    @click=${this._handleInstall}
                ></mushroom-button>
            </mushroom-button-group>
        `;
    }
};
__decorate([
    e$3({ attribute: false })
], UpdateButtonsControl.prototype, "hass", void 0);
__decorate([
    e$3({ attribute: false })
], UpdateButtonsControl.prototype, "entity", void 0);
__decorate([
    e$3()
], UpdateButtonsControl.prototype, "fill", void 0);
UpdateButtonsControl = __decorate([
    n$1("mushroom-update-buttons-control")
], UpdateButtonsControl);

function getStateColor(state, isInstalling) {
    if (isInstalling) {
        return UPDATE_CARD_STATE_COLOR["installing"];
    }
    else {
        return UPDATE_CARD_STATE_COLOR[state] || UPDATE_CARD_DEFAULT_STATE_COLOR;
    }
}

registerCustomCard({
    type: UPDATE_CARD_NAME,
    name: "Mushroom Update Card",
    description: "Card for update entity",
});
let UpdateCard = class UpdateCard extends MushroomBaseCard {
    static async getConfigElement() {
        await Promise.resolve().then(function () { return updateCardEditor; });
        return document.createElement(UPDATE_CARD_EDITOR_NAME);
    }
    static async getStubConfig(hass) {
        const entities = Object.keys(hass.states);
        const updates = entities.filter((e) => UPDATE_ENTITY_DOMAINS.includes(e.split(".")[0]));
        return {
            type: `custom:${UPDATE_CARD_NAME}`,
            entity: updates[0],
        };
    }
    getCardSize() {
        return 1;
    }
    setConfig(config) {
        this._config = Object.assign({ tap_action: {
                action: "more-info",
            }, hold_action: {
                action: "more-info",
            } }, config);
    }
    _handleAction(ev) {
        handleAction(this, this.hass, this._config, ev.detail.action);
    }
    render() {
        if (!this._config || !this.hass || !this._config.entity) {
            return $ ``;
        }
        const entityId = this._config.entity;
        const entity = this.hass.states[entityId];
        const name = this._config.name || entity.attributes.friendly_name || "";
        const icon = this._config.icon || stateIcon(entity);
        const appearance = computeAppearance(this._config);
        const picture = computeEntityPicture(entity, appearance.icon_type);
        const rtl = computeRTL(this.hass);
        const displayControls = (!this._config.collapsible_controls || isActive(entity)) &&
            this._config.show_buttons_control &&
            supportsFeature(entity, UPDATE_SUPPORT_INSTALL);
        return $ `
            <ha-card class=${o({ "fill-container": appearance.fill_container })}>
                <mushroom-card .appearance=${appearance} ?rtl=${rtl}>
                    <mushroom-state-item
                        ?rtl=${rtl}
                        .appearance=${appearance}
                        @action=${this._handleAction}
                        .actionHandler=${actionHandler({
            hasHold: hasAction(this._config.hold_action),
            hasDoubleClick: hasAction(this._config.double_tap_action),
        })}
                    >
                        ${picture ? this.renderPicture(picture) : this.renderIcon(entity, icon)}
                        ${this.renderBadge(entity)}
                        ${this.renderStateInfo(entity, appearance, name)};
                    </mushroom-state-item>
                    ${displayControls
            ? $ `
                              <div class="actions" ?rtl=${rtl}>
                                  <mushroom-update-buttons-control
                                      .hass=${this.hass}
                                      .entity=${entity}
                                      .fill=${appearance.layout !== "horizontal"}
                                  />
                              </div>
                          `
            : null}
                </mushroom-card>
            </ha-card>
        `;
    }
    renderIcon(entity, icon) {
        const isInstalling = updateIsInstalling(entity);
        const color = getStateColor(entity.state, isInstalling);
        const style = {
            "--icon-color": `rgb(${color})`,
            "--shape-color": `rgba(${color}, 0.2)`,
        };
        return $ `
            <mushroom-shape-icon
                slot="icon"
                .disabled=${!isAvailable(entity)}
                .icon=${icon}
                class=${o({
            pulse: isInstalling,
        })}
                style=${i$2(style)}
            ></mushroom-shape-icon>
        `;
    }
    static get styles() {
        return [
            super.styles,
            cardStyle,
            r$3 `
                mushroom-state-item {
                    cursor: pointer;
                }
                mushroom-shape-icon {
                    --icon-color: rgb(var(--rgb-state-entity));
                    --shape-color: rgba(var(--rgb-state-entity), 0.2);
                }
                mushroom-shape-icon.pulse {
                    --shape-animation: 1s ease 0s infinite normal none running pulse;
                }
                mushroom-update-buttons-control {
                    flex: 1;
                }
            `,
        ];
    }
};
__decorate([
    t$1()
], UpdateCard.prototype, "_config", void 0);
UpdateCard = __decorate([
    n$1(UPDATE_CARD_NAME)
], UpdateCard);

const VACUUM_CARD_NAME = `${PREFIX_NAME}-vacuum-card`;
const VACUUM_CARD_EDITOR_NAME = `${VACUUM_CARD_NAME}-editor`;
const VACUUM_ENTITY_DOMAINS = ["vacuum"];

function isCleaning(entity) {
    switch (entity.state) {
        case STATE_CLEANING:
        case STATE_ON:
            return true;
        default:
            return false;
    }
}
function isStopped(entity) {
    switch (entity.state) {
        case STATE_DOCKED:
        case STATE_OFF:
        case STATE_IDLE:
        case STATE_RETURNING:
            return true;
        default:
            return false;
    }
}
function isReturningHome(entity) {
    switch (entity.state) {
        case STATE_RETURNING:
            return true;
        default:
            return false;
    }
}

const isCommandsControlVisible = (entity, commands) => VACUUM_BUTTONS.some((item) => item.isVisible(entity, commands));
const VACUUM_BUTTONS = [
    {
        icon: "mdi:power",
        serviceName: "turn_on",
        isVisible: (entity, commands) => supportsFeature(entity, VACUUM_SUPPORT_TURN_ON) &&
            commands.includes("on_off") &&
            !isActive(entity),
        isDisabled: () => false,
    },
    {
        icon: "mdi:power",
        serviceName: "turn_off",
        isVisible: (entity, commands) => supportsFeature(entity, VACUUM_SUPPORT_TURN_OFF) &&
            commands.includes("on_off") &&
            isActive(entity),
        isDisabled: () => false,
    },
    {
        icon: "mdi:play",
        serviceName: "start",
        isVisible: (entity, commands) => supportsFeature(entity, VACUUM_SUPPORT_START) &&
            commands.includes("start_pause") &&
            !isCleaning(entity),
        isDisabled: () => false,
    },
    {
        icon: "mdi:pause",
        serviceName: "pause",
        isVisible: (entity, commands) => 
        // We need also to check if Start is supported because if not we show play-pause
        supportsFeature(entity, VACUUM_SUPPORT_START) &&
            supportsFeature(entity, VACUUM_SUPPORT_PAUSE) &&
            commands.includes("start_pause") &&
            isCleaning(entity),
        isDisabled: () => false,
    },
    {
        icon: "mdi:play-pause",
        serviceName: "start_pause",
        isVisible: (entity, commands) => 
        // If start is supported, we don't show this button
        !supportsFeature(entity, VACUUM_SUPPORT_START) &&
            supportsFeature(entity, VACUUM_SUPPORT_PAUSE) &&
            commands.includes("start_pause"),
        isDisabled: () => false,
    },
    {
        icon: "mdi:stop",
        serviceName: "stop",
        isVisible: (entity, commands) => supportsFeature(entity, VACUUM_SUPPORT_STOP) && commands.includes("stop"),
        isDisabled: (entity) => isStopped(entity),
    },
    {
        icon: "mdi:target-variant",
        serviceName: "clean_spot",
        isVisible: (entity, commands) => supportsFeature(entity, VACUUM_SUPPORT_CLEAN_SPOT) && commands.includes("clean_spot"),
        isDisabled: () => false,
    },
    {
        icon: "mdi:map-marker",
        serviceName: "locate",
        isVisible: (entity, commands) => supportsFeature(entity, VACUUM_SUPPORT_LOCATE) && commands.includes("locate"),
        isDisabled: (entity) => isReturningHome(entity),
    },
    {
        icon: "mdi:home-map-marker",
        serviceName: "return_to_base",
        isVisible: (entity, commands) => supportsFeature(entity, VACUUM_SUPPORT_RETURN_HOME) && commands.includes("return_home"),
        isDisabled: () => false,
    },
];
let CoverButtonsControl = class CoverButtonsControl extends s$1 {
    constructor() {
        super(...arguments);
        this.fill = false;
    }
    callService(e) {
        e.stopPropagation();
        const entry = e.target.entry;
        this.hass.callService("vacuum", entry.serviceName, {
            entity_id: this.entity.entity_id,
        });
    }
    render() {
        const rtl = computeRTL(this.hass);
        return $ `
            <mushroom-button-group .fill=${this.fill} ?rtl=${rtl}>
                ${VACUUM_BUTTONS.filter((item) => item.isVisible(this.entity, this.commands)).map((item) => $ `
                        <mushroom-button
                            .icon=${item.icon}
                            .entry=${item}
                            .disabled=${!isAvailable(this.entity) || item.isDisabled(this.entity)}
                            @click=${this.callService}
                        ></mushroom-button>
                    `)}
            </mushroom-button-group>
        `;
    }
};
__decorate([
    e$3({ attribute: false })
], CoverButtonsControl.prototype, "hass", void 0);
__decorate([
    e$3({ attribute: false })
], CoverButtonsControl.prototype, "entity", void 0);
__decorate([
    e$3({ attribute: false })
], CoverButtonsControl.prototype, "commands", void 0);
__decorate([
    e$3()
], CoverButtonsControl.prototype, "fill", void 0);
CoverButtonsControl = __decorate([
    n$1("mushroom-vacuum-commands-control")
], CoverButtonsControl);

registerCustomCard({
    type: VACUUM_CARD_NAME,
    name: "Mushroom Vacuum Card",
    description: "Card for vacuum entity",
});
let VacuumCard = class VacuumCard extends MushroomBaseCard {
    static async getConfigElement() {
        await Promise.resolve().then(function () { return vacuumCardEditor; });
        return document.createElement(VACUUM_CARD_EDITOR_NAME);
    }
    static async getStubConfig(hass) {
        const entities = Object.keys(hass.states);
        const vacuums = entities.filter((e) => VACUUM_ENTITY_DOMAINS.includes(e.split(".")[0]));
        return {
            type: `custom:${VACUUM_CARD_NAME}`,
            entity: vacuums[0],
        };
    }
    getCardSize() {
        return 1;
    }
    setConfig(config) {
        this._config = Object.assign({ tap_action: {
                action: "more-info",
            }, hold_action: {
                action: "more-info",
            } }, config);
    }
    _handleAction(ev) {
        handleAction(this, this.hass, this._config, ev.detail.action);
    }
    render() {
        var _a, _b;
        if (!this._config || !this.hass || !this._config.entity) {
            return $ ``;
        }
        const entity_id = this._config.entity;
        const entity = this.hass.states[entity_id];
        const name = this._config.name || entity.attributes.friendly_name || "";
        const icon = this._config.icon || stateIcon(entity);
        const appearance = computeAppearance(this._config);
        const picture = computeEntityPicture(entity, appearance.icon_type);
        const rtl = computeRTL(this.hass);
        const commands = (_b = (_a = this._config) === null || _a === void 0 ? void 0 : _a.commands) !== null && _b !== void 0 ? _b : [];
        return $ `
            <ha-card class=${o({ "fill-container": appearance.fill_container })}>
                <mushroom-card .appearance=${appearance} ?rtl=${rtl}>
                    <mushroom-state-item
                        ?rtl=${rtl}
                        .appearance=${appearance}
                        @action=${this._handleAction}
                        .actionHandler=${actionHandler({
            hasHold: hasAction(this._config.hold_action),
            hasDoubleClick: hasAction(this._config.double_tap_action),
        })}
                    >
                        ${picture ? this.renderPicture(picture) : this.renderIcon(entity, icon)}
                        ${this.renderBadge(entity)}
                        ${this.renderStateInfo(entity, appearance, name)};
                    </mushroom-state-item>
                    ${isCommandsControlVisible(entity, commands)
            ? $ `
                              <div class="actions" ?rtl=${rtl}>
                                  <mushroom-vacuum-commands-control
                                      .hass=${this.hass}
                                      .entity=${entity}
                                      .commands=${commands}
                                      .fill=${appearance.layout !== "horizontal"}
                                  >
                                  </mushroom-vacuum-commands-control>
                              </div>
                          `
            : null}
                </mushroom-card>
            </ha-card>
        `;
    }
    renderIcon(entity, icon) {
        var _a, _b;
        return $ `
            <mushroom-shape-icon
                slot="icon"
                class=${o({
            returning: isReturningHome(entity) && Boolean((_a = this._config) === null || _a === void 0 ? void 0 : _a.icon_animation),
            cleaning: isCleaning(entity) && Boolean((_b = this._config) === null || _b === void 0 ? void 0 : _b.icon_animation),
        })}
                style=${i$2({})}
                .disabled=${!isActive(entity)}
                .icon=${icon}
            ></mushroom-shape-icon>
        `;
    }
    static get styles() {
        return [
            super.styles,
            cardStyle,
            r$3 `
                mushroom-state-item {
                    cursor: pointer;
                }
                mushroom-shape-icon {
                    --icon-color: rgb(var(--rgb-state-vacuum));
                    --shape-color: rgba(var(--rgb-state-vacuum), 0.2);
                }
                mushroom-shape-icon.cleaning {
                    --icon-animation: 5s infinite linear cleaning;
                }
                mushroom-shape-icon.returning {
                    --icon-animation: 2s infinite linear returning;
                }
                mushroom-vacuum-commands-control {
                    flex: 1;
                }
            `,
        ];
    }
};
__decorate([
    t$1()
], VacuumCard.prototype, "_config", void 0);
VacuumCard = __decorate([
    n$1(VACUUM_CARD_NAME)
], VacuumCard);

console.info(`%c🍄 Mushroom 🍄 - ${version$1}`, "color: #ef5350; font-weight: 700;");

const actionsSharedConfigStruct = object({
    tap_action: optional(actionConfigStruct),
    hold_action: optional(actionConfigStruct),
    double_tap_action: optional(actionConfigStruct),
});
const computeActionsFormSchema = (actions) => [
    {
        name: "tap_action",
        selector: { "ui-action": { actions } },
    },
    {
        name: "hold_action",
        selector: { "ui-action": { actions } },
    },
    {
        name: "double_tap_action",
        selector: { "ui-action": { actions } },
    },
];

const layoutStruct = union([literal("horizontal"), literal("vertical"), literal("default")]);

const appearanceSharedConfigStruct = object({
    layout: optional(layoutStruct),
    fill_container: optional(boolean()),
    primary_info: optional(enums(INFOS)),
    secondary_info: optional(enums(INFOS)),
    icon_type: optional(enums(ICON_TYPES)),
});
const APPEARANCE_FORM_SCHEMA = [
    {
        type: "grid",
        name: "",
        schema: [
            { name: "layout", selector: { "mush-layout": {} } },
            { name: "fill_container", selector: { boolean: {} } },
        ],
    },
    {
        type: "grid",
        name: "",
        schema: [
            { name: "primary_info", selector: { "mush-info": {} } },
            { name: "secondary_info", selector: { "mush-info": {} } },
            { name: "icon_type", selector: { "mush-icon-type": {} } },
        ],
    },
];

const GENERIC_LABELS = [
    "icon_color",
    "layout",
    "fill_container",
    "primary_info",
    "secondary_info",
    "icon_type",
    "content_info",
    "use_entity_picture",
    "collapsible_controls",
    "icon_animation",
];

// Hack to load ha-components needed for editor
const loadHaComponents = () => {
    var _a, _b;
    if (!customElements.get("ha-form")) {
        (_a = customElements.get("hui-button-card")) === null || _a === void 0 ? void 0 : _a.getConfigElement();
    }
    if (!customElements.get("ha-entity-picker")) {
        (_b = customElements.get("hui-entities-card")) === null || _b === void 0 ? void 0 : _b.getConfigElement();
    }
};

const entitySharedConfigStruct = object({
    entity: optional(string()),
    name: optional(string()),
    icon: optional(string()),
});

const lovelaceCardConfigStruct = object({
    index: optional(number()),
    view_index: optional(number()),
    view_layout: any(),
    type: string(),
});

const alarmControlPanelCardCardConfigStruct = assign(lovelaceCardConfigStruct, assign(entitySharedConfigStruct, appearanceSharedConfigStruct, actionsSharedConfigStruct), object({
    states: optional(array()),
    show_keypad: optional(boolean()),
}));

const actions$5 = ["more-info", "navigate", "url", "call-service", "none"];
const states = ["armed_home", "armed_away", "armed_night", "armed_vacation", "armed_custom_bypass"];
const ALARM_CONTROL_PANEL_LABELS = ["show_keypad"];
const computeSchema$l = memoizeOne((localize, icon) => [
    { name: "entity", selector: { entity: { domain: ALARM_CONTROl_PANEL_ENTITY_DOMAINS } } },
    { name: "name", selector: { text: {} } },
    { name: "icon", selector: { icon: { placeholder: icon } } },
    ...APPEARANCE_FORM_SCHEMA,
    {
        type: "multi_select",
        name: "states",
        options: states.map((state) => [
            state,
            localize(`ui.card.alarm_control_panel.${state.replace("armed", "arm")}`),
        ]),
    },
    { name: "show_keypad", selector: { boolean: {} } },
    ...computeActionsFormSchema(actions$5),
]);
let SwitchCardEditor$1 = class SwitchCardEditor extends MushroomBaseElement {
    constructor() {
        super(...arguments);
        this._computeLabel = (schema) => {
            const customLocalize = setupCustomlocalize(this.hass);
            if (GENERIC_LABELS.includes(schema.name)) {
                return customLocalize(`editor.card.generic.${schema.name}`);
            }
            if (ALARM_CONTROL_PANEL_LABELS.includes(schema.name)) {
                return customLocalize(`editor.card.alarm_control_panel.${schema.name}`);
            }
            if (schema.name === "states") {
                return this.hass.localize("ui.panel.lovelace.editor.card.alarm-panel.available_states");
            }
            return this.hass.localize(`ui.panel.lovelace.editor.card.generic.${schema.name}`);
        };
    }
    connectedCallback() {
        super.connectedCallback();
        void loadHaComponents();
    }
    setConfig(config) {
        assert(config, alarmControlPanelCardCardConfigStruct);
        this._config = config;
    }
    render() {
        if (!this.hass || !this._config) {
            return $ ``;
        }
        const entityState = this._config.entity ? this.hass.states[this._config.entity] : undefined;
        const entityIcon = entityState ? stateIcon(entityState) : undefined;
        const icon = this._config.icon || entityIcon;
        const schema = computeSchema$l(this.hass.localize, icon);
        return $ `
            <ha-form
                .hass=${this.hass}
                .data=${this._config}
                .schema=${schema}
                .computeLabel=${this._computeLabel}
                @value-changed=${this._valueChanged}
            ></ha-form>
        `;
    }
    _valueChanged(ev) {
        fireEvent(this, "config-changed", { config: ev.detail.value });
    }
};
__decorate([
    t$1()
], SwitchCardEditor$1.prototype, "_config", void 0);
SwitchCardEditor$1 = __decorate([
    n$1(ALARM_CONTROl_PANEL_CARD_EDITOR_NAME)
], SwitchCardEditor$1);

var alarmControlPanelCardEditor = /*#__PURE__*/Object.freeze({
  __proto__: null,
  get SwitchCardEditor () { return SwitchCardEditor$1; }
});

/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-LIcense-Identifier: Apache-2.0
 */
const styles = r$3 `.mdc-floating-label{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:Roboto, sans-serif;font-family:var(--mdc-typography-subtitle1-font-family, var(--mdc-typography-font-family, Roboto, sans-serif));font-size:1rem;font-size:var(--mdc-typography-subtitle1-font-size, 1rem);font-weight:400;font-weight:var(--mdc-typography-subtitle1-font-weight, 400);letter-spacing:0.009375em;letter-spacing:var(--mdc-typography-subtitle1-letter-spacing, 0.009375em);text-decoration:inherit;text-decoration:var(--mdc-typography-subtitle1-text-decoration, inherit);text-transform:inherit;text-transform:var(--mdc-typography-subtitle1-text-transform, inherit);position:absolute;left:0;-webkit-transform-origin:left top;transform-origin:left top;line-height:1.15rem;text-align:left;text-overflow:ellipsis;white-space:nowrap;cursor:text;overflow:hidden;will-change:transform;transition:transform 150ms cubic-bezier(0.4, 0, 0.2, 1),color 150ms cubic-bezier(0.4, 0, 0.2, 1)}[dir=rtl] .mdc-floating-label,.mdc-floating-label[dir=rtl]{right:0;left:auto;-webkit-transform-origin:right top;transform-origin:right top;text-align:right}.mdc-floating-label--float-above{cursor:auto}.mdc-floating-label--required::after{margin-left:1px;margin-right:0px;content:"*"}[dir=rtl] .mdc-floating-label--required::after,.mdc-floating-label--required[dir=rtl]::after{margin-left:0;margin-right:1px}.mdc-floating-label--float-above{transform:translateY(-106%) scale(0.75)}.mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-standard 250ms 1}@keyframes mdc-floating-label-shake-float-above-standard{0%{transform:translateX(calc(0 - 0%)) translateY(-106%) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 0%)) translateY(-106%) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 0%)) translateY(-106%) scale(0.75)}100%{transform:translateX(calc(0 - 0%)) translateY(-106%) scale(0.75)}}.mdc-line-ripple::before,.mdc-line-ripple::after{position:absolute;bottom:0;left:0;width:100%;border-bottom-style:solid;content:""}.mdc-line-ripple::before{border-bottom-width:1px;z-index:1}.mdc-line-ripple::after{transform:scaleX(0);border-bottom-width:2px;opacity:0;z-index:2}.mdc-line-ripple::after{transition:transform 180ms cubic-bezier(0.4, 0, 0.2, 1),opacity 180ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-line-ripple--active::after{transform:scaleX(1);opacity:1}.mdc-line-ripple--deactivating::after{opacity:0}.mdc-notched-outline{display:flex;position:absolute;top:0;right:0;left:0;box-sizing:border-box;width:100%;max-width:100%;height:100%;text-align:left;pointer-events:none}[dir=rtl] .mdc-notched-outline,.mdc-notched-outline[dir=rtl]{text-align:right}.mdc-notched-outline__leading,.mdc-notched-outline__notch,.mdc-notched-outline__trailing{box-sizing:border-box;height:100%;border-top:1px solid;border-bottom:1px solid;pointer-events:none}.mdc-notched-outline__leading{border-left:1px solid;border-right:none;width:12px}[dir=rtl] .mdc-notched-outline__leading,.mdc-notched-outline__leading[dir=rtl]{border-left:none;border-right:1px solid}.mdc-notched-outline__trailing{border-left:none;border-right:1px solid;flex-grow:1}[dir=rtl] .mdc-notched-outline__trailing,.mdc-notched-outline__trailing[dir=rtl]{border-left:1px solid;border-right:none}.mdc-notched-outline__notch{flex:0 0 auto;width:auto;max-width:calc(100% - 12px * 2)}.mdc-notched-outline .mdc-floating-label{display:inline-block;position:relative;max-width:100%}.mdc-notched-outline .mdc-floating-label--float-above{text-overflow:clip}.mdc-notched-outline--upgraded .mdc-floating-label--float-above{max-width:calc(100% / 0.75)}.mdc-notched-outline--notched .mdc-notched-outline__notch{padding-left:0;padding-right:8px;border-top:none}[dir=rtl] .mdc-notched-outline--notched .mdc-notched-outline__notch,.mdc-notched-outline--notched .mdc-notched-outline__notch[dir=rtl]{padding-left:8px;padding-right:0}.mdc-notched-outline--no-label .mdc-notched-outline__notch{display:none}@keyframes mdc-ripple-fg-radius-in{from{animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transform:translate(var(--mdc-ripple-fg-translate-start, 0)) scale(1)}to{transform:translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1))}}@keyframes mdc-ripple-fg-opacity-in{from{animation-timing-function:linear;opacity:0}to{opacity:var(--mdc-ripple-fg-opacity, 0)}}@keyframes mdc-ripple-fg-opacity-out{from{animation-timing-function:linear;opacity:var(--mdc-ripple-fg-opacity, 0)}to{opacity:0}}.mdc-text-field--filled{--mdc-ripple-fg-size: 0;--mdc-ripple-left: 0;--mdc-ripple-top: 0;--mdc-ripple-fg-scale: 1;--mdc-ripple-fg-translate-end: 0;--mdc-ripple-fg-translate-start: 0;-webkit-tap-highlight-color:rgba(0,0,0,0);will-change:transform,opacity}.mdc-text-field--filled .mdc-text-field__ripple::before,.mdc-text-field--filled .mdc-text-field__ripple::after{position:absolute;border-radius:50%;opacity:0;pointer-events:none;content:""}.mdc-text-field--filled .mdc-text-field__ripple::before{transition:opacity 15ms linear,background-color 15ms linear;z-index:1;z-index:var(--mdc-ripple-z-index, 1)}.mdc-text-field--filled .mdc-text-field__ripple::after{z-index:0;z-index:var(--mdc-ripple-z-index, 0)}.mdc-text-field--filled.mdc-ripple-upgraded .mdc-text-field__ripple::before{transform:scale(var(--mdc-ripple-fg-scale, 1))}.mdc-text-field--filled.mdc-ripple-upgraded .mdc-text-field__ripple::after{top:0;left:0;transform:scale(0);transform-origin:center center}.mdc-text-field--filled.mdc-ripple-upgraded--unbounded .mdc-text-field__ripple::after{top:var(--mdc-ripple-top, 0);left:var(--mdc-ripple-left, 0)}.mdc-text-field--filled.mdc-ripple-upgraded--foreground-activation .mdc-text-field__ripple::after{animation:mdc-ripple-fg-radius-in 225ms forwards,mdc-ripple-fg-opacity-in 75ms forwards}.mdc-text-field--filled.mdc-ripple-upgraded--foreground-deactivation .mdc-text-field__ripple::after{animation:mdc-ripple-fg-opacity-out 150ms;transform:translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1))}.mdc-text-field--filled .mdc-text-field__ripple::before,.mdc-text-field--filled .mdc-text-field__ripple::after{top:calc(50% - 100%);left:calc(50% - 100%);width:200%;height:200%}.mdc-text-field--filled.mdc-ripple-upgraded .mdc-text-field__ripple::after{width:var(--mdc-ripple-fg-size, 100%);height:var(--mdc-ripple-fg-size, 100%)}.mdc-text-field__ripple{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none}.mdc-text-field{border-top-left-radius:4px;border-top-left-radius:var(--mdc-shape-small, 4px);border-top-right-radius:4px;border-top-right-radius:var(--mdc-shape-small, 4px);border-bottom-right-radius:0;border-bottom-left-radius:0;display:inline-flex;align-items:baseline;padding:0 16px;position:relative;box-sizing:border-box;overflow:hidden;will-change:opacity,transform,color}.mdc-text-field:not(.mdc-text-field--disabled) .mdc-floating-label{color:rgba(0, 0, 0, 0.6)}.mdc-text-field:not(.mdc-text-field--disabled) .mdc-text-field__input{color:rgba(0, 0, 0, 0.87)}@media all{.mdc-text-field:not(.mdc-text-field--disabled) .mdc-text-field__input::placeholder{color:rgba(0, 0, 0, 0.54)}}@media all{.mdc-text-field:not(.mdc-text-field--disabled) .mdc-text-field__input:-ms-input-placeholder{color:rgba(0, 0, 0, 0.54)}}.mdc-text-field .mdc-text-field__input{caret-color:#6200ee;caret-color:var(--mdc-theme-primary, #6200ee)}.mdc-text-field:not(.mdc-text-field--disabled)+.mdc-text-field-helper-line .mdc-text-field-helper-text{color:rgba(0, 0, 0, 0.6)}.mdc-text-field:not(.mdc-text-field--disabled) .mdc-text-field-character-counter,.mdc-text-field:not(.mdc-text-field--disabled)+.mdc-text-field-helper-line .mdc-text-field-character-counter{color:rgba(0, 0, 0, 0.6)}.mdc-text-field:not(.mdc-text-field--disabled) .mdc-text-field__icon--leading{color:rgba(0, 0, 0, 0.54)}.mdc-text-field:not(.mdc-text-field--disabled) .mdc-text-field__icon--trailing{color:rgba(0, 0, 0, 0.54)}.mdc-text-field:not(.mdc-text-field--disabled) .mdc-text-field__affix--prefix{color:rgba(0, 0, 0, 0.6)}.mdc-text-field:not(.mdc-text-field--disabled) .mdc-text-field__affix--suffix{color:rgba(0, 0, 0, 0.6)}.mdc-text-field .mdc-floating-label{top:50%;transform:translateY(-50%);pointer-events:none}.mdc-text-field__input{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:Roboto, sans-serif;font-family:var(--mdc-typography-subtitle1-font-family, var(--mdc-typography-font-family, Roboto, sans-serif));font-size:1rem;font-size:var(--mdc-typography-subtitle1-font-size, 1rem);font-weight:400;font-weight:var(--mdc-typography-subtitle1-font-weight, 400);letter-spacing:0.009375em;letter-spacing:var(--mdc-typography-subtitle1-letter-spacing, 0.009375em);text-decoration:inherit;text-decoration:var(--mdc-typography-subtitle1-text-decoration, inherit);text-transform:inherit;text-transform:var(--mdc-typography-subtitle1-text-transform, inherit);height:28px;transition:opacity 150ms 0ms cubic-bezier(0.4, 0, 0.2, 1);width:100%;min-width:0;border:none;border-radius:0;background:none;appearance:none;padding:0}.mdc-text-field__input::-ms-clear{display:none}.mdc-text-field__input::-webkit-calendar-picker-indicator{display:none}.mdc-text-field__input:focus{outline:none}.mdc-text-field__input:invalid{box-shadow:none}@media all{.mdc-text-field__input::placeholder{transition:opacity 67ms 0ms cubic-bezier(0.4, 0, 0.2, 1);opacity:0}}@media all{.mdc-text-field__input:-ms-input-placeholder{transition:opacity 67ms 0ms cubic-bezier(0.4, 0, 0.2, 1);opacity:0}}@media all{.mdc-text-field--no-label .mdc-text-field__input::placeholder,.mdc-text-field--focused .mdc-text-field__input::placeholder{transition-delay:40ms;transition-duration:110ms;opacity:1}}@media all{.mdc-text-field--no-label .mdc-text-field__input:-ms-input-placeholder,.mdc-text-field--focused .mdc-text-field__input:-ms-input-placeholder{transition-delay:40ms;transition-duration:110ms;opacity:1}}.mdc-text-field__affix{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:Roboto, sans-serif;font-family:var(--mdc-typography-subtitle1-font-family, var(--mdc-typography-font-family, Roboto, sans-serif));font-size:1rem;font-size:var(--mdc-typography-subtitle1-font-size, 1rem);font-weight:400;font-weight:var(--mdc-typography-subtitle1-font-weight, 400);letter-spacing:0.009375em;letter-spacing:var(--mdc-typography-subtitle1-letter-spacing, 0.009375em);text-decoration:inherit;text-decoration:var(--mdc-typography-subtitle1-text-decoration, inherit);text-transform:inherit;text-transform:var(--mdc-typography-subtitle1-text-transform, inherit);height:28px;transition:opacity 150ms 0ms cubic-bezier(0.4, 0, 0.2, 1);opacity:0;white-space:nowrap}.mdc-text-field--label-floating .mdc-text-field__affix,.mdc-text-field--no-label .mdc-text-field__affix{opacity:1}@supports(-webkit-hyphens: none){.mdc-text-field--outlined .mdc-text-field__affix{align-items:center;align-self:center;display:inline-flex;height:100%}}.mdc-text-field__affix--prefix{padding-left:0;padding-right:2px}[dir=rtl] .mdc-text-field__affix--prefix,.mdc-text-field__affix--prefix[dir=rtl]{padding-left:2px;padding-right:0}.mdc-text-field--end-aligned .mdc-text-field__affix--prefix{padding-left:0;padding-right:12px}[dir=rtl] .mdc-text-field--end-aligned .mdc-text-field__affix--prefix,.mdc-text-field--end-aligned .mdc-text-field__affix--prefix[dir=rtl]{padding-left:12px;padding-right:0}.mdc-text-field__affix--suffix{padding-left:12px;padding-right:0}[dir=rtl] .mdc-text-field__affix--suffix,.mdc-text-field__affix--suffix[dir=rtl]{padding-left:0;padding-right:12px}.mdc-text-field--end-aligned .mdc-text-field__affix--suffix{padding-left:2px;padding-right:0}[dir=rtl] .mdc-text-field--end-aligned .mdc-text-field__affix--suffix,.mdc-text-field--end-aligned .mdc-text-field__affix--suffix[dir=rtl]{padding-left:0;padding-right:2px}.mdc-text-field--filled{height:56px}.mdc-text-field--filled .mdc-text-field__ripple::before,.mdc-text-field--filled .mdc-text-field__ripple::after{background-color:rgba(0, 0, 0, 0.87);background-color:var(--mdc-ripple-color, rgba(0, 0, 0, 0.87))}.mdc-text-field--filled:hover .mdc-text-field__ripple::before,.mdc-text-field--filled.mdc-ripple-surface--hover .mdc-text-field__ripple::before{opacity:0.04;opacity:var(--mdc-ripple-hover-opacity, 0.04)}.mdc-text-field--filled.mdc-ripple-upgraded--background-focused .mdc-text-field__ripple::before,.mdc-text-field--filled:not(.mdc-ripple-upgraded):focus .mdc-text-field__ripple::before{transition-duration:75ms;opacity:0.12;opacity:var(--mdc-ripple-focus-opacity, 0.12)}.mdc-text-field--filled::before{display:inline-block;width:0;height:40px;content:"";vertical-align:0}.mdc-text-field--filled:not(.mdc-text-field--disabled){background-color:whitesmoke}.mdc-text-field--filled:not(.mdc-text-field--disabled) .mdc-line-ripple::before{border-bottom-color:rgba(0, 0, 0, 0.42)}.mdc-text-field--filled:not(.mdc-text-field--disabled):hover .mdc-line-ripple::before{border-bottom-color:rgba(0, 0, 0, 0.87)}.mdc-text-field--filled .mdc-line-ripple::after{border-bottom-color:#6200ee;border-bottom-color:var(--mdc-theme-primary, #6200ee)}.mdc-text-field--filled .mdc-floating-label{left:16px;right:initial}[dir=rtl] .mdc-text-field--filled .mdc-floating-label,.mdc-text-field--filled .mdc-floating-label[dir=rtl]{left:initial;right:16px}.mdc-text-field--filled .mdc-floating-label--float-above{transform:translateY(-106%) scale(0.75)}.mdc-text-field--filled.mdc-text-field--no-label .mdc-text-field__input{height:100%}.mdc-text-field--filled.mdc-text-field--no-label .mdc-floating-label{display:none}.mdc-text-field--filled.mdc-text-field--no-label::before{display:none}@supports(-webkit-hyphens: none){.mdc-text-field--filled.mdc-text-field--no-label .mdc-text-field__affix{align-items:center;align-self:center;display:inline-flex;height:100%}}.mdc-text-field--outlined{height:56px;overflow:visible}.mdc-text-field--outlined .mdc-floating-label--float-above{transform:translateY(-37.25px) scale(1)}.mdc-text-field--outlined .mdc-floating-label--float-above{font-size:.75rem}.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{transform:translateY(-34.75px) scale(0.75)}.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:1rem}.mdc-text-field--outlined .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-text-field-outlined 250ms 1}@keyframes mdc-floating-label-shake-float-above-text-field-outlined{0%{transform:translateX(calc(0 - 0%)) translateY(-34.75px) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 0%)) translateY(-34.75px) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 0%)) translateY(-34.75px) scale(0.75)}100%{transform:translateX(calc(0 - 0%)) translateY(-34.75px) scale(0.75)}}.mdc-text-field--outlined .mdc-text-field__input{height:100%}.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-notched-outline__leading,.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-notched-outline__notch,.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-notched-outline__trailing{border-color:rgba(0, 0, 0, 0.38)}.mdc-text-field--outlined:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--outlined:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-notched-outline .mdc-notched-outline__notch,.mdc-text-field--outlined:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-notched-outline .mdc-notched-outline__trailing{border-color:rgba(0, 0, 0, 0.87)}.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__leading,.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__notch,.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__trailing{border-color:#6200ee;border-color:var(--mdc-theme-primary, #6200ee)}.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading{border-top-left-radius:4px;border-top-left-radius:var(--mdc-shape-small, 4px);border-top-right-radius:0;border-bottom-right-radius:0;border-bottom-left-radius:4px;border-bottom-left-radius:var(--mdc-shape-small, 4px)}[dir=rtl] .mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading[dir=rtl]{border-top-left-radius:0;border-top-right-radius:4px;border-top-right-radius:var(--mdc-shape-small, 4px);border-bottom-right-radius:4px;border-bottom-right-radius:var(--mdc-shape-small, 4px);border-bottom-left-radius:0}@supports(top: max(0%)){.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading{width:max(12px, var(--mdc-shape-small, 4px))}}@supports(top: max(0%)){.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__notch{max-width:calc(100% - max(12px, var(--mdc-shape-small, 4px)) * 2)}}.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__trailing{border-top-left-radius:0;border-top-right-radius:4px;border-top-right-radius:var(--mdc-shape-small, 4px);border-bottom-right-radius:4px;border-bottom-right-radius:var(--mdc-shape-small, 4px);border-bottom-left-radius:0}[dir=rtl] .mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__trailing,.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__trailing[dir=rtl]{border-top-left-radius:4px;border-top-left-radius:var(--mdc-shape-small, 4px);border-top-right-radius:0;border-bottom-right-radius:0;border-bottom-left-radius:4px;border-bottom-left-radius:var(--mdc-shape-small, 4px)}@supports(top: max(0%)){.mdc-text-field--outlined{padding-left:max(16px, calc(var(--mdc-shape-small, 4px) + 4px))}}@supports(top: max(0%)){.mdc-text-field--outlined{padding-right:max(16px, var(--mdc-shape-small, 4px))}}@supports(top: max(0%)){.mdc-text-field--outlined+.mdc-text-field-helper-line{padding-left:max(16px, calc(var(--mdc-shape-small, 4px) + 4px))}}@supports(top: max(0%)){.mdc-text-field--outlined+.mdc-text-field-helper-line{padding-right:max(16px, var(--mdc-shape-small, 4px))}}.mdc-text-field--outlined.mdc-text-field--with-leading-icon{padding-left:0}@supports(top: max(0%)){.mdc-text-field--outlined.mdc-text-field--with-leading-icon{padding-right:max(16px, var(--mdc-shape-small, 4px))}}[dir=rtl] .mdc-text-field--outlined.mdc-text-field--with-leading-icon,.mdc-text-field--outlined.mdc-text-field--with-leading-icon[dir=rtl]{padding-right:0}@supports(top: max(0%)){[dir=rtl] .mdc-text-field--outlined.mdc-text-field--with-leading-icon,.mdc-text-field--outlined.mdc-text-field--with-leading-icon[dir=rtl]{padding-left:max(16px, var(--mdc-shape-small, 4px))}}.mdc-text-field--outlined.mdc-text-field--with-trailing-icon{padding-right:0}@supports(top: max(0%)){.mdc-text-field--outlined.mdc-text-field--with-trailing-icon{padding-left:max(16px, calc(var(--mdc-shape-small, 4px) + 4px))}}[dir=rtl] .mdc-text-field--outlined.mdc-text-field--with-trailing-icon,.mdc-text-field--outlined.mdc-text-field--with-trailing-icon[dir=rtl]{padding-left:0}@supports(top: max(0%)){[dir=rtl] .mdc-text-field--outlined.mdc-text-field--with-trailing-icon,.mdc-text-field--outlined.mdc-text-field--with-trailing-icon[dir=rtl]{padding-right:max(16px, calc(var(--mdc-shape-small, 4px) + 4px))}}.mdc-text-field--outlined.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon{padding-left:0;padding-right:0}.mdc-text-field--outlined .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-top:1px}.mdc-text-field--outlined .mdc-text-field__ripple::before,.mdc-text-field--outlined .mdc-text-field__ripple::after{content:none}.mdc-text-field--outlined .mdc-floating-label{left:4px;right:initial}[dir=rtl] .mdc-text-field--outlined .mdc-floating-label,.mdc-text-field--outlined .mdc-floating-label[dir=rtl]{left:initial;right:4px}.mdc-text-field--outlined .mdc-text-field__input{display:flex;border:none !important;background-color:transparent}.mdc-text-field--outlined .mdc-notched-outline{z-index:1}.mdc-text-field--textarea{flex-direction:column;align-items:center;width:auto;height:auto;padding:0;transition:none}.mdc-text-field--textarea .mdc-floating-label{top:19px}.mdc-text-field--textarea .mdc-floating-label:not(.mdc-floating-label--float-above){transform:none}.mdc-text-field--textarea .mdc-text-field__input{flex-grow:1;height:auto;min-height:1.5rem;overflow-x:hidden;overflow-y:auto;box-sizing:border-box;resize:none;padding:0 16px;line-height:1.5rem}.mdc-text-field--textarea.mdc-text-field--filled::before{display:none}.mdc-text-field--textarea.mdc-text-field--filled .mdc-floating-label--float-above{transform:translateY(-10.25px) scale(0.75)}.mdc-text-field--textarea.mdc-text-field--filled .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-textarea-filled 250ms 1}@keyframes mdc-floating-label-shake-float-above-textarea-filled{0%{transform:translateX(calc(0 - 0%)) translateY(-10.25px) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 0%)) translateY(-10.25px) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 0%)) translateY(-10.25px) scale(0.75)}100%{transform:translateX(calc(0 - 0%)) translateY(-10.25px) scale(0.75)}}.mdc-text-field--textarea.mdc-text-field--filled .mdc-text-field__input{margin-top:23px;margin-bottom:9px}.mdc-text-field--textarea.mdc-text-field--filled.mdc-text-field--no-label .mdc-text-field__input{margin-top:16px;margin-bottom:16px}.mdc-text-field--textarea.mdc-text-field--outlined .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-top:0}.mdc-text-field--textarea.mdc-text-field--outlined .mdc-floating-label--float-above{transform:translateY(-27.25px) scale(1)}.mdc-text-field--textarea.mdc-text-field--outlined .mdc-floating-label--float-above{font-size:.75rem}.mdc-text-field--textarea.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--textarea.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{transform:translateY(-24.75px) scale(0.75)}.mdc-text-field--textarea.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--textarea.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:1rem}.mdc-text-field--textarea.mdc-text-field--outlined .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-textarea-outlined 250ms 1}@keyframes mdc-floating-label-shake-float-above-textarea-outlined{0%{transform:translateX(calc(0 - 0%)) translateY(-24.75px) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 0%)) translateY(-24.75px) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 0%)) translateY(-24.75px) scale(0.75)}100%{transform:translateX(calc(0 - 0%)) translateY(-24.75px) scale(0.75)}}.mdc-text-field--textarea.mdc-text-field--outlined .mdc-text-field__input{margin-top:16px;margin-bottom:16px}.mdc-text-field--textarea.mdc-text-field--outlined .mdc-floating-label{top:18px}.mdc-text-field--textarea.mdc-text-field--with-internal-counter .mdc-text-field__input{margin-bottom:2px}.mdc-text-field--textarea.mdc-text-field--with-internal-counter .mdc-text-field-character-counter{align-self:flex-end;padding:0 16px}.mdc-text-field--textarea.mdc-text-field--with-internal-counter .mdc-text-field-character-counter::after{display:inline-block;width:0;height:16px;content:"";vertical-align:-16px}.mdc-text-field--textarea.mdc-text-field--with-internal-counter .mdc-text-field-character-counter::before{display:none}.mdc-text-field__resizer{align-self:stretch;display:inline-flex;flex-direction:column;flex-grow:1;max-height:100%;max-width:100%;min-height:56px;min-width:fit-content;min-width:-moz-available;min-width:-webkit-fill-available;overflow:hidden;resize:both}.mdc-text-field--filled .mdc-text-field__resizer{transform:translateY(-1px)}.mdc-text-field--filled .mdc-text-field__resizer .mdc-text-field__input,.mdc-text-field--filled .mdc-text-field__resizer .mdc-text-field-character-counter{transform:translateY(1px)}.mdc-text-field--outlined .mdc-text-field__resizer{transform:translateX(-1px) translateY(-1px)}[dir=rtl] .mdc-text-field--outlined .mdc-text-field__resizer,.mdc-text-field--outlined .mdc-text-field__resizer[dir=rtl]{transform:translateX(1px) translateY(-1px)}.mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field__input,.mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field-character-counter{transform:translateX(1px) translateY(1px)}[dir=rtl] .mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field__input,[dir=rtl] .mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field-character-counter,.mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field__input[dir=rtl],.mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field-character-counter[dir=rtl]{transform:translateX(-1px) translateY(1px)}.mdc-text-field--with-leading-icon{padding-left:0;padding-right:16px}[dir=rtl] .mdc-text-field--with-leading-icon,.mdc-text-field--with-leading-icon[dir=rtl]{padding-left:16px;padding-right:0}.mdc-text-field--with-leading-icon.mdc-text-field--filled .mdc-floating-label{max-width:calc(100% - 48px);left:48px;right:initial}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--filled .mdc-floating-label,.mdc-text-field--with-leading-icon.mdc-text-field--filled .mdc-floating-label[dir=rtl]{left:initial;right:48px}.mdc-text-field--with-leading-icon.mdc-text-field--filled .mdc-floating-label--float-above{max-width:calc(100% / 0.75 - 64px / 0.75)}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label{left:36px;right:initial}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label,.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label[dir=rtl]{left:initial;right:36px}.mdc-text-field--with-leading-icon.mdc-text-field--outlined :not(.mdc-notched-outline--notched) .mdc-notched-outline__notch{max-width:calc(100% - 60px)}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--float-above{transform:translateY(-37.25px) translateX(-32px) scale(1)}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--float-above[dir=rtl]{transform:translateY(-37.25px) translateX(32px) scale(1)}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--float-above{font-size:.75rem}.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{transform:translateY(-34.75px) translateX(-32px) scale(0.75)}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above[dir=rtl],.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above[dir=rtl]{transform:translateY(-34.75px) translateX(32px) scale(0.75)}.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:1rem}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-text-field-outlined-leading-icon 250ms 1}@keyframes mdc-floating-label-shake-float-above-text-field-outlined-leading-icon{0%{transform:translateX(calc(0 - 32px)) translateY(-34.75px) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 32px)) translateY(-34.75px) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 32px)) translateY(-34.75px) scale(0.75)}100%{transform:translateX(calc(0 - 32px)) translateY(-34.75px) scale(0.75)}}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--shake,.mdc-text-field--with-leading-icon.mdc-text-field--outlined[dir=rtl] .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-text-field-outlined-leading-icon 250ms 1}@keyframes mdc-floating-label-shake-float-above-text-field-outlined-leading-icon-rtl{0%{transform:translateX(calc(0 - -32px)) translateY(-34.75px) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - -32px)) translateY(-34.75px) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - -32px)) translateY(-34.75px) scale(0.75)}100%{transform:translateX(calc(0 - -32px)) translateY(-34.75px) scale(0.75)}}.mdc-text-field--with-trailing-icon{padding-left:16px;padding-right:0}[dir=rtl] .mdc-text-field--with-trailing-icon,.mdc-text-field--with-trailing-icon[dir=rtl]{padding-left:0;padding-right:16px}.mdc-text-field--with-trailing-icon.mdc-text-field--filled .mdc-floating-label{max-width:calc(100% - 64px)}.mdc-text-field--with-trailing-icon.mdc-text-field--filled .mdc-floating-label--float-above{max-width:calc(100% / 0.75 - 64px / 0.75)}.mdc-text-field--with-trailing-icon.mdc-text-field--outlined :not(.mdc-notched-outline--notched) .mdc-notched-outline__notch{max-width:calc(100% - 60px)}.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon{padding-left:0;padding-right:0}.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon.mdc-text-field--filled .mdc-floating-label{max-width:calc(100% - 96px)}.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon.mdc-text-field--filled .mdc-floating-label--float-above{max-width:calc(100% / 0.75 - 96px / 0.75)}.mdc-text-field-helper-line{display:flex;justify-content:space-between;box-sizing:border-box}.mdc-text-field+.mdc-text-field-helper-line{padding-right:16px;padding-left:16px}.mdc-form-field>.mdc-text-field+label{align-self:flex-start}.mdc-text-field--focused:not(.mdc-text-field--disabled) .mdc-floating-label{color:rgba(98, 0, 238, 0.87)}.mdc-text-field--focused .mdc-notched-outline__leading,.mdc-text-field--focused .mdc-notched-outline__notch,.mdc-text-field--focused .mdc-notched-outline__trailing{border-width:2px}.mdc-text-field--focused+.mdc-text-field-helper-line .mdc-text-field-helper-text:not(.mdc-text-field-helper-text--validation-msg){opacity:1}.mdc-text-field--focused.mdc-text-field--outlined .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-top:2px}.mdc-text-field--focused.mdc-text-field--outlined.mdc-text-field--textarea .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-top:0}.mdc-text-field--invalid:not(.mdc-text-field--disabled):hover .mdc-line-ripple::before{border-bottom-color:#b00020;border-bottom-color:var(--mdc-theme-error, #b00020)}.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-line-ripple::after{border-bottom-color:#b00020;border-bottom-color:var(--mdc-theme-error, #b00020)}.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-floating-label{color:#b00020;color:var(--mdc-theme-error, #b00020)}.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--invalid+.mdc-text-field-helper-line .mdc-text-field-helper-text--validation-msg{color:#b00020;color:var(--mdc-theme-error, #b00020)}.mdc-text-field--invalid .mdc-text-field__input{caret-color:#b00020;caret-color:var(--mdc-theme-error, #b00020)}.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-text-field__icon--trailing{color:#b00020;color:var(--mdc-theme-error, #b00020)}.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-line-ripple::before{border-bottom-color:#b00020;border-bottom-color:var(--mdc-theme-error, #b00020)}.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-notched-outline__leading,.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-notched-outline__notch,.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-notched-outline__trailing{border-color:#b00020;border-color:var(--mdc-theme-error, #b00020)}.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-notched-outline .mdc-notched-outline__notch,.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-notched-outline .mdc-notched-outline__trailing{border-color:#b00020;border-color:var(--mdc-theme-error, #b00020)}.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__leading,.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__notch,.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__trailing{border-color:#b00020;border-color:var(--mdc-theme-error, #b00020)}.mdc-text-field--invalid+.mdc-text-field-helper-line .mdc-text-field-helper-text--validation-msg{opacity:1}.mdc-text-field--disabled{pointer-events:none}.mdc-text-field--disabled .mdc-text-field__input{color:rgba(0, 0, 0, 0.38)}@media all{.mdc-text-field--disabled .mdc-text-field__input::placeholder{color:rgba(0, 0, 0, 0.38)}}@media all{.mdc-text-field--disabled .mdc-text-field__input:-ms-input-placeholder{color:rgba(0, 0, 0, 0.38)}}.mdc-text-field--disabled .mdc-floating-label{color:rgba(0, 0, 0, 0.38)}.mdc-text-field--disabled+.mdc-text-field-helper-line .mdc-text-field-helper-text{color:rgba(0, 0, 0, 0.38)}.mdc-text-field--disabled .mdc-text-field-character-counter,.mdc-text-field--disabled+.mdc-text-field-helper-line .mdc-text-field-character-counter{color:rgba(0, 0, 0, 0.38)}.mdc-text-field--disabled .mdc-text-field__icon--leading{color:rgba(0, 0, 0, 0.3)}.mdc-text-field--disabled .mdc-text-field__icon--trailing{color:rgba(0, 0, 0, 0.3)}.mdc-text-field--disabled .mdc-text-field__affix--prefix{color:rgba(0, 0, 0, 0.38)}.mdc-text-field--disabled .mdc-text-field__affix--suffix{color:rgba(0, 0, 0, 0.38)}.mdc-text-field--disabled .mdc-line-ripple::before{border-bottom-color:rgba(0, 0, 0, 0.06)}.mdc-text-field--disabled .mdc-notched-outline__leading,.mdc-text-field--disabled .mdc-notched-outline__notch,.mdc-text-field--disabled .mdc-notched-outline__trailing{border-color:rgba(0, 0, 0, 0.06)}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mdc-text-field--disabled .mdc-text-field__input::placeholder{color:GrayText}}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mdc-text-field--disabled .mdc-text-field__input:-ms-input-placeholder{color:GrayText}}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mdc-text-field--disabled .mdc-floating-label{color:GrayText}}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mdc-text-field--disabled+.mdc-text-field-helper-line .mdc-text-field-helper-text{color:GrayText}}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mdc-text-field--disabled .mdc-text-field-character-counter,.mdc-text-field--disabled+.mdc-text-field-helper-line .mdc-text-field-character-counter{color:GrayText}}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mdc-text-field--disabled .mdc-text-field__icon--leading{color:GrayText}}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mdc-text-field--disabled .mdc-text-field__icon--trailing{color:GrayText}}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mdc-text-field--disabled .mdc-text-field__affix--prefix{color:GrayText}}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mdc-text-field--disabled .mdc-text-field__affix--suffix{color:GrayText}}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mdc-text-field--disabled .mdc-line-ripple::before{border-bottom-color:GrayText}}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mdc-text-field--disabled .mdc-notched-outline__leading,.mdc-text-field--disabled .mdc-notched-outline__notch,.mdc-text-field--disabled .mdc-notched-outline__trailing{border-color:GrayText}}@media screen and (forced-colors: active){.mdc-text-field--disabled .mdc-text-field__input{background-color:Window}.mdc-text-field--disabled .mdc-floating-label{z-index:1}}.mdc-text-field--disabled .mdc-floating-label{cursor:default}.mdc-text-field--disabled.mdc-text-field--filled{background-color:#fafafa}.mdc-text-field--disabled.mdc-text-field--filled .mdc-text-field__ripple{display:none}.mdc-text-field--disabled .mdc-text-field__input{pointer-events:auto}.mdc-text-field--end-aligned .mdc-text-field__input{text-align:right}[dir=rtl] .mdc-text-field--end-aligned .mdc-text-field__input,.mdc-text-field--end-aligned .mdc-text-field__input[dir=rtl]{text-align:left}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__input,[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__affix,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__input,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__affix{direction:ltr}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__affix--prefix,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__affix--prefix{padding-left:0;padding-right:2px}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__affix--suffix,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__affix--suffix{padding-left:12px;padding-right:0}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__icon--leading,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__icon--leading{order:1}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__affix--suffix,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__affix--suffix{order:2}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__input,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__input{order:3}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__affix--prefix,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__affix--prefix{order:4}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__icon--trailing,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__icon--trailing{order:5}[dir=rtl] .mdc-text-field--ltr-text.mdc-text-field--end-aligned .mdc-text-field__input,.mdc-text-field--ltr-text.mdc-text-field--end-aligned[dir=rtl] .mdc-text-field__input{text-align:right}[dir=rtl] .mdc-text-field--ltr-text.mdc-text-field--end-aligned .mdc-text-field__affix--prefix,.mdc-text-field--ltr-text.mdc-text-field--end-aligned[dir=rtl] .mdc-text-field__affix--prefix{padding-right:12px}[dir=rtl] .mdc-text-field--ltr-text.mdc-text-field--end-aligned .mdc-text-field__affix--suffix,.mdc-text-field--ltr-text.mdc-text-field--end-aligned[dir=rtl] .mdc-text-field__affix--suffix{padding-left:2px}.mdc-text-field-helper-text{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:Roboto, sans-serif;font-family:var(--mdc-typography-caption-font-family, var(--mdc-typography-font-family, Roboto, sans-serif));font-size:0.75rem;font-size:var(--mdc-typography-caption-font-size, 0.75rem);line-height:1.25rem;line-height:var(--mdc-typography-caption-line-height, 1.25rem);font-weight:400;font-weight:var(--mdc-typography-caption-font-weight, 400);letter-spacing:0.0333333333em;letter-spacing:var(--mdc-typography-caption-letter-spacing, 0.0333333333em);text-decoration:inherit;text-decoration:var(--mdc-typography-caption-text-decoration, inherit);text-transform:inherit;text-transform:var(--mdc-typography-caption-text-transform, inherit);display:block;margin-top:0;line-height:normal;margin:0;opacity:0;will-change:opacity;transition:opacity 150ms 0ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-text-field-helper-text::before{display:inline-block;width:0;height:16px;content:"";vertical-align:0}.mdc-text-field-helper-text--persistent{transition:none;opacity:1;will-change:initial}.mdc-text-field-character-counter{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:Roboto, sans-serif;font-family:var(--mdc-typography-caption-font-family, var(--mdc-typography-font-family, Roboto, sans-serif));font-size:0.75rem;font-size:var(--mdc-typography-caption-font-size, 0.75rem);line-height:1.25rem;line-height:var(--mdc-typography-caption-line-height, 1.25rem);font-weight:400;font-weight:var(--mdc-typography-caption-font-weight, 400);letter-spacing:0.0333333333em;letter-spacing:var(--mdc-typography-caption-letter-spacing, 0.0333333333em);text-decoration:inherit;text-decoration:var(--mdc-typography-caption-text-decoration, inherit);text-transform:inherit;text-transform:var(--mdc-typography-caption-text-transform, inherit);display:block;margin-top:0;line-height:normal;margin-left:auto;margin-right:0;padding-left:16px;padding-right:0;white-space:nowrap}.mdc-text-field-character-counter::before{display:inline-block;width:0;height:16px;content:"";vertical-align:0}[dir=rtl] .mdc-text-field-character-counter,.mdc-text-field-character-counter[dir=rtl]{margin-left:0;margin-right:auto}[dir=rtl] .mdc-text-field-character-counter,.mdc-text-field-character-counter[dir=rtl]{padding-left:0;padding-right:16px}.mdc-text-field__icon{align-self:center;cursor:pointer}.mdc-text-field__icon:not([tabindex]),.mdc-text-field__icon[tabindex="-1"]{cursor:default;pointer-events:none}.mdc-text-field__icon svg{display:block}.mdc-text-field__icon--leading{margin-left:16px;margin-right:8px}[dir=rtl] .mdc-text-field__icon--leading,.mdc-text-field__icon--leading[dir=rtl]{margin-left:8px;margin-right:16px}.mdc-text-field__icon--trailing{padding:12px;margin-left:0px;margin-right:0px}[dir=rtl] .mdc-text-field__icon--trailing,.mdc-text-field__icon--trailing[dir=rtl]{margin-left:0px;margin-right:0px}.material-icons{font-family:var(--mdc-icon-font, "Material Icons");font-weight:normal;font-style:normal;font-size:var(--mdc-icon-size, 24px);line-height:1;letter-spacing:normal;text-transform:none;display:inline-block;white-space:nowrap;word-wrap:normal;direction:ltr;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;-moz-osx-font-smoothing:grayscale;font-feature-settings:"liga"}:host{display:inline-flex;flex-direction:column;outline:none}.mdc-text-field{width:100%}.mdc-text-field:not(.mdc-text-field--disabled) .mdc-line-ripple::before{border-bottom-color:rgba(0, 0, 0, 0.42);border-bottom-color:var(--mdc-text-field-idle-line-color, rgba(0, 0, 0, 0.42))}.mdc-text-field:not(.mdc-text-field--disabled):hover .mdc-line-ripple::before{border-bottom-color:rgba(0, 0, 0, 0.87);border-bottom-color:var(--mdc-text-field-hover-line-color, rgba(0, 0, 0, 0.87))}.mdc-text-field.mdc-text-field--disabled .mdc-line-ripple::before{border-bottom-color:rgba(0, 0, 0, 0.06);border-bottom-color:var(--mdc-text-field-disabled-line-color, rgba(0, 0, 0, 0.06))}.mdc-text-field.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-line-ripple::before{border-bottom-color:#b00020;border-bottom-color:var(--mdc-theme-error, #b00020)}.mdc-text-field__input{direction:inherit}mwc-notched-outline{--mdc-notched-outline-border-color: var( --mdc-text-field-outlined-idle-border-color, rgba(0, 0, 0, 0.38) )}:host(:not([disabled]):hover) :not(.mdc-text-field--invalid):not(.mdc-text-field--focused) mwc-notched-outline{--mdc-notched-outline-border-color: var( --mdc-text-field-outlined-hover-border-color, rgba(0, 0, 0, 0.87) )}:host(:not([disabled])) .mdc-text-field:not(.mdc-text-field--outlined){background-color:var(--mdc-text-field-fill-color, whitesmoke)}:host(:not([disabled])) .mdc-text-field.mdc-text-field--invalid mwc-notched-outline{--mdc-notched-outline-border-color: var( --mdc-text-field-error-color, var(--mdc-theme-error, #b00020) )}:host(:not([disabled])) .mdc-text-field.mdc-text-field--invalid+.mdc-text-field-helper-line .mdc-text-field-character-counter,:host(:not([disabled])) .mdc-text-field.mdc-text-field--invalid .mdc-text-field__icon{color:var(--mdc-text-field-error-color, var(--mdc-theme-error, #b00020))}:host(:not([disabled])) .mdc-text-field:not(.mdc-text-field--invalid):not(.mdc-text-field--focused) .mdc-floating-label,:host(:not([disabled])) .mdc-text-field:not(.mdc-text-field--invalid):not(.mdc-text-field--focused) .mdc-floating-label::after{color:var(--mdc-text-field-label-ink-color, rgba(0, 0, 0, 0.6))}:host(:not([disabled])) .mdc-text-field.mdc-text-field--focused mwc-notched-outline{--mdc-notched-outline-stroke-width: 2px}:host(:not([disabled])) .mdc-text-field.mdc-text-field--focused:not(.mdc-text-field--invalid) mwc-notched-outline{--mdc-notched-outline-border-color: var( --mdc-text-field-focused-label-color, var(--mdc-theme-primary, rgba(98, 0, 238, 0.87)) )}:host(:not([disabled])) .mdc-text-field.mdc-text-field--focused:not(.mdc-text-field--invalid) .mdc-floating-label{color:#6200ee;color:var(--mdc-theme-primary, #6200ee)}:host(:not([disabled])) .mdc-text-field .mdc-text-field__input{color:var(--mdc-text-field-ink-color, rgba(0, 0, 0, 0.87))}:host(:not([disabled])) .mdc-text-field .mdc-text-field__input::placeholder{color:var(--mdc-text-field-label-ink-color, rgba(0, 0, 0, 0.6))}:host(:not([disabled])) .mdc-text-field-helper-line .mdc-text-field-helper-text:not(.mdc-text-field-helper-text--validation-msg),:host(:not([disabled])) .mdc-text-field-helper-line:not(.mdc-text-field--invalid) .mdc-text-field-character-counter{color:var(--mdc-text-field-label-ink-color, rgba(0, 0, 0, 0.6))}:host([disabled]) .mdc-text-field:not(.mdc-text-field--outlined){background-color:var(--mdc-text-field-disabled-fill-color, #fafafa)}:host([disabled]) .mdc-text-field.mdc-text-field--outlined mwc-notched-outline{--mdc-notched-outline-border-color: var( --mdc-text-field-outlined-disabled-border-color, rgba(0, 0, 0, 0.06) )}:host([disabled]) .mdc-text-field:not(.mdc-text-field--invalid):not(.mdc-text-field--focused) .mdc-floating-label,:host([disabled]) .mdc-text-field:not(.mdc-text-field--invalid):not(.mdc-text-field--focused) .mdc-floating-label::after{color:var(--mdc-text-field-disabled-ink-color, rgba(0, 0, 0, 0.38))}:host([disabled]) .mdc-text-field .mdc-text-field__input,:host([disabled]) .mdc-text-field .mdc-text-field__input::placeholder{color:var(--mdc-text-field-disabled-ink-color, rgba(0, 0, 0, 0.38))}:host([disabled]) .mdc-text-field-helper-line .mdc-text-field-helper-text,:host([disabled]) .mdc-text-field-helper-line .mdc-text-field-character-counter{color:var(--mdc-text-field-disabled-ink-color, rgba(0, 0, 0, 0.38))}`;

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCFoundation = /** @class */ (function () {
    function MDCFoundation(adapter) {
        if (adapter === void 0) { adapter = {}; }
        this.adapter = adapter;
    }
    Object.defineProperty(MDCFoundation, "cssClasses", {
        get: function () {
            // Classes extending MDCFoundation should implement this method to return an object which exports every
            // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
            return {};
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MDCFoundation, "strings", {
        get: function () {
            // Classes extending MDCFoundation should implement this method to return an object which exports all
            // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
            return {};
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MDCFoundation, "numbers", {
        get: function () {
            // Classes extending MDCFoundation should implement this method to return an object which exports all
            // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
            return {};
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MDCFoundation, "defaultAdapter", {
        get: function () {
            // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
            // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
            // validation.
            return {};
        },
        enumerable: false,
        configurable: true
    });
    MDCFoundation.prototype.init = function () {
        // Subclasses should override this method to perform initialization routines (registering events, etc.)
    };
    MDCFoundation.prototype.destroy = function () {
        // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
    };
    return MDCFoundation;
}());

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var strings = {
    ARIA_CONTROLS: 'aria-controls',
    ARIA_DESCRIBEDBY: 'aria-describedby',
    INPUT_SELECTOR: '.mdc-text-field__input',
    LABEL_SELECTOR: '.mdc-floating-label',
    LEADING_ICON_SELECTOR: '.mdc-text-field__icon--leading',
    LINE_RIPPLE_SELECTOR: '.mdc-line-ripple',
    OUTLINE_SELECTOR: '.mdc-notched-outline',
    PREFIX_SELECTOR: '.mdc-text-field__affix--prefix',
    SUFFIX_SELECTOR: '.mdc-text-field__affix--suffix',
    TRAILING_ICON_SELECTOR: '.mdc-text-field__icon--trailing'
};
var cssClasses = {
    DISABLED: 'mdc-text-field--disabled',
    FOCUSED: 'mdc-text-field--focused',
    HELPER_LINE: 'mdc-text-field-helper-line',
    INVALID: 'mdc-text-field--invalid',
    LABEL_FLOATING: 'mdc-text-field--label-floating',
    NO_LABEL: 'mdc-text-field--no-label',
    OUTLINED: 'mdc-text-field--outlined',
    ROOT: 'mdc-text-field',
    TEXTAREA: 'mdc-text-field--textarea',
    WITH_LEADING_ICON: 'mdc-text-field--with-leading-icon',
    WITH_TRAILING_ICON: 'mdc-text-field--with-trailing-icon',
    WITH_INTERNAL_COUNTER: 'mdc-text-field--with-internal-counter',
};
var numbers = {
    LABEL_SCALE: 0.75,
};
/**
 * Whitelist based off of
 * https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/Constraint_validation
 * under the "Validation-related attributes" section.
 */
var VALIDATION_ATTR_WHITELIST = [
    'pattern',
    'min',
    'max',
    'required',
    'step',
    'minlength',
    'maxlength',
];
/**
 * Label should always float for these types as they show some UI even if value
 * is empty.
 */
var ALWAYS_FLOAT_TYPES = [
    'color',
    'date',
    'datetime-local',
    'month',
    'range',
    'time',
    'week',
];

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var POINTERDOWN_EVENTS = ['mousedown', 'touchstart'];
var INTERACTION_EVENTS = ['click', 'keydown'];
var MDCTextFieldFoundation = /** @class */ (function (_super) {
    __extends(MDCTextFieldFoundation, _super);
    /**
     * @param adapter
     * @param foundationMap Map from subcomponent names to their subfoundations.
     */
    function MDCTextFieldFoundation(adapter, foundationMap) {
        if (foundationMap === void 0) { foundationMap = {}; }
        var _this = _super.call(this, __assign(__assign({}, MDCTextFieldFoundation.defaultAdapter), adapter)) || this;
        _this.isFocused = false;
        _this.receivedUserInput = false;
        _this.valid = true;
        _this.useNativeValidation = true;
        _this.validateOnValueChange = true;
        _this.helperText = foundationMap.helperText;
        _this.characterCounter = foundationMap.characterCounter;
        _this.leadingIcon = foundationMap.leadingIcon;
        _this.trailingIcon = foundationMap.trailingIcon;
        _this.inputFocusHandler = function () {
            _this.activateFocus();
        };
        _this.inputBlurHandler = function () {
            _this.deactivateFocus();
        };
        _this.inputInputHandler = function () {
            _this.handleInput();
        };
        _this.setPointerXOffset = function (evt) {
            _this.setTransformOrigin(evt);
        };
        _this.textFieldInteractionHandler = function () {
            _this.handleTextFieldInteraction();
        };
        _this.validationAttributeChangeHandler = function (attributesList) {
            _this.handleValidationAttributeChange(attributesList);
        };
        return _this;
    }
    Object.defineProperty(MDCTextFieldFoundation, "cssClasses", {
        get: function () {
            return cssClasses;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MDCTextFieldFoundation, "strings", {
        get: function () {
            return strings;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MDCTextFieldFoundation, "numbers", {
        get: function () {
            return numbers;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MDCTextFieldFoundation.prototype, "shouldAlwaysFloat", {
        get: function () {
            var type = this.getNativeInput().type;
            return ALWAYS_FLOAT_TYPES.indexOf(type) >= 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MDCTextFieldFoundation.prototype, "shouldFloat", {
        get: function () {
            return this.shouldAlwaysFloat || this.isFocused || !!this.getValue() ||
                this.isBadInput();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MDCTextFieldFoundation.prototype, "shouldShake", {
        get: function () {
            return !this.isFocused && !this.isValid() && !!this.getValue();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MDCTextFieldFoundation, "defaultAdapter", {
        /**
         * See {@link MDCTextFieldAdapter} for typing information on parameters and
         * return types.
         */
        get: function () {
            // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
            return {
                addClass: function () { return undefined; },
                removeClass: function () { return undefined; },
                hasClass: function () { return true; },
                setInputAttr: function () { return undefined; },
                removeInputAttr: function () { return undefined; },
                registerTextFieldInteractionHandler: function () { return undefined; },
                deregisterTextFieldInteractionHandler: function () { return undefined; },
                registerInputInteractionHandler: function () { return undefined; },
                deregisterInputInteractionHandler: function () { return undefined; },
                registerValidationAttributeChangeHandler: function () {
                    return new MutationObserver(function () { return undefined; });
                },
                deregisterValidationAttributeChangeHandler: function () { return undefined; },
                getNativeInput: function () { return null; },
                isFocused: function () { return false; },
                activateLineRipple: function () { return undefined; },
                deactivateLineRipple: function () { return undefined; },
                setLineRippleTransformOrigin: function () { return undefined; },
                shakeLabel: function () { return undefined; },
                floatLabel: function () { return undefined; },
                setLabelRequired: function () { return undefined; },
                hasLabel: function () { return false; },
                getLabelWidth: function () { return 0; },
                hasOutline: function () { return false; },
                notchOutline: function () { return undefined; },
                closeOutline: function () { return undefined; },
            };
            // tslint:enable:object-literal-sort-keys
        },
        enumerable: false,
        configurable: true
    });
    MDCTextFieldFoundation.prototype.init = function () {
        var e_1, _a, e_2, _b;
        if (this.adapter.hasLabel() && this.getNativeInput().required) {
            this.adapter.setLabelRequired(true);
        }
        if (this.adapter.isFocused()) {
            this.inputFocusHandler();
        }
        else if (this.adapter.hasLabel() && this.shouldFloat) {
            this.notchOutline(true);
            this.adapter.floatLabel(true);
            this.styleFloating(true);
        }
        this.adapter.registerInputInteractionHandler('focus', this.inputFocusHandler);
        this.adapter.registerInputInteractionHandler('blur', this.inputBlurHandler);
        this.adapter.registerInputInteractionHandler('input', this.inputInputHandler);
        try {
            for (var POINTERDOWN_EVENTS_1 = __values(POINTERDOWN_EVENTS), POINTERDOWN_EVENTS_1_1 = POINTERDOWN_EVENTS_1.next(); !POINTERDOWN_EVENTS_1_1.done; POINTERDOWN_EVENTS_1_1 = POINTERDOWN_EVENTS_1.next()) {
                var evtType = POINTERDOWN_EVENTS_1_1.value;
                this.adapter.registerInputInteractionHandler(evtType, this.setPointerXOffset);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (POINTERDOWN_EVENTS_1_1 && !POINTERDOWN_EVENTS_1_1.done && (_a = POINTERDOWN_EVENTS_1.return)) _a.call(POINTERDOWN_EVENTS_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        try {
            for (var INTERACTION_EVENTS_1 = __values(INTERACTION_EVENTS), INTERACTION_EVENTS_1_1 = INTERACTION_EVENTS_1.next(); !INTERACTION_EVENTS_1_1.done; INTERACTION_EVENTS_1_1 = INTERACTION_EVENTS_1.next()) {
                var evtType = INTERACTION_EVENTS_1_1.value;
                this.adapter.registerTextFieldInteractionHandler(evtType, this.textFieldInteractionHandler);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (INTERACTION_EVENTS_1_1 && !INTERACTION_EVENTS_1_1.done && (_b = INTERACTION_EVENTS_1.return)) _b.call(INTERACTION_EVENTS_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        this.validationObserver =
            this.adapter.registerValidationAttributeChangeHandler(this.validationAttributeChangeHandler);
        this.setcharacterCounter(this.getValue().length);
    };
    MDCTextFieldFoundation.prototype.destroy = function () {
        var e_3, _a, e_4, _b;
        this.adapter.deregisterInputInteractionHandler('focus', this.inputFocusHandler);
        this.adapter.deregisterInputInteractionHandler('blur', this.inputBlurHandler);
        this.adapter.deregisterInputInteractionHandler('input', this.inputInputHandler);
        try {
            for (var POINTERDOWN_EVENTS_2 = __values(POINTERDOWN_EVENTS), POINTERDOWN_EVENTS_2_1 = POINTERDOWN_EVENTS_2.next(); !POINTERDOWN_EVENTS_2_1.done; POINTERDOWN_EVENTS_2_1 = POINTERDOWN_EVENTS_2.next()) {
                var evtType = POINTERDOWN_EVENTS_2_1.value;
                this.adapter.deregisterInputInteractionHandler(evtType, this.setPointerXOffset);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (POINTERDOWN_EVENTS_2_1 && !POINTERDOWN_EVENTS_2_1.done && (_a = POINTERDOWN_EVENTS_2.return)) _a.call(POINTERDOWN_EVENTS_2);
            }
            finally { if (e_3) throw e_3.error; }
        }
        try {
            for (var INTERACTION_EVENTS_2 = __values(INTERACTION_EVENTS), INTERACTION_EVENTS_2_1 = INTERACTION_EVENTS_2.next(); !INTERACTION_EVENTS_2_1.done; INTERACTION_EVENTS_2_1 = INTERACTION_EVENTS_2.next()) {
                var evtType = INTERACTION_EVENTS_2_1.value;
                this.adapter.deregisterTextFieldInteractionHandler(evtType, this.textFieldInteractionHandler);
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (INTERACTION_EVENTS_2_1 && !INTERACTION_EVENTS_2_1.done && (_b = INTERACTION_EVENTS_2.return)) _b.call(INTERACTION_EVENTS_2);
            }
            finally { if (e_4) throw e_4.error; }
        }
        this.adapter.deregisterValidationAttributeChangeHandler(this.validationObserver);
    };
    /**
     * Handles user interactions with the Text Field.
     */
    MDCTextFieldFoundation.prototype.handleTextFieldInteraction = function () {
        var nativeInput = this.adapter.getNativeInput();
        if (nativeInput && nativeInput.disabled) {
            return;
        }
        this.receivedUserInput = true;
    };
    /**
     * Handles validation attribute changes
     */
    MDCTextFieldFoundation.prototype.handleValidationAttributeChange = function (attributesList) {
        var _this = this;
        attributesList.some(function (attributeName) {
            if (VALIDATION_ATTR_WHITELIST.indexOf(attributeName) > -1) {
                _this.styleValidity(true);
                _this.adapter.setLabelRequired(_this.getNativeInput().required);
                return true;
            }
            return false;
        });
        if (attributesList.indexOf('maxlength') > -1) {
            this.setcharacterCounter(this.getValue().length);
        }
    };
    /**
     * Opens/closes the notched outline.
     */
    MDCTextFieldFoundation.prototype.notchOutline = function (openNotch) {
        if (!this.adapter.hasOutline() || !this.adapter.hasLabel()) {
            return;
        }
        if (openNotch) {
            var labelWidth = this.adapter.getLabelWidth() * numbers.LABEL_SCALE;
            this.adapter.notchOutline(labelWidth);
        }
        else {
            this.adapter.closeOutline();
        }
    };
    /**
     * Activates the text field focus state.
     */
    MDCTextFieldFoundation.prototype.activateFocus = function () {
        this.isFocused = true;
        this.styleFocused(this.isFocused);
        this.adapter.activateLineRipple();
        if (this.adapter.hasLabel()) {
            this.notchOutline(this.shouldFloat);
            this.adapter.floatLabel(this.shouldFloat);
            this.styleFloating(this.shouldFloat);
            this.adapter.shakeLabel(this.shouldShake);
        }
        if (this.helperText &&
            (this.helperText.isPersistent() || !this.helperText.isValidation() ||
                !this.valid)) {
            this.helperText.showToScreenReader();
        }
    };
    /**
     * Sets the line ripple's transform origin, so that the line ripple activate
     * animation will animate out from the user's click location.
     */
    MDCTextFieldFoundation.prototype.setTransformOrigin = function (evt) {
        if (this.isDisabled() || this.adapter.hasOutline()) {
            return;
        }
        var touches = evt.touches;
        var targetEvent = touches ? touches[0] : evt;
        var targetClientRect = targetEvent.target.getBoundingClientRect();
        var normalizedX = targetEvent.clientX - targetClientRect.left;
        this.adapter.setLineRippleTransformOrigin(normalizedX);
    };
    /**
     * Handles input change of text input and text area.
     */
    MDCTextFieldFoundation.prototype.handleInput = function () {
        this.autoCompleteFocus();
        this.setcharacterCounter(this.getValue().length);
    };
    /**
     * Activates the Text Field's focus state in cases when the input value
     * changes without user input (e.g. programmatically).
     */
    MDCTextFieldFoundation.prototype.autoCompleteFocus = function () {
        if (!this.receivedUserInput) {
            this.activateFocus();
        }
    };
    /**
     * Deactivates the Text Field's focus state.
     */
    MDCTextFieldFoundation.prototype.deactivateFocus = function () {
        this.isFocused = false;
        this.adapter.deactivateLineRipple();
        var isValid = this.isValid();
        this.styleValidity(isValid);
        this.styleFocused(this.isFocused);
        if (this.adapter.hasLabel()) {
            this.notchOutline(this.shouldFloat);
            this.adapter.floatLabel(this.shouldFloat);
            this.styleFloating(this.shouldFloat);
            this.adapter.shakeLabel(this.shouldShake);
        }
        if (!this.shouldFloat) {
            this.receivedUserInput = false;
        }
    };
    MDCTextFieldFoundation.prototype.getValue = function () {
        return this.getNativeInput().value;
    };
    /**
     * @param value The value to set on the input Element.
     */
    MDCTextFieldFoundation.prototype.setValue = function (value) {
        // Prevent Safari from moving the caret to the end of the input when the
        // value has not changed.
        if (this.getValue() !== value) {
            this.getNativeInput().value = value;
        }
        this.setcharacterCounter(value.length);
        if (this.validateOnValueChange) {
            var isValid = this.isValid();
            this.styleValidity(isValid);
        }
        if (this.adapter.hasLabel()) {
            this.notchOutline(this.shouldFloat);
            this.adapter.floatLabel(this.shouldFloat);
            this.styleFloating(this.shouldFloat);
            if (this.validateOnValueChange) {
                this.adapter.shakeLabel(this.shouldShake);
            }
        }
    };
    /**
     * @return The custom validity state, if set; otherwise, the result of a
     *     native validity check.
     */
    MDCTextFieldFoundation.prototype.isValid = function () {
        return this.useNativeValidation ? this.isNativeInputValid() : this.valid;
    };
    /**
     * @param isValid Sets the custom validity state of the Text Field.
     */
    MDCTextFieldFoundation.prototype.setValid = function (isValid) {
        this.valid = isValid;
        this.styleValidity(isValid);
        var shouldShake = !isValid && !this.isFocused && !!this.getValue();
        if (this.adapter.hasLabel()) {
            this.adapter.shakeLabel(shouldShake);
        }
    };
    /**
     * @param shouldValidate Whether or not validity should be updated on
     *     value change.
     */
    MDCTextFieldFoundation.prototype.setValidateOnValueChange = function (shouldValidate) {
        this.validateOnValueChange = shouldValidate;
    };
    /**
     * @return Whether or not validity should be updated on value change. `true`
     *     by default.
     */
    MDCTextFieldFoundation.prototype.getValidateOnValueChange = function () {
        return this.validateOnValueChange;
    };
    /**
     * Enables or disables the use of native validation. Use this for custom
     * validation.
     * @param useNativeValidation Set this to false to ignore native input
     *     validation.
     */
    MDCTextFieldFoundation.prototype.setUseNativeValidation = function (useNativeValidation) {
        this.useNativeValidation = useNativeValidation;
    };
    MDCTextFieldFoundation.prototype.isDisabled = function () {
        return this.getNativeInput().disabled;
    };
    /**
     * @param disabled Sets the text-field disabled or enabled.
     */
    MDCTextFieldFoundation.prototype.setDisabled = function (disabled) {
        this.getNativeInput().disabled = disabled;
        this.styleDisabled(disabled);
    };
    /**
     * @param content Sets the content of the helper text.
     */
    MDCTextFieldFoundation.prototype.setHelperTextContent = function (content) {
        if (this.helperText) {
            this.helperText.setContent(content);
        }
    };
    /**
     * Sets the aria label of the leading icon.
     */
    MDCTextFieldFoundation.prototype.setLeadingIconAriaLabel = function (label) {
        if (this.leadingIcon) {
            this.leadingIcon.setAriaLabel(label);
        }
    };
    /**
     * Sets the text content of the leading icon.
     */
    MDCTextFieldFoundation.prototype.setLeadingIconContent = function (content) {
        if (this.leadingIcon) {
            this.leadingIcon.setContent(content);
        }
    };
    /**
     * Sets the aria label of the trailing icon.
     */
    MDCTextFieldFoundation.prototype.setTrailingIconAriaLabel = function (label) {
        if (this.trailingIcon) {
            this.trailingIcon.setAriaLabel(label);
        }
    };
    /**
     * Sets the text content of the trailing icon.
     */
    MDCTextFieldFoundation.prototype.setTrailingIconContent = function (content) {
        if (this.trailingIcon) {
            this.trailingIcon.setContent(content);
        }
    };
    /**
     * Sets character counter values that shows characters used and the total
     * character limit.
     */
    MDCTextFieldFoundation.prototype.setcharacterCounter = function (currentLength) {
        if (!this.characterCounter) {
            return;
        }
        var maxLength = this.getNativeInput().maxLength;
        if (maxLength === -1) {
            throw new Error('MDCTextFieldFoundation: Expected maxlength html property on text input or textarea.');
        }
        this.characterCounter.setCounterValue(currentLength, maxLength);
    };
    /**
     * @return True if the Text Field input fails in converting the user-supplied
     *     value.
     */
    MDCTextFieldFoundation.prototype.isBadInput = function () {
        // The badInput property is not supported in IE 11 💩.
        return this.getNativeInput().validity.badInput || false;
    };
    /**
     * @return The result of native validity checking (ValidityState.valid).
     */
    MDCTextFieldFoundation.prototype.isNativeInputValid = function () {
        return this.getNativeInput().validity.valid;
    };
    /**
     * Styles the component based on the validity state.
     */
    MDCTextFieldFoundation.prototype.styleValidity = function (isValid) {
        var INVALID = MDCTextFieldFoundation.cssClasses.INVALID;
        if (isValid) {
            this.adapter.removeClass(INVALID);
        }
        else {
            this.adapter.addClass(INVALID);
        }
        if (this.helperText) {
            this.helperText.setValidity(isValid);
            // We dynamically set or unset aria-describedby for validation helper text
            // only, based on whether the field is valid
            var helperTextValidation = this.helperText.isValidation();
            if (!helperTextValidation) {
                return;
            }
            var helperTextVisible = this.helperText.isVisible();
            var helperTextId = this.helperText.getId();
            if (helperTextVisible && helperTextId) {
                this.adapter.setInputAttr(strings.ARIA_DESCRIBEDBY, helperTextId);
            }
            else {
                this.adapter.removeInputAttr(strings.ARIA_DESCRIBEDBY);
            }
        }
    };
    /**
     * Styles the component based on the focused state.
     */
    MDCTextFieldFoundation.prototype.styleFocused = function (isFocused) {
        var FOCUSED = MDCTextFieldFoundation.cssClasses.FOCUSED;
        if (isFocused) {
            this.adapter.addClass(FOCUSED);
        }
        else {
            this.adapter.removeClass(FOCUSED);
        }
    };
    /**
     * Styles the component based on the disabled state.
     */
    MDCTextFieldFoundation.prototype.styleDisabled = function (isDisabled) {
        var _a = MDCTextFieldFoundation.cssClasses, DISABLED = _a.DISABLED, INVALID = _a.INVALID;
        if (isDisabled) {
            this.adapter.addClass(DISABLED);
            this.adapter.removeClass(INVALID);
        }
        else {
            this.adapter.removeClass(DISABLED);
        }
        if (this.leadingIcon) {
            this.leadingIcon.setDisabled(isDisabled);
        }
        if (this.trailingIcon) {
            this.trailingIcon.setDisabled(isDisabled);
        }
    };
    /**
     * Styles the component based on the label floating state.
     */
    MDCTextFieldFoundation.prototype.styleFloating = function (isFloating) {
        var LABEL_FLOATING = MDCTextFieldFoundation.cssClasses.LABEL_FLOATING;
        if (isFloating) {
            this.adapter.addClass(LABEL_FLOATING);
        }
        else {
            this.adapter.removeClass(LABEL_FLOATING);
        }
    };
    /**
     * @return The native text input element from the host environment, or an
     *     object with the same shape for unit tests.
     */
    MDCTextFieldFoundation.prototype.getNativeInput = function () {
        // this.adapter may be undefined in foundation unit tests. This happens when
        // testdouble is creating a mock object and invokes the
        // shouldShake/shouldFloat getters (which in turn call getValue(), which
        // calls this method) before init() has been called from the MDCTextField
        // constructor. To work around that issue, we return a dummy object.
        var nativeInput = this.adapter ? this.adapter.getNativeInput() : null;
        return nativeInput || {
            disabled: false,
            maxLength: -1,
            required: false,
            type: 'input',
            validity: {
                badInput: false,
                valid: true,
            },
            value: '',
        };
    };
    return MDCTextFieldFoundation;
}(MDCFoundation));

/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const r=o=>void 0===o.strings,f={},s=(o,i=f)=>o._$AH=i;

/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const l=e$1(class extends i$3{constructor(r$1){if(super(r$1),r$1.type!==t.PROPERTY&&r$1.type!==t.ATTRIBUTE&&r$1.type!==t.BOOLEAN_ATTRIBUTE)throw Error("The `live` directive is not allowed on child or event bindings");if(!r(r$1))throw Error("`live` bindings can only contain a single expression")}render(r){return r}update(i,[t$1]){if(t$1===b||t$1===w)return t$1;const o=i.element,l=i.name;if(i.type===t.PROPERTY){if(t$1===o[l])return b}else if(i.type===t.BOOLEAN_ATTRIBUTE){if(!!t$1===o.hasAttribute(l))return b}else if(i.type===t.ATTRIBUTE&&o.getAttribute(l)===t$1+"")return b;return s(i),t$1}});

/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const passiveEvents = ['touchstart', 'touchmove', 'scroll', 'mousewheel'];
const createValidityObj = (customValidity = {}) => {
    /*
     * We need to make ValidityState an object because it is readonly and
     * we cannot use the spread operator. Also, we don't export
     * `CustomValidityState` because it is a leaky implementation and the user
     * already has access to `ValidityState` in lib.dom.ts. Also an interface
     * {a: Type} can be casted to {readonly a: Type} so passing any object
     * should be fine.
     */
    const objectifiedCustomValidity = {};
    // eslint-disable-next-line guard-for-in
    for (const propName in customValidity) {
        /*
         * Casting is needed because ValidityState's props are all readonly and
         * thus cannot be set on `onjectifiedCustomValidity`. In the end, the
         * interface is the same as ValidityState (but not readonly), but the
         * function signature casts the output to ValidityState (thus readonly).
         */
        objectifiedCustomValidity[propName] =
            customValidity[propName];
    }
    return Object.assign({ badInput: false, customError: false, patternMismatch: false, rangeOverflow: false, rangeUnderflow: false, stepMismatch: false, tooLong: false, tooShort: false, typeMismatch: false, valid: true, valueMissing: false }, objectifiedCustomValidity);
};
/** @soyCompatible */
class TextFieldBase extends FormElement {
    constructor() {
        super(...arguments);
        this.mdcFoundationClass = MDCTextFieldFoundation;
        this.value = '';
        this.type = 'text';
        this.placeholder = '';
        this.label = '';
        this.icon = '';
        this.iconTrailing = '';
        this.disabled = false;
        this.required = false;
        this.minLength = -1;
        this.maxLength = -1;
        this.outlined = false;
        this.helper = '';
        this.validateOnInitialRender = false;
        this.validationMessage = '';
        this.autoValidate = false;
        this.pattern = '';
        this.min = '';
        this.max = '';
        /**
         * step can be a number or the keyword "any".
         *
         * Use `String` typing to pass down the value as a string and let the native
         * input cast internally as needed.
         */
        this.step = null;
        this.size = null;
        this.helperPersistent = false;
        this.charCounter = false;
        this.endAligned = false;
        this.prefix = '';
        this.suffix = '';
        this.name = '';
        this.readOnly = false;
        this.autocapitalize = '';
        this.outlineOpen = false;
        this.outlineWidth = 0;
        this.isUiValid = true;
        this.focused = false;
        this._validity = createValidityObj();
        this.validityTransform = null;
    }
    get validity() {
        this._checkValidity(this.value);
        return this._validity;
    }
    get willValidate() {
        return this.formElement.willValidate;
    }
    get selectionStart() {
        return this.formElement.selectionStart;
    }
    get selectionEnd() {
        return this.formElement.selectionEnd;
    }
    focus() {
        const focusEvt = new CustomEvent('focus');
        this.formElement.dispatchEvent(focusEvt);
        this.formElement.focus();
    }
    blur() {
        const blurEvt = new CustomEvent('blur');
        this.formElement.dispatchEvent(blurEvt);
        this.formElement.blur();
    }
    select() {
        this.formElement.select();
    }
    setSelectionRange(selectionStart, selectionEnd, selectionDirection) {
        this.formElement.setSelectionRange(selectionStart, selectionEnd, selectionDirection);
    }
    update(changedProperties) {
        if (changedProperties.has('autoValidate') && this.mdcFoundation) {
            this.mdcFoundation.setValidateOnValueChange(this.autoValidate);
        }
        if (changedProperties.has('value') && typeof this.value !== 'string') {
            this.value = `${this.value}`;
        }
        super.update(changedProperties);
    }
    setFormData(formData) {
        if (this.name) {
            formData.append(this.name, this.value);
        }
    }
    /** @soyTemplate */
    render() {
        const shouldRenderCharCounter = this.charCounter && this.maxLength !== -1;
        const shouldRenderHelperText = !!this.helper || !!this.validationMessage || shouldRenderCharCounter;
        /** @classMap */
        const classes = {
            'mdc-text-field--disabled': this.disabled,
            'mdc-text-field--no-label': !this.label,
            'mdc-text-field--filled': !this.outlined,
            'mdc-text-field--outlined': this.outlined,
            'mdc-text-field--with-leading-icon': this.icon,
            'mdc-text-field--with-trailing-icon': this.iconTrailing,
            'mdc-text-field--end-aligned': this.endAligned,
        };
        return $ `
      <label class="mdc-text-field ${o(classes)}">
        ${this.renderRipple()}
        ${this.outlined ? this.renderOutline() : this.renderLabel()}
        ${this.renderLeadingIcon()}
        ${this.renderPrefix()}
        ${this.renderInput(shouldRenderHelperText)}
        ${this.renderSuffix()}
        ${this.renderTrailingIcon()}
        ${this.renderLineRipple()}
      </label>
      ${this.renderHelperText(shouldRenderHelperText, shouldRenderCharCounter)}
    `;
    }
    updated(changedProperties) {
        if (changedProperties.has('value') &&
            changedProperties.get('value') !== undefined) {
            this.mdcFoundation.setValue(this.value);
            if (this.autoValidate) {
                this.reportValidity();
            }
        }
    }
    /** @soyTemplate */
    renderRipple() {
        return this.outlined ? '' : $ `
      <span class="mdc-text-field__ripple"></span>
    `;
    }
    /** @soyTemplate */
    renderOutline() {
        return !this.outlined ? '' : $ `
      <mwc-notched-outline
          .width=${this.outlineWidth}
          .open=${this.outlineOpen}
          class="mdc-notched-outline">
        ${this.renderLabel()}
      </mwc-notched-outline>`;
    }
    /** @soyTemplate */
    renderLabel() {
        return !this.label ?
            '' :
            $ `
      <span
          .floatingLabelFoundation=${floatingLabel(this.label)}
          id="label">${this.label}</span>
    `;
    }
    /** @soyTemplate */
    renderLeadingIcon() {
        return this.icon ? this.renderIcon(this.icon) : '';
    }
    /** @soyTemplate */
    renderTrailingIcon() {
        return this.iconTrailing ? this.renderIcon(this.iconTrailing, true) : '';
    }
    /** @soyTemplate */
    renderIcon(icon, isTrailingIcon = false) {
        /** @classMap */
        const classes = {
            'mdc-text-field__icon--leading': !isTrailingIcon,
            'mdc-text-field__icon--trailing': isTrailingIcon
        };
        return $ `<i class="material-icons mdc-text-field__icon ${o(classes)}">${icon}</i>`;
    }
    /** @soyTemplate */
    renderPrefix() {
        return this.prefix ? this.renderAffix(this.prefix) : '';
    }
    /** @soyTemplate */
    renderSuffix() {
        return this.suffix ? this.renderAffix(this.suffix, true) : '';
    }
    /** @soyTemplate */
    renderAffix(content, isSuffix = false) {
        /** @classMap */
        const classes = {
            'mdc-text-field__affix--prefix': !isSuffix,
            'mdc-text-field__affix--suffix': isSuffix
        };
        return $ `<span class="mdc-text-field__affix ${o(classes)}">
        ${content}</span>`;
    }
    /** @soyTemplate */
    renderInput(shouldRenderHelperText) {
        const minOrUndef = this.minLength === -1 ? undefined : this.minLength;
        const maxOrUndef = this.maxLength === -1 ? undefined : this.maxLength;
        const autocapitalizeOrUndef = this.autocapitalize ?
            this.autocapitalize :
            undefined;
        const showValidationMessage = this.validationMessage && !this.isUiValid;
        const ariaLabelledbyOrUndef = !!this.label ? 'label' : undefined;
        const ariaControlsOrUndef = shouldRenderHelperText ? 'helper-text' : undefined;
        const ariaDescribedbyOrUndef = this.focused || this.helperPersistent || showValidationMessage ?
            'helper-text' :
            undefined;
        // TODO: live() directive needs casting for lit-analyzer
        // https://github.com/runem/lit-analyzer/pull/91/files
        // TODO: lit-analyzer labels min/max as (number|string) instead of string
        return $ `
      <input
          aria-labelledby=${l$1(ariaLabelledbyOrUndef)}
          aria-controls="${l$1(ariaControlsOrUndef)}"
          aria-describedby="${l$1(ariaDescribedbyOrUndef)}"
          class="mdc-text-field__input"
          type="${this.type}"
          .value="${l(this.value)}"
          ?disabled="${this.disabled}"
          placeholder="${this.placeholder}"
          ?required="${this.required}"
          ?readonly="${this.readOnly}"
          minlength="${l$1(minOrUndef)}"
          maxlength="${l$1(maxOrUndef)}"
          pattern="${l$1(this.pattern ? this.pattern : undefined)}"
          min="${l$1(this.min === '' ? undefined : this.min)}"
          max="${l$1(this.max === '' ? undefined : this.max)}"
          step="${l$1(this.step === null ? undefined : this.step)}"
          size="${l$1(this.size === null ? undefined : this.size)}"
          name="${l$1(this.name === '' ? undefined : this.name)}"
          inputmode="${l$1(this.inputMode)}"
          autocapitalize="${l$1(autocapitalizeOrUndef)}"
          @input="${this.handleInputChange}"
          @focus="${this.onInputFocus}"
          @blur="${this.onInputBlur}">`;
    }
    /** @soyTemplate */
    renderLineRipple() {
        return this.outlined ?
            '' :
            $ `
      <span .lineRippleFoundation=${lineRipple()}></span>
    `;
    }
    /** @soyTemplate */
    renderHelperText(shouldRenderHelperText, shouldRenderCharCounter) {
        const showValidationMessage = this.validationMessage && !this.isUiValid;
        /** @classMap */
        const classes = {
            'mdc-text-field-helper-text--persistent': this.helperPersistent,
            'mdc-text-field-helper-text--validation-msg': showValidationMessage,
        };
        const ariaHiddenOrUndef = this.focused || this.helperPersistent || showValidationMessage ?
            undefined :
            'true';
        const helperText = showValidationMessage ? this.validationMessage : this.helper;
        return !shouldRenderHelperText ? '' : $ `
      <div class="mdc-text-field-helper-line">
        <div id="helper-text"
             aria-hidden="${l$1(ariaHiddenOrUndef)}"
             class="mdc-text-field-helper-text ${o(classes)}"
             >${helperText}</div>
        ${this.renderCharCounter(shouldRenderCharCounter)}
      </div>`;
    }
    /** @soyTemplate */
    renderCharCounter(shouldRenderCharCounter) {
        const length = Math.min(this.value.length, this.maxLength);
        return !shouldRenderCharCounter ? '' : $ `
      <span class="mdc-text-field-character-counter"
            >${length} / ${this.maxLength}</span>`;
    }
    onInputFocus() {
        this.focused = true;
    }
    onInputBlur() {
        this.focused = false;
        this.reportValidity();
    }
    checkValidity() {
        const isValid = this._checkValidity(this.value);
        if (!isValid) {
            const invalidEvent = new Event('invalid', { bubbles: false, cancelable: true });
            this.dispatchEvent(invalidEvent);
        }
        return isValid;
    }
    reportValidity() {
        const isValid = this.checkValidity();
        this.mdcFoundation.setValid(isValid);
        this.isUiValid = isValid;
        return isValid;
    }
    _checkValidity(value) {
        const nativeValidity = this.formElement.validity;
        let validity = createValidityObj(nativeValidity);
        if (this.validityTransform) {
            const customValidity = this.validityTransform(value, validity);
            validity = Object.assign(Object.assign({}, validity), customValidity);
            this.mdcFoundation.setUseNativeValidation(false);
        }
        else {
            this.mdcFoundation.setUseNativeValidation(true);
        }
        this._validity = validity;
        return this._validity.valid;
    }
    setCustomValidity(message) {
        this.validationMessage = message;
        this.formElement.setCustomValidity(message);
    }
    handleInputChange() {
        this.value = this.formElement.value;
    }
    createAdapter() {
        return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, this.getRootAdapterMethods()), this.getInputAdapterMethods()), this.getLabelAdapterMethods()), this.getLineRippleAdapterMethods()), this.getOutlineAdapterMethods());
    }
    getRootAdapterMethods() {
        return Object.assign({ registerTextFieldInteractionHandler: (evtType, handler) => this.addEventListener(evtType, handler), deregisterTextFieldInteractionHandler: (evtType, handler) => this.removeEventListener(evtType, handler), registerValidationAttributeChangeHandler: (handler) => {
                const getAttributesList = (mutationsList) => {
                    return mutationsList.map((mutation) => mutation.attributeName)
                        .filter((attributeName) => attributeName);
                };
                const observer = new MutationObserver((mutationsList) => {
                    handler(getAttributesList(mutationsList));
                });
                const config = { attributes: true };
                observer.observe(this.formElement, config);
                return observer;
            }, deregisterValidationAttributeChangeHandler: (observer) => observer.disconnect() }, addHasRemoveClass(this.mdcRoot));
    }
    getInputAdapterMethods() {
        return {
            getNativeInput: () => this.formElement,
            // since HelperTextFoundation is not used, aria-describedby a11y logic
            // is implemented in render method instead of these adapter methods
            setInputAttr: () => undefined,
            removeInputAttr: () => undefined,
            isFocused: () => this.shadowRoot ?
                this.shadowRoot.activeElement === this.formElement :
                false,
            registerInputInteractionHandler: (evtType, handler) => this.formElement.addEventListener(evtType, handler, { passive: evtType in passiveEvents }),
            deregisterInputInteractionHandler: (evtType, handler) => this.formElement.removeEventListener(evtType, handler),
        };
    }
    getLabelAdapterMethods() {
        return {
            floatLabel: (shouldFloat) => this.labelElement &&
                this.labelElement.floatingLabelFoundation.float(shouldFloat),
            getLabelWidth: () => {
                return this.labelElement ?
                    this.labelElement.floatingLabelFoundation.getWidth() :
                    0;
            },
            hasLabel: () => Boolean(this.labelElement),
            shakeLabel: (shouldShake) => this.labelElement &&
                this.labelElement.floatingLabelFoundation.shake(shouldShake),
            setLabelRequired: (isRequired) => {
                if (this.labelElement) {
                    this.labelElement.floatingLabelFoundation.setRequired(isRequired);
                }
            },
        };
    }
    getLineRippleAdapterMethods() {
        return {
            activateLineRipple: () => {
                if (this.lineRippleElement) {
                    this.lineRippleElement.lineRippleFoundation.activate();
                }
            },
            deactivateLineRipple: () => {
                if (this.lineRippleElement) {
                    this.lineRippleElement.lineRippleFoundation.deactivate();
                }
            },
            setLineRippleTransformOrigin: (normalizedX) => {
                if (this.lineRippleElement) {
                    this.lineRippleElement.lineRippleFoundation.setRippleCenter(normalizedX);
                }
            },
        };
    }
    // tslint:disable:ban-ts-ignore
    async getUpdateComplete() {
        var _a;
        // @ts-ignore
        const result = await super.getUpdateComplete();
        await ((_a = this.outlineElement) === null || _a === void 0 ? void 0 : _a.updateComplete);
        return result;
    }
    // tslint:enable:ban-ts-ignore
    firstUpdated() {
        var _a;
        super.firstUpdated();
        this.mdcFoundation.setValidateOnValueChange(this.autoValidate);
        if (this.validateOnInitialRender) {
            this.reportValidity();
        }
        // wait for the outline element to render to update the notch width
        (_a = this.outlineElement) === null || _a === void 0 ? void 0 : _a.updateComplete.then(() => {
            var _a;
            // `foundation.notchOutline()` assumes the label isn't floating and
            // multiplies by a constant, but the label is already is floating at this
            // stage, therefore directly set the outline width to the label width
            this.outlineWidth =
                ((_a = this.labelElement) === null || _a === void 0 ? void 0 : _a.floatingLabelFoundation.getWidth()) || 0;
        });
    }
    getOutlineAdapterMethods() {
        return {
            closeOutline: () => this.outlineElement && (this.outlineOpen = false),
            hasOutline: () => Boolean(this.outlineElement),
            notchOutline: (labelWidth) => {
                const outlineElement = this.outlineElement;
                if (outlineElement && !this.outlineOpen) {
                    this.outlineWidth = labelWidth;
                    this.outlineOpen = true;
                }
            }
        };
    }
    async layout() {
        await this.updateComplete;
        const labelElement = this.labelElement;
        if (!labelElement) {
            this.outlineOpen = false;
            return;
        }
        const shouldFloat = !!this.label && !!this.value;
        labelElement.floatingLabelFoundation.float(shouldFloat);
        if (!this.outlined) {
            return;
        }
        this.outlineOpen = shouldFloat;
        await this.updateComplete;
        /* When the textfield automatically notches due to a value and label
         * being defined, the textfield may be set to `display: none` by the user.
         * this means that the notch is of size 0px. We provide this function so
         * that the user may manually resize the notch to the floated label's
         * width.
         */
        const labelWidth = labelElement.floatingLabelFoundation.getWidth();
        if (this.outlineOpen) {
            this.outlineWidth = labelWidth;
            await this.updateComplete;
        }
    }
}
__decorate([
    i$4('.mdc-text-field')
], TextFieldBase.prototype, "mdcRoot", void 0);
__decorate([
    i$4('input')
], TextFieldBase.prototype, "formElement", void 0);
__decorate([
    i$4('.mdc-floating-label')
], TextFieldBase.prototype, "labelElement", void 0);
__decorate([
    i$4('.mdc-line-ripple')
], TextFieldBase.prototype, "lineRippleElement", void 0);
__decorate([
    i$4('mwc-notched-outline')
], TextFieldBase.prototype, "outlineElement", void 0);
__decorate([
    i$4('.mdc-notched-outline__notch')
], TextFieldBase.prototype, "notchElement", void 0);
__decorate([
    e$3({ type: String })
], TextFieldBase.prototype, "value", void 0);
__decorate([
    e$3({ type: String })
], TextFieldBase.prototype, "type", void 0);
__decorate([
    e$3({ type: String })
], TextFieldBase.prototype, "placeholder", void 0);
__decorate([
    e$3({ type: String }),
    observer(function (_newVal, oldVal) {
        if (oldVal !== undefined && this.label !== oldVal) {
            this.layout();
        }
    })
], TextFieldBase.prototype, "label", void 0);
__decorate([
    e$3({ type: String })
], TextFieldBase.prototype, "icon", void 0);
__decorate([
    e$3({ type: String })
], TextFieldBase.prototype, "iconTrailing", void 0);
__decorate([
    e$3({ type: Boolean, reflect: true })
], TextFieldBase.prototype, "disabled", void 0);
__decorate([
    e$3({ type: Boolean })
], TextFieldBase.prototype, "required", void 0);
__decorate([
    e$3({ type: Number })
], TextFieldBase.prototype, "minLength", void 0);
__decorate([
    e$3({ type: Number })
], TextFieldBase.prototype, "maxLength", void 0);
__decorate([
    e$3({ type: Boolean, reflect: true }),
    observer(function (_newVal, oldVal) {
        if (oldVal !== undefined && this.outlined !== oldVal) {
            this.layout();
        }
    })
], TextFieldBase.prototype, "outlined", void 0);
__decorate([
    e$3({ type: String })
], TextFieldBase.prototype, "helper", void 0);
__decorate([
    e$3({ type: Boolean })
], TextFieldBase.prototype, "validateOnInitialRender", void 0);
__decorate([
    e$3({ type: String })
], TextFieldBase.prototype, "validationMessage", void 0);
__decorate([
    e$3({ type: Boolean })
], TextFieldBase.prototype, "autoValidate", void 0);
__decorate([
    e$3({ type: String })
], TextFieldBase.prototype, "pattern", void 0);
__decorate([
    e$3({ type: String })
], TextFieldBase.prototype, "min", void 0);
__decorate([
    e$3({ type: String })
], TextFieldBase.prototype, "max", void 0);
__decorate([
    e$3({ type: String })
], TextFieldBase.prototype, "step", void 0);
__decorate([
    e$3({ type: Number })
], TextFieldBase.prototype, "size", void 0);
__decorate([
    e$3({ type: Boolean })
], TextFieldBase.prototype, "helperPersistent", void 0);
__decorate([
    e$3({ type: Boolean })
], TextFieldBase.prototype, "charCounter", void 0);
__decorate([
    e$3({ type: Boolean })
], TextFieldBase.prototype, "endAligned", void 0);
__decorate([
    e$3({ type: String })
], TextFieldBase.prototype, "prefix", void 0);
__decorate([
    e$3({ type: String })
], TextFieldBase.prototype, "suffix", void 0);
__decorate([
    e$3({ type: String })
], TextFieldBase.prototype, "name", void 0);
__decorate([
    e$3({ type: String })
], TextFieldBase.prototype, "inputMode", void 0);
__decorate([
    e$3({ type: Boolean })
], TextFieldBase.prototype, "readOnly", void 0);
__decorate([
    e$3({ type: String })
], TextFieldBase.prototype, "autocapitalize", void 0);
__decorate([
    t$1()
], TextFieldBase.prototype, "outlineOpen", void 0);
__decorate([
    t$1()
], TextFieldBase.prototype, "outlineWidth", void 0);
__decorate([
    t$1()
], TextFieldBase.prototype, "isUiValid", void 0);
__decorate([
    t$1()
], TextFieldBase.prototype, "focused", void 0);
__decorate([
    e$2({ passive: true })
], TextFieldBase.prototype, "handleInputChange", null);

class MushroomTextField extends TextFieldBase {
    updated(changedProperties) {
        super.updated(changedProperties);
        if ((changedProperties.has("invalid") &&
            (this.invalid || changedProperties.get("invalid") !== undefined)) ||
            changedProperties.has("errorMessage")) {
            this.setCustomValidity(this.invalid ? this.errorMessage || "Invalid" : "");
            this.reportValidity();
        }
    }
    renderOutline() {
        return "";
    }
    renderIcon(_icon, isTrailingIcon = false) {
        const type = isTrailingIcon ? "trailing" : "leading";
        return $ `
            <span
                class="mdc-text-field__icon mdc-text-field__icon--${type}"
                tabindex=${isTrailingIcon ? 1 : -1}
            >
                <slot name="${type}Icon"></slot>
            </span>
        `;
    }
}
MushroomTextField.styles = [
    styles,
    r$3 `
            .mdc-text-field__input {
                width: var(--ha-textfield-input-width, 100%);
            }
            .mdc-text-field:not(.mdc-text-field--with-leading-icon) {
                padding: var(--text-field-padding, 0px 16px);
            }
            .mdc-text-field__affix--suffix {
                padding-left: var(--text-field-suffix-padding-left, 12px);
                padding-right: var(--text-field-suffix-padding-right, 0px);
            }

            input {
                text-align: var(--text-field-text-align);
            }

            /* Chrome, Safari, Edge, Opera */
            :host([no-spinner]) input::-webkit-outer-spin-button,
            :host([no-spinner]) input::-webkit-inner-spin-button {
                -webkit-appearance: none;
                margin: 0;
            }

            /* Firefox */
            :host([no-spinner]) input[type="number"] {
                -moz-appearance: textfield;
            }

            .mdc-text-field__ripple {
                overflow: hidden;
            }

            .mdc-text-field {
                overflow: var(--text-field-overflow);
            }
        `,
];
__decorate([
    e$3({ type: Boolean })
], MushroomTextField.prototype, "invalid", void 0);
__decorate([
    e$3({ attribute: "error-message" })
], MushroomTextField.prototype, "errorMessage", void 0);
customElements.define("mushroom-textfield", MushroomTextField);

var mushroomTextfield = /*#__PURE__*/Object.freeze({
  __proto__: null
});

const computeSchema$k = memoizeOne((icon) => [
    { name: "entity", selector: { entity: {} } },
    {
        type: "grid",
        name: "",
        schema: [
            { name: "name", selector: { text: {} } },
            { name: "content_info", selector: { "mush-info": {} } },
        ],
    },
    {
        type: "grid",
        name: "",
        schema: [
            { name: "icon", selector: { icon: { placeholder: icon } } },
            { name: "icon_color", selector: { "mush-color": {} } },
        ],
    },
    { name: "use_entity_picture", selector: { boolean: {} } },
    ...computeActionsFormSchema(),
]);
let EntityChipEditor$2 = class EntityChipEditor extends s$1 {
    constructor() {
        super(...arguments);
        this._computeLabel = (schema) => {
            const customLocalize = setupCustomlocalize(this.hass);
            if (GENERIC_LABELS.includes(schema.name)) {
                return customLocalize(`editor.card.generic.${schema.name}`);
            }
            return this.hass.localize(`ui.panel.lovelace.editor.card.generic.${schema.name}`);
        };
    }
    setConfig(config) {
        this._config = config;
    }
    render() {
        if (!this.hass || !this._config) {
            return $ ``;
        }
        const entityState = this._config.entity ? this.hass.states[this._config.entity] : undefined;
        const entityIcon = entityState ? stateIcon(entityState) : undefined;
        const icon = this._config.icon || entityIcon;
        const schema = computeSchema$k(icon);
        return $ `
            <ha-form
                .hass=${this.hass}
                .data=${this._config}
                .schema=${schema}
                .computeLabel=${this._computeLabel}
                @value-changed=${this._valueChanged}
            ></ha-form>
        `;
    }
    _valueChanged(ev) {
        fireEvent(this, "config-changed", { config: ev.detail.value });
    }
};
__decorate([
    e$3({ attribute: false })
], EntityChipEditor$2.prototype, "hass", void 0);
__decorate([
    t$1()
], EntityChipEditor$2.prototype, "_config", void 0);
EntityChipEditor$2 = __decorate([
    n$1(computeChipEditorComponentName("entity"))
], EntityChipEditor$2);

var entityChipEditor = /*#__PURE__*/Object.freeze({
  __proto__: null,
  get EntityChipEditor () { return EntityChipEditor$2; }
});

const WEATHER_ENTITY_DOMAINS = ["weather"];
const WEATHER_LABELS = ["show_conditions", "show_temperature"];
const actions$4 = ["more-info", "navigate", "url", "call-service", "none"];
const computeSchema$j = memoizeOne(() => [
    { name: "entity", selector: { entity: { domain: WEATHER_ENTITY_DOMAINS } } },
    {
        type: "grid",
        name: "",
        schema: [
            { name: "show_conditions", selector: { boolean: {} } },
            { name: "show_temperature", selector: { boolean: {} } },
        ],
    },
    ...computeActionsFormSchema(actions$4),
]);
let WeatherChipEditor = class WeatherChipEditor extends s$1 {
    constructor() {
        super(...arguments);
        this._computeLabel = (schema) => {
            const customLocalize = setupCustomlocalize(this.hass);
            if (GENERIC_LABELS.includes(schema.name)) {
                return customLocalize(`editor.card.generic.${schema.name}`);
            }
            if (WEATHER_LABELS.includes(schema.name)) {
                return customLocalize(`editor.card.weather.${schema.name}`);
            }
            return this.hass.localize(`ui.panel.lovelace.editor.card.generic.${schema.name}`);
        };
    }
    setConfig(config) {
        this._config = config;
    }
    render() {
        if (!this.hass || !this._config) {
            return $ ``;
        }
        const schema = computeSchema$j();
        return $ `
            <ha-form
                .hass=${this.hass}
                .data=${this._config}
                .schema=${schema}
                .computeLabel=${this._computeLabel}
                @value-changed=${this._valueChanged}
            ></ha-form>
        `;
    }
    _valueChanged(ev) {
        fireEvent(this, "config-changed", { config: ev.detail.value });
    }
};
__decorate([
    e$3({ attribute: false })
], WeatherChipEditor.prototype, "hass", void 0);
__decorate([
    t$1()
], WeatherChipEditor.prototype, "_config", void 0);
WeatherChipEditor = __decorate([
    n$1(computeChipEditorComponentName("weather"))
], WeatherChipEditor);

var weatherChipEditor = /*#__PURE__*/Object.freeze({
  __proto__: null,
  get WeatherChipEditor () { return WeatherChipEditor; }
});

const computeSchema$i = memoizeOne((icon) => [
    { name: "icon", selector: { icon: { placeholder: icon } } },
]);
let BackChipEditor = class BackChipEditor extends s$1 {
    constructor() {
        super(...arguments);
        this._computeLabel = (schema) => {
            return this.hass.localize(`ui.panel.lovelace.editor.card.generic.${schema.name}`);
        };
    }
    setConfig(config) {
        this._config = config;
    }
    render() {
        if (!this.hass || !this._config) {
            return $ ``;
        }
        const icon = this._config.icon || DEFAULT_BACK_ICON;
        const schema = computeSchema$i(icon);
        return $ `
            <ha-form
                .hass=${this.hass}
                .data=${this._config}
                .schema=${schema}
                .computeLabel=${this._computeLabel}
                @value-changed=${this._valueChanged}
            ></ha-form>
        `;
    }
    _valueChanged(ev) {
        fireEvent(this, "config-changed", { config: ev.detail.value });
    }
};
__decorate([
    e$3({ attribute: false })
], BackChipEditor.prototype, "hass", void 0);
__decorate([
    t$1()
], BackChipEditor.prototype, "_config", void 0);
BackChipEditor = __decorate([
    n$1(computeChipEditorComponentName("back"))
], BackChipEditor);

var backChipEditor = /*#__PURE__*/Object.freeze({
  __proto__: null,
  get BackChipEditor () { return BackChipEditor; }
});

const actions$3 = ["navigate", "url", "call-service", "none"];
const computeSchema$h = memoizeOne((icon) => [
    {
        type: "grid",
        name: "",
        schema: [
            { name: "icon", selector: { icon: { placeholder: icon } } },
            { name: "icon_color", selector: { "mush-color": {} } },
        ],
    },
    ...computeActionsFormSchema(actions$3),
]);
let EntityChipEditor$1 = class EntityChipEditor extends s$1 {
    constructor() {
        super(...arguments);
        this._computeLabel = (schema) => {
            const customLocalize = setupCustomlocalize(this.hass);
            if (GENERIC_LABELS.includes(schema.name)) {
                return customLocalize(`editor.card.generic.${schema.name}`);
            }
            return this.hass.localize(`ui.panel.lovelace.editor.card.generic.${schema.name}`);
        };
    }
    setConfig(config) {
        this._config = config;
    }
    render() {
        if (!this.hass || !this._config) {
            return $ ``;
        }
        const icon = this._config.icon || DEFAULT_ACTION_ICON;
        const schema = computeSchema$h(icon);
        return $ `
            <ha-form
                .hass=${this.hass}
                .data=${this._config}
                .schema=${schema}
                .computeLabel=${this._computeLabel}
                @value-changed=${this._valueChanged}
            ></ha-form>
        `;
    }
    _valueChanged(ev) {
        fireEvent(this, "config-changed", { config: ev.detail.value });
    }
};
__decorate([
    e$3({ attribute: false })
], EntityChipEditor$1.prototype, "hass", void 0);
__decorate([
    t$1()
], EntityChipEditor$1.prototype, "_config", void 0);
EntityChipEditor$1 = __decorate([
    n$1(computeChipEditorComponentName("action"))
], EntityChipEditor$1);

var actionChipEditor = /*#__PURE__*/Object.freeze({
  __proto__: null,
  get EntityChipEditor () { return EntityChipEditor$1; }
});

const computeSchema$g = memoizeOne((icon) => [
    { name: "icon", selector: { icon: { placeholder: icon } } },
]);
let MenuChipEditor = class MenuChipEditor extends s$1 {
    constructor() {
        super(...arguments);
        this._computeLabel = (schema) => {
            return this.hass.localize(`ui.panel.lovelace.editor.card.generic.${schema.name}`);
        };
    }
    setConfig(config) {
        this._config = config;
    }
    render() {
        if (!this.hass || !this._config) {
            return $ ``;
        }
        const icon = this._config.icon || DEFAULT_MENU_ICON;
        const schema = computeSchema$g(icon);
        return $ `
            <ha-form
                .hass=${this.hass}
                .data=${this._config}
                .schema=${schema}
                .computeLabel=${this._computeLabel}
                @value-changed=${this._valueChanged}
            ></ha-form>
        `;
    }
    _valueChanged(ev) {
        fireEvent(this, "config-changed", { config: ev.detail.value });
    }
};
__decorate([
    e$3({ attribute: false })
], MenuChipEditor.prototype, "hass", void 0);
__decorate([
    t$1()
], MenuChipEditor.prototype, "_config", void 0);
MenuChipEditor = __decorate([
    n$1(computeChipEditorComponentName("menu"))
], MenuChipEditor);

var menuChipEditor = /*#__PURE__*/Object.freeze({
  __proto__: null,
  get MenuChipEditor () { return MenuChipEditor; }
});

const templateCardConfigStruct = assign(lovelaceCardConfigStruct, assign(appearanceSharedConfigStruct, actionsSharedConfigStruct), object({
    entity: optional(string()),
    icon: optional(string()),
    icon_color: optional(string()),
    primary: optional(string()),
    secondary: optional(string()),
    badge_icon: optional(string()),
    badge_color: optional(string()),
    picture: optional(string()),
    multiline_secondary: optional(boolean()),
    entity_id: optional(union([string(), array(string())])),
}));

const TEMPLATE_LABELS = [
    "badge_icon",
    "badge_color",
    "content",
    "primary",
    "secondary",
    "multiline_secondary",
    "picture",
];
const computeSchema$f = memoizeOne(() => [
    { name: "entity", selector: { entity: {} } },
    {
        name: "icon",
        selector: { template: {} },
    },
    {
        name: "icon_color",
        selector: { template: {} },
    },
    {
        name: "primary",
        selector: { template: {} },
    },
    {
        name: "secondary",
        selector: { template: {} },
    },
    {
        name: "badge_icon",
        selector: { template: {} },
    },
    {
        name: "badge_color",
        selector: { template: {} },
    },
    {
        name: "picture",
        selector: { template: {} },
    },
    {
        type: "grid",
        name: "",
        schema: [
            { name: "layout", selector: { "mush-layout": {} } },
            { name: "fill_container", selector: { boolean: {} } },
            { name: "multiline_secondary", selector: { boolean: {} } },
        ],
    },
    ...computeActionsFormSchema(),
]);
let TemplateCardEditor = class TemplateCardEditor extends MushroomBaseElement {
    constructor() {
        super(...arguments);
        this._computeLabel = (schema) => {
            const customLocalize = setupCustomlocalize(this.hass);
            if (schema.name === "entity") {
                return `${this.hass.localize("ui.panel.lovelace.editor.card.generic.entity")} (${customLocalize("editor.card.template.entity_extra")})`;
            }
            if (GENERIC_LABELS.includes(schema.name)) {
                return customLocalize(`editor.card.generic.${schema.name}`);
            }
            if (TEMPLATE_LABELS.includes(schema.name)) {
                return customLocalize(`editor.card.template.${schema.name}`);
            }
            return this.hass.localize(`ui.panel.lovelace.editor.card.generic.${schema.name}`);
        };
    }
    connectedCallback() {
        super.connectedCallback();
        void loadHaComponents();
    }
    setConfig(config) {
        assert(config, templateCardConfigStruct);
        this._config = config;
    }
    render() {
        if (!this.hass || !this._config) {
            return $ ``;
        }
        const schema = computeSchema$f();
        return $ `
            <ha-form
                .hass=${this.hass}
                .data=${this._config}
                .schema=${schema}
                .computeLabel=${this._computeLabel}
                @value-changed=${this._valueChanged}
            ></ha-form>
        `;
    }
    _valueChanged(ev) {
        fireEvent(this, "config-changed", { config: ev.detail.value });
    }
};
__decorate([
    t$1()
], TemplateCardEditor.prototype, "_config", void 0);
TemplateCardEditor = __decorate([
    n$1(TEMPLATE_CARD_EDITOR_NAME)
], TemplateCardEditor);

var templateCardEditor = /*#__PURE__*/Object.freeze({
  __proto__: null,
  TEMPLATE_LABELS: TEMPLATE_LABELS,
  get TemplateCardEditor () { return TemplateCardEditor; }
});

const computeSchema$e = memoizeOne(() => [
    { name: "entity", selector: { entity: {} } },
    {
        name: "icon",
        selector: { template: {} },
    },
    {
        name: "icon_color",
        selector: { template: {} },
    },
    {
        name: "picture",
        selector: { template: {} },
    },
    {
        name: "content",
        selector: { template: {} },
    },
    ...computeActionsFormSchema(),
]);
let EntityChipEditor = class EntityChipEditor extends s$1 {
    constructor() {
        super(...arguments);
        this._computeLabel = (schema) => {
            const customLocalize = setupCustomlocalize(this.hass);
            if (schema.name === "entity") {
                return `${this.hass.localize("ui.panel.lovelace.editor.card.generic.entity")} (${customLocalize("editor.card.template.entity_extra")})`;
            }
            if (GENERIC_LABELS.includes(schema.name)) {
                return customLocalize(`editor.card.generic.${schema.name}`);
            }
            if (TEMPLATE_LABELS.includes(schema.name)) {
                return customLocalize(`editor.card.template.${schema.name}`);
            }
            return this.hass.localize(`ui.panel.lovelace.editor.card.generic.${schema.name}`);
        };
    }
    setConfig(config) {
        this._config = config;
    }
    render() {
        if (!this.hass || !this._config) {
            return $ ``;
        }
        const schema = computeSchema$e();
        return $ `
            <ha-form
                .hass=${this.hass}
                .data=${this._config}
                .schema=${schema}
                .computeLabel=${this._computeLabel}
                @value-changed=${this._valueChanged}
            ></ha-form>
        `;
    }
    _valueChanged(ev) {
        fireEvent(this, "config-changed", { config: ev.detail.value });
    }
};
__decorate([
    e$3({ attribute: false })
], EntityChipEditor.prototype, "hass", void 0);
__decorate([
    t$1()
], EntityChipEditor.prototype, "_config", void 0);
EntityChipEditor = __decorate([
    n$1(computeChipEditorComponentName("template"))
], EntityChipEditor);

var templateChipEditor = /*#__PURE__*/Object.freeze({
  __proto__: null,
  get EntityChipEditor () { return EntityChipEditor; }
});

var loader$1 = {};

var common$5 = {};

function isNothing(subject) {
  return (typeof subject === 'undefined') || (subject === null);
}


function isObject(subject) {
  return (typeof subject === 'object') && (subject !== null);
}


function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;
  else if (isNothing(sequence)) return [];

  return [ sequence ];
}


function extend$1(target, source) {
  var index, length, key, sourceKeys;

  if (source) {
    sourceKeys = Object.keys(source);

    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }

  return target;
}


function repeat(string, count) {
  var result = '', cycle;

  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }

  return result;
}


function isNegativeZero(number) {
  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);
}


common$5.isNothing      = isNothing;
common$5.isObject       = isObject;
common$5.toArray        = toArray;
common$5.repeat         = repeat;
common$5.isNegativeZero = isNegativeZero;
common$5.extend         = extend$1;

function formatError(exception, compact) {
  var where = '', message = exception.reason || '(unknown reason)';

  if (!exception.mark) return message;

  if (exception.mark.name) {
    where += 'in "' + exception.mark.name + '" ';
  }

  where += '(' + (exception.mark.line + 1) + ':' + (exception.mark.column + 1) + ')';

  if (!compact && exception.mark.snippet) {
    where += '\n\n' + exception.mark.snippet;
  }

  return message + ' ' + where;
}


function YAMLException$4(reason, mark) {
  // Super constructor
  Error.call(this);

  this.name = 'YAMLException';
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);

  // Include stack trace in error object
  if (Error.captureStackTrace) {
    // Chrome and NodeJS
    Error.captureStackTrace(this, this.constructor);
  } else {
    // FF, IE 10+ and Safari 6+. Fallback for others
    this.stack = (new Error()).stack || '';
  }
}


// Inherit from Error
YAMLException$4.prototype = Object.create(Error.prototype);
YAMLException$4.prototype.constructor = YAMLException$4;


YAMLException$4.prototype.toString = function toString(compact) {
  return this.name + ': ' + formatError(this, compact);
};


var exception = YAMLException$4;

var common$4 = common$5;


// get snippet for a single line, respecting maxLength
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head = '';
  var tail = '';
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;

  if (position - lineStart > maxHalfLength) {
    head = ' ... ';
    lineStart = position - maxHalfLength + head.length;
  }

  if (lineEnd - position > maxHalfLength) {
    tail = ' ...';
    lineEnd = position + maxHalfLength - tail.length;
  }

  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, '→') + tail,
    pos: position - lineStart + head.length // relative position
  };
}


function padStart(string, max) {
  return common$4.repeat(' ', max - string.length) + string;
}


function makeSnippet$1(mark, options) {
  options = Object.create(options || null);

  if (!mark.buffer) return null;

  if (!options.maxLength) options.maxLength = 79;
  if (typeof options.indent      !== 'number') options.indent      = 1;
  if (typeof options.linesBefore !== 'number') options.linesBefore = 3;
  if (typeof options.linesAfter  !== 'number') options.linesAfter  = 2;

  var re = /\r?\n|\r|\0/g;
  var lineStarts = [ 0 ];
  var lineEnds = [];
  var match;
  var foundLineNo = -1;

  while ((match = re.exec(mark.buffer))) {
    lineEnds.push(match.index);
    lineStarts.push(match.index + match[0].length);

    if (mark.position <= match.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }

  if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;

  var result = '', i, line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);

  for (i = 1; i <= options.linesBefore; i++) {
    if (foundLineNo - i < 0) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo - i],
      lineEnds[foundLineNo - i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
      maxLineLength
    );
    result = common$4.repeat(' ', options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) +
      ' | ' + line.str + '\n' + result;
  }

  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common$4.repeat(' ', options.indent) + padStart((mark.line + 1).toString(), lineNoLength) +
    ' | ' + line.str + '\n';
  result += common$4.repeat('-', options.indent + lineNoLength + 3 + line.pos) + '^' + '\n';

  for (i = 1; i <= options.linesAfter; i++) {
    if (foundLineNo + i >= lineEnds.length) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo + i],
      lineEnds[foundLineNo + i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
      maxLineLength
    );
    result += common$4.repeat(' ', options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) +
      ' | ' + line.str + '\n';
  }

  return result.replace(/\n$/, '');
}


var snippet = makeSnippet$1;

var core = {exports: {}};

var YAMLException$3 = exception;

var TYPE_CONSTRUCTOR_OPTIONS = [
  'kind',
  'multi',
  'resolve',
  'construct',
  'instanceOf',
  'predicate',
  'represent',
  'representName',
  'defaultStyle',
  'styleAliases'
];

var YAML_NODE_KINDS = [
  'scalar',
  'sequence',
  'mapping'
];

function compileStyleAliases(map) {
  var result = {};

  if (map !== null) {
    Object.keys(map).forEach(function (style) {
      map[style].forEach(function (alias) {
        result[String(alias)] = style;
      });
    });
  }

  return result;
}

function Type$e(tag, options) {
  options = options || {};

  Object.keys(options).forEach(function (name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new YAMLException$3('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });

  // TODO: Add tag format check.
  this.options       = options; // keep original options in case user wants to extend this type later
  this.tag           = tag;
  this.kind          = options['kind']          || null;
  this.resolve       = options['resolve']       || function () { return true; };
  this.construct     = options['construct']     || function (data) { return data; };
  this.instanceOf    = options['instanceOf']    || null;
  this.predicate     = options['predicate']     || null;
  this.represent     = options['represent']     || null;
  this.representName = options['representName'] || null;
  this.defaultStyle  = options['defaultStyle']  || null;
  this.multi         = options['multi']         || false;
  this.styleAliases  = compileStyleAliases(options['styleAliases'] || null);

  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new YAMLException$3('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}

var type = Type$e;

/*eslint-disable max-len*/

var YAMLException$2 = exception;
var Type$d          = type;


function compileList(schema, name) {
  var result = [];

  schema[name].forEach(function (currentType) {
    var newIndex = result.length;

    result.forEach(function (previousType, previousIndex) {
      if (previousType.tag === currentType.tag &&
          previousType.kind === currentType.kind &&
          previousType.multi === currentType.multi) {

        newIndex = previousIndex;
      }
    });

    result[newIndex] = currentType;
  });

  return result;
}


function compileMap(/* lists... */) {
  var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {},
        multi: {
          scalar: [],
          sequence: [],
          mapping: [],
          fallback: []
        }
      }, index, length;

  function collectType(type) {
    if (type.multi) {
      result.multi[type.kind].push(type);
      result.multi['fallback'].push(type);
    } else {
      result[type.kind][type.tag] = result['fallback'][type.tag] = type;
    }
  }

  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}


function Schema$1(definition) {
  return this.extend(definition);
}


Schema$1.prototype.extend = function extend(definition) {
  var implicit = [];
  var explicit = [];

  if (definition instanceof Type$d) {
    // Schema.extend(type)
    explicit.push(definition);

  } else if (Array.isArray(definition)) {
    // Schema.extend([ type1, type2, ... ])
    explicit = explicit.concat(definition);

  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    // Schema.extend({ explicit: [ type1, type2, ... ], implicit: [ type1, type2, ... ] })
    if (definition.implicit) implicit = implicit.concat(definition.implicit);
    if (definition.explicit) explicit = explicit.concat(definition.explicit);

  } else {
    throw new YAMLException$2('Schema.extend argument should be a Type, [ Type ], ' +
      'or a schema definition ({ implicit: [...], explicit: [...] })');
  }

  implicit.forEach(function (type) {
    if (!(type instanceof Type$d)) {
      throw new YAMLException$2('Specified list of YAML types (or a single Type object) contains a non-Type object.');
    }

    if (type.loadKind && type.loadKind !== 'scalar') {
      throw new YAMLException$2('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
    }

    if (type.multi) {
      throw new YAMLException$2('There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.');
    }
  });

  explicit.forEach(function (type) {
    if (!(type instanceof Type$d)) {
      throw new YAMLException$2('Specified list of YAML types (or a single Type object) contains a non-Type object.');
    }
  });

  var result = Object.create(Schema$1.prototype);

  result.implicit = (this.implicit || []).concat(implicit);
  result.explicit = (this.explicit || []).concat(explicit);

  result.compiledImplicit = compileList(result, 'implicit');
  result.compiledExplicit = compileList(result, 'explicit');
  result.compiledTypeMap  = compileMap(result.compiledImplicit, result.compiledExplicit);

  return result;
};


var schema = Schema$1;

var Type$c = type;

var str = new Type$c('tag:yaml.org,2002:str', {
  kind: 'scalar',
  construct: function (data) { return data !== null ? data : ''; }
});

var Type$b = type;

var seq = new Type$b('tag:yaml.org,2002:seq', {
  kind: 'sequence',
  construct: function (data) { return data !== null ? data : []; }
});

var Type$a = type;

var map = new Type$a('tag:yaml.org,2002:map', {
  kind: 'mapping',
  construct: function (data) { return data !== null ? data : {}; }
});

var Schema = schema;


var failsafe = new Schema({
  explicit: [
    str,
    seq,
    map
  ]
});

var Type$9 = type;

function resolveYamlNull(data) {
  if (data === null) return true;

  var max = data.length;

  return (max === 1 && data === '~') ||
         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
}

function constructYamlNull() {
  return null;
}

function isNull(object) {
  return object === null;
}

var _null = new Type$9('tag:yaml.org,2002:null', {
  kind: 'scalar',
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function () { return '~';    },
    lowercase: function () { return 'null'; },
    uppercase: function () { return 'NULL'; },
    camelcase: function () { return 'Null'; },
    empty:     function () { return '';     }
  },
  defaultStyle: 'lowercase'
});

var Type$8 = type;

function resolveYamlBoolean(data) {
  if (data === null) return false;

  var max = data.length;

  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||
         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
}

function constructYamlBoolean(data) {
  return data === 'true' ||
         data === 'True' ||
         data === 'TRUE';
}

function isBoolean(object) {
  return Object.prototype.toString.call(object) === '[object Boolean]';
}

var bool = new Type$8('tag:yaml.org,2002:bool', {
  kind: 'scalar',
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function (object) { return object ? 'true' : 'false'; },
    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },
    camelcase: function (object) { return object ? 'True' : 'False'; }
  },
  defaultStyle: 'lowercase'
});

var common$3 = common$5;
var Type$7   = type;

function isHexCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||
         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||
         ((0x61/* a */ <= c) && (c <= 0x66/* f */));
}

function isOctCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));
}

function isDecCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));
}

function resolveYamlInteger(data) {
  if (data === null) return false;

  var max = data.length,
      index = 0,
      hasDigits = false,
      ch;

  if (!max) return false;

  ch = data[index];

  // sign
  if (ch === '-' || ch === '+') {
    ch = data[++index];
  }

  if (ch === '0') {
    // 0
    if (index + 1 === max) return true;
    ch = data[++index];

    // base 2, base 8, base 16

    if (ch === 'b') {
      // base 2
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (ch !== '0' && ch !== '1') return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }


    if (ch === 'x') {
      // base 16
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }


    if (ch === 'o') {
      // base 8
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (!isOctCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }
  }

  // base 10 (except 0)

  // value should not start with `_`;
  if (ch === '_') return false;

  for (; index < max; index++) {
    ch = data[index];
    if (ch === '_') continue;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }

  // Should have digits and should not end with `_`
  if (!hasDigits || ch === '_') return false;

  return true;
}

function constructYamlInteger(data) {
  var value = data, sign = 1, ch;

  if (value.indexOf('_') !== -1) {
    value = value.replace(/_/g, '');
  }

  ch = value[0];

  if (ch === '-' || ch === '+') {
    if (ch === '-') sign = -1;
    value = value.slice(1);
    ch = value[0];
  }

  if (value === '0') return 0;

  if (ch === '0') {
    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
    if (value[1] === 'x') return sign * parseInt(value.slice(2), 16);
    if (value[1] === 'o') return sign * parseInt(value.slice(2), 8);
  }

  return sign * parseInt(value, 10);
}

function isInteger(object) {
  return (Object.prototype.toString.call(object)) === '[object Number]' &&
         (object % 1 === 0 && !common$3.isNegativeZero(object));
}

var int = new Type$7('tag:yaml.org,2002:int', {
  kind: 'scalar',
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },
    octal:       function (obj) { return obj >= 0 ? '0o'  + obj.toString(8) : '-0o'  + obj.toString(8).slice(1); },
    decimal:     function (obj) { return obj.toString(10); },
    /* eslint-disable max-len */
    hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }
  },
  defaultStyle: 'decimal',
  styleAliases: {
    binary:      [ 2,  'bin' ],
    octal:       [ 8,  'oct' ],
    decimal:     [ 10, 'dec' ],
    hexadecimal: [ 16, 'hex' ]
  }
});

var common$2 = common$5;
var Type$6   = type;

var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  '^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +
  // .2e4, .2
  // special case, seems not from spec
  '|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +
  // .inf
  '|[-+]?\\.(?:inf|Inf|INF)' +
  // .nan
  '|\\.(?:nan|NaN|NAN))$');

function resolveYamlFloat(data) {
  if (data === null) return false;

  if (!YAML_FLOAT_PATTERN.test(data) ||
      // Quick hack to not allow integers end with `_`
      // Probably should update regexp & check speed
      data[data.length - 1] === '_') {
    return false;
  }

  return true;
}

function constructYamlFloat(data) {
  var value, sign;

  value  = data.replace(/_/g, '').toLowerCase();
  sign   = value[0] === '-' ? -1 : 1;

  if ('+-'.indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }

  if (value === '.inf') {
    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

  } else if (value === '.nan') {
    return NaN;
  }
  return sign * parseFloat(value, 10);
}


var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

function representYamlFloat(object, style) {
  var res;

  if (isNaN(object)) {
    switch (style) {
      case 'lowercase': return '.nan';
      case 'uppercase': return '.NAN';
      case 'camelcase': return '.NaN';
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '.inf';
      case 'uppercase': return '.INF';
      case 'camelcase': return '.Inf';
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '-.inf';
      case 'uppercase': return '-.INF';
      case 'camelcase': return '-.Inf';
    }
  } else if (common$2.isNegativeZero(object)) {
    return '-0.0';
  }

  res = object.toString(10);

  // JS stringifier can build scientific format without dots: 5e-100,
  // while YAML requres dot: 5.e-100. Fix it with simple hack

  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
}

function isFloat(object) {
  return (Object.prototype.toString.call(object) === '[object Number]') &&
         (object % 1 !== 0 || common$2.isNegativeZero(object));
}

var float = new Type$6('tag:yaml.org,2002:float', {
  kind: 'scalar',
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: 'lowercase'
});

var json = failsafe.extend({
  implicit: [
    _null,
    bool,
    int,
    float
  ]
});

(function (module) {


	module.exports = json;
} (core));

var Type$5 = type;

var YAML_DATE_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9])'                    + // [2] month
  '-([0-9][0-9])$');                   // [3] day

var YAML_TIMESTAMP_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9]?)'                   + // [2] month
  '-([0-9][0-9]?)'                   + // [3] day
  '(?:[Tt]|[ \\t]+)'                 + // ...
  '([0-9][0-9]?)'                    + // [4] hour
  ':([0-9][0-9])'                    + // [5] minute
  ':([0-9][0-9])'                    + // [6] second
  '(?:\\.([0-9]*))?'                 + // [7] fraction
  '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute

function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}

function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, date;

  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (match === null) throw new Error('Date resolve error');

  // match: [1] year [2] month [3] day

  year = +(match[1]);
  month = +(match[2]) - 1; // JS month starts with 0
  day = +(match[3]);

  if (!match[4]) { // no hour
    return new Date(Date.UTC(year, month, day));
  }

  // match: [4] hour [5] minute [6] second [7] fraction

  hour = +(match[4]);
  minute = +(match[5]);
  second = +(match[6]);

  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) { // milli-seconds
      fraction += '0';
    }
    fraction = +fraction;
  }

  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

  if (match[9]) {
    tz_hour = +(match[10]);
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
    if (match[9] === '-') delta = -delta;
  }

  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

  if (delta) date.setTime(date.getTime() - delta);

  return date;
}

function representYamlTimestamp(object /*, style*/) {
  return object.toISOString();
}

var timestamp = new Type$5('tag:yaml.org,2002:timestamp', {
  kind: 'scalar',
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});

var Type$4 = type;

function resolveYamlMerge(data) {
  return data === '<<' || data === null;
}

var merge = new Type$4('tag:yaml.org,2002:merge', {
  kind: 'scalar',
  resolve: resolveYamlMerge
});

/*eslint-disable no-bitwise*/


var Type$3 = type;


// [ 64, 65, 66 ] -> [ padding, CR, LF ]
var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';


function resolveYamlBinary(data) {
  if (data === null) return false;

  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;

  // Convert one by one.
  for (idx = 0; idx < max; idx++) {
    code = map.indexOf(data.charAt(idx));

    // Skip CR/LF
    if (code > 64) continue;

    // Fail on illegal characters
    if (code < 0) return false;

    bitlen += 6;
  }

  // If there are any bits left, source was corrupted
  return (bitlen % 8) === 0;
}

function constructYamlBinary(data) {
  var idx, tailbits,
      input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
      max = input.length,
      map = BASE64_MAP,
      bits = 0,
      result = [];

  // Collect by 6*4 bits (3 bytes)

  for (idx = 0; idx < max; idx++) {
    if ((idx % 4 === 0) && idx) {
      result.push((bits >> 16) & 0xFF);
      result.push((bits >> 8) & 0xFF);
      result.push(bits & 0xFF);
    }

    bits = (bits << 6) | map.indexOf(input.charAt(idx));
  }

  // Dump tail

  tailbits = (max % 4) * 6;

  if (tailbits === 0) {
    result.push((bits >> 16) & 0xFF);
    result.push((bits >> 8) & 0xFF);
    result.push(bits & 0xFF);
  } else if (tailbits === 18) {
    result.push((bits >> 10) & 0xFF);
    result.push((bits >> 2) & 0xFF);
  } else if (tailbits === 12) {
    result.push((bits >> 4) & 0xFF);
  }

  return new Uint8Array(result);
}

function representYamlBinary(object /*, style*/) {
  var result = '', bits = 0, idx, tail,
      max = object.length,
      map = BASE64_MAP;

  // Convert every three bytes to 4 ASCII characters.

  for (idx = 0; idx < max; idx++) {
    if ((idx % 3 === 0) && idx) {
      result += map[(bits >> 18) & 0x3F];
      result += map[(bits >> 12) & 0x3F];
      result += map[(bits >> 6) & 0x3F];
      result += map[bits & 0x3F];
    }

    bits = (bits << 8) + object[idx];
  }

  // Dump tail

  tail = max % 3;

  if (tail === 0) {
    result += map[(bits >> 18) & 0x3F];
    result += map[(bits >> 12) & 0x3F];
    result += map[(bits >> 6) & 0x3F];
    result += map[bits & 0x3F];
  } else if (tail === 2) {
    result += map[(bits >> 10) & 0x3F];
    result += map[(bits >> 4) & 0x3F];
    result += map[(bits << 2) & 0x3F];
    result += map[64];
  } else if (tail === 1) {
    result += map[(bits >> 2) & 0x3F];
    result += map[(bits << 4) & 0x3F];
    result += map[64];
    result += map[64];
  }

  return result;
}

function isBinary(obj) {
  return Object.prototype.toString.call(obj) ===  '[object Uint8Array]';
}

var binary = new Type$3('tag:yaml.org,2002:binary', {
  kind: 'scalar',
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});

var Type$2 = type;

var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2       = Object.prototype.toString;

function resolveYamlOmap(data) {
  if (data === null) return true;

  var objectKeys = [], index, length, pair, pairKey, pairHasKey,
      object = data;

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;

    if (_toString$2.call(pair) !== '[object Object]') return false;

    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }

    if (!pairHasKey) return false;

    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }

  return true;
}

function constructYamlOmap(data) {
  return data !== null ? data : [];
}

var omap = new Type$2('tag:yaml.org,2002:omap', {
  kind: 'sequence',
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});

var Type$1 = type;

var _toString$1 = Object.prototype.toString;

function resolveYamlPairs(data) {
  if (data === null) return true;

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    if (_toString$1.call(pair) !== '[object Object]') return false;

    keys = Object.keys(pair);

    if (keys.length !== 1) return false;

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return true;
}

function constructYamlPairs(data) {
  if (data === null) return [];

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    keys = Object.keys(pair);

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return result;
}

var pairs = new Type$1('tag:yaml.org,2002:pairs', {
  kind: 'sequence',
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});

var Type = type;

var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;

function resolveYamlSet(data) {
  if (data === null) return true;

  var key, object = data;

  for (key in object) {
    if (_hasOwnProperty$2.call(object, key)) {
      if (object[key] !== null) return false;
    }
  }

  return true;
}

function constructYamlSet(data) {
  return data !== null ? data : {};
}

var set = new Type('tag:yaml.org,2002:set', {
  kind: 'mapping',
  resolve: resolveYamlSet,
  construct: constructYamlSet
});

var _default = core.exports.extend({
  implicit: [
    timestamp,
    merge
  ],
  explicit: [
    binary,
    omap,
    pairs,
    set
  ]
});

/*eslint-disable max-len,no-use-before-define*/

var common$1              = common$5;
var YAMLException$1       = exception;
var makeSnippet         = snippet;
var DEFAULT_SCHEMA$1      = _default;


var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;


var CONTEXT_FLOW_IN   = 1;
var CONTEXT_FLOW_OUT  = 2;
var CONTEXT_BLOCK_IN  = 3;
var CONTEXT_BLOCK_OUT = 4;


var CHOMPING_CLIP  = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP  = 3;


var PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS       = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI               = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;


function _class(obj) { return Object.prototype.toString.call(obj); }

function is_EOL(c) {
  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);
}

function is_WHITE_SPACE(c) {
  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);
}

function is_WS_OR_EOL(c) {
  return (c === 0x09/* Tab */) ||
         (c === 0x20/* Space */) ||
         (c === 0x0A/* LF */) ||
         (c === 0x0D/* CR */);
}

function is_FLOW_INDICATOR(c) {
  return c === 0x2C/* , */ ||
         c === 0x5B/* [ */ ||
         c === 0x5D/* ] */ ||
         c === 0x7B/* { */ ||
         c === 0x7D/* } */;
}

function fromHexCode(c) {
  var lc;

  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  /*eslint-disable no-bitwise*/
  lc = c | 0x20;

  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {
    return lc - 0x61 + 10;
  }

  return -1;
}

function escapedHexLen(c) {
  if (c === 0x78/* x */) { return 2; }
  if (c === 0x75/* u */) { return 4; }
  if (c === 0x55/* U */) { return 8; }
  return 0;
}

function fromDecimalCode(c) {
  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  return -1;
}

function simpleEscapeSequence(c) {
  /* eslint-disable indent */
  return (c === 0x30/* 0 */) ? '\x00' :
        (c === 0x61/* a */) ? '\x07' :
        (c === 0x62/* b */) ? '\x08' :
        (c === 0x74/* t */) ? '\x09' :
        (c === 0x09/* Tab */) ? '\x09' :
        (c === 0x6E/* n */) ? '\x0A' :
        (c === 0x76/* v */) ? '\x0B' :
        (c === 0x66/* f */) ? '\x0C' :
        (c === 0x72/* r */) ? '\x0D' :
        (c === 0x65/* e */) ? '\x1B' :
        (c === 0x20/* Space */) ? ' ' :
        (c === 0x22/* " */) ? '\x22' :
        (c === 0x2F/* / */) ? '/' :
        (c === 0x5C/* \ */) ? '\x5C' :
        (c === 0x4E/* N */) ? '\x85' :
        (c === 0x5F/* _ */) ? '\xA0' :
        (c === 0x4C/* L */) ? '\u2028' :
        (c === 0x50/* P */) ? '\u2029' : '';
}

function charFromCodepoint(c) {
  if (c <= 0xFFFF) {
    return String.fromCharCode(c);
  }
  // Encode UTF-16 surrogate pair
  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
  return String.fromCharCode(
    ((c - 0x010000) >> 10) + 0xD800,
    ((c - 0x010000) & 0x03FF) + 0xDC00
  );
}

var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for (var i$1 = 0; i$1 < 256; i$1++) {
  simpleEscapeCheck[i$1] = simpleEscapeSequence(i$1) ? 1 : 0;
  simpleEscapeMap[i$1] = simpleEscapeSequence(i$1);
}


function State$1(input, options) {
  this.input = input;

  this.filename  = options['filename']  || null;
  this.schema    = options['schema']    || DEFAULT_SCHEMA$1;
  this.onWarning = options['onWarning'] || null;
  // (Hidden) Remove? makes the loader to expect YAML 1.1 documents
  // if such documents have no explicit %YAML directive
  this.legacy    = options['legacy']    || false;

  this.json      = options['json']      || false;
  this.listener  = options['listener']  || null;

  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap       = this.schema.compiledTypeMap;

  this.length     = input.length;
  this.position   = 0;
  this.line       = 0;
  this.lineStart  = 0;
  this.lineIndent = 0;

  // position of first leading tab in the current line,
  // used to make sure there are no tabs in the indentation
  this.firstTabInLine = -1;

  this.documents = [];

  /*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/

}


function generateError(state, message) {
  var mark = {
    name:     state.filename,
    buffer:   state.input.slice(0, -1), // omit trailing \0
    position: state.position,
    line:     state.line,
    column:   state.position - state.lineStart
  };

  mark.snippet = makeSnippet(mark);

  return new YAMLException$1(message, mark);
}

function throwError(state, message) {
  throw generateError(state, message);
}

function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}


var directiveHandlers = {

  YAML: function handleYamlDirective(state, name, args) {

    var match, major, minor;

    if (state.version !== null) {
      throwError(state, 'duplication of %YAML directive');
    }

    if (args.length !== 1) {
      throwError(state, 'YAML directive accepts exactly one argument');
    }

    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

    if (match === null) {
      throwError(state, 'ill-formed argument of the YAML directive');
    }

    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);

    if (major !== 1) {
      throwError(state, 'unacceptable YAML version of the document');
    }

    state.version = args[0];
    state.checkLineBreaks = (minor < 2);

    if (minor !== 1 && minor !== 2) {
      throwWarning(state, 'unsupported YAML version of the document');
    }
  },

  TAG: function handleTagDirective(state, name, args) {

    var handle, prefix;

    if (args.length !== 2) {
      throwError(state, 'TAG directive accepts exactly two arguments');
    }

    handle = args[0];
    prefix = args[1];

    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
    }

    if (_hasOwnProperty$1.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }

    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
    }

    try {
      prefix = decodeURIComponent(prefix);
    } catch (err) {
      throwError(state, 'tag prefix is malformed: ' + prefix);
    }

    state.tagMap[handle] = prefix;
  }
};


function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;

  if (start < end) {
    _result = state.input.slice(start, end);

    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 0x09 ||
              (0x20 <= _character && _character <= 0x10FFFF))) {
          throwError(state, 'expected valid JSON character');
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, 'the stream contains non-printable characters');
    }

    state.result += _result;
  }
}

function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;

  if (!common$1.isObject(source)) {
    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
  }

  sourceKeys = Object.keys(source);

  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];

    if (!_hasOwnProperty$1.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}

function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode,
  startLine, startLineStart, startPos) {

  var index, quantity;

  // The output is a plain object here, so keys can only be strings.
  // We need to convert keyNode to a string, but doing so can hang the process
  // (deeply nested arrays that explode exponentially using aliases).
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);

    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, 'nested arrays are not supported inside keys');
      }

      if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {
        keyNode[index] = '[object Object]';
      }
    }
  }

  // Avoid code execution in load() via toString property
  // (still use its own toString for arrays, timestamps,
  // and whatever user schema extensions happen to have @@toStringTag)
  if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {
    keyNode = '[object Object]';
  }


  keyNode = String(keyNode);

  if (_result === null) {
    _result = {};
  }

  if (keyTag === 'tag:yaml.org,2002:merge') {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json &&
        !_hasOwnProperty$1.call(overridableKeys, keyNode) &&
        _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, 'duplicated mapping key');
    }

    // used for this specific key only because Object.defineProperty is slow
    if (keyNode === '__proto__') {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
  }

  return _result;
}

function readLineBreak(state) {
  var ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x0A/* LF */) {
    state.position++;
  } else if (ch === 0x0D/* CR */) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {
      state.position++;
    }
  } else {
    throwError(state, 'a line break is expected');
  }

  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}

function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0,
      ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 0x09/* Tab */ && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }
      ch = state.input.charCodeAt(++state.position);
    }

    if (allowComments && ch === 0x23/* # */) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);
    }

    if (is_EOL(ch)) {
      readLineBreak(state);

      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;

      while (ch === 0x20/* Space */) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }

  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, 'deficient indentation');
  }

  return lineBreaks;
}

function testDocumentSeparator(state) {
  var _position = state.position,
      ch;

  ch = state.input.charCodeAt(_position);

  // Condition state.position === state.lineStart is tested
  // in parent on each call, for efficiency. No needs to test here again.
  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&
      ch === state.input.charCodeAt(_position + 1) &&
      ch === state.input.charCodeAt(_position + 2)) {

    _position += 3;

    ch = state.input.charCodeAt(_position);

    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }

  return false;
}

function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += ' ';
  } else if (count > 1) {
    state.result += common$1.repeat('\n', count - 1);
  }
}


function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding,
      following,
      captureStart,
      captureEnd,
      hasPendingContent,
      _line,
      _lineStart,
      _lineIndent,
      _kind = state.kind,
      _result = state.result,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (is_WS_OR_EOL(ch)      ||
      is_FLOW_INDICATOR(ch) ||
      ch === 0x23/* # */    ||
      ch === 0x26/* & */    ||
      ch === 0x2A/* * */    ||
      ch === 0x21/* ! */    ||
      ch === 0x7C/* | */    ||
      ch === 0x3E/* > */    ||
      ch === 0x27/* ' */    ||
      ch === 0x22/* " */    ||
      ch === 0x25/* % */    ||
      ch === 0x40/* @ */    ||
      ch === 0x60/* ` */) {
    return false;
  }

  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {
    following = state.input.charCodeAt(state.position + 1);

    if (is_WS_OR_EOL(following) ||
        withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }

  state.kind = 'scalar';
  state.result = '';
  captureStart = captureEnd = state.position;
  hasPendingContent = false;

  while (ch !== 0) {
    if (ch === 0x3A/* : */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following) ||
          withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }

    } else if (ch === 0x23/* # */) {
      preceding = state.input.charCodeAt(state.position - 1);

      if (is_WS_OR_EOL(preceding)) {
        break;
      }

    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||
               withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;

    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);

      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }

    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }

    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }

    ch = state.input.charCodeAt(++state.position);
  }

  captureSegment(state, captureStart, captureEnd, false);

  if (state.result) {
    return true;
  }

  state.kind = _kind;
  state.result = _result;
  return false;
}

function readSingleQuotedScalar(state, nodeIndent) {
  var ch,
      captureStart, captureEnd;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x27/* ' */) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x27/* ' */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (ch === 0x27/* ' */) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a single quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a single quoted scalar');
}

function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart,
      captureEnd,
      hexLength,
      hexResult,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x22/* " */) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x22/* " */) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;

    } else if (ch === 0x5C/* \ */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);

        // TODO: rework to inline fn with no type cast?
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;

      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;

        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);

          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;

          } else {
            throwError(state, 'expected hexadecimal character');
          }
        }

        state.result += charFromCodepoint(hexResult);

        state.position++;

      } else {
        throwError(state, 'unknown escape sequence');
      }

      captureStart = captureEnd = state.position;

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a double quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a double quoted scalar');
}

function readFlowCollection(state, nodeIndent) {
  var readNext = true,
      _line,
      _lineStart,
      _pos,
      _tag     = state.tag,
      _result,
      _anchor  = state.anchor,
      following,
      terminator,
      isPair,
      isExplicitPair,
      isMapping,
      overridableKeys = Object.create(null),
      keyNode,
      keyTag,
      valueNode,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x5B/* [ */) {
    terminator = 0x5D;/* ] */
    isMapping = false;
    _result = [];
  } else if (ch === 0x7B/* { */) {
    terminator = 0x7D;/* } */
    isMapping = true;
    _result = {};
  } else {
    return false;
  }

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(++state.position);

  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? 'mapping' : 'sequence';
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, 'missed comma between flow collection entries');
    } else if (ch === 0x2C/* , */) {
      // "flow collection entries can never be completely empty", as per YAML 1.2, section 7.4
      throwError(state, "expected the node content, but found ','");
    }

    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;

    if (ch === 0x3F/* ? */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }

    _line = state.line; // Save the current line.
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }

    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }

    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x2C/* , */) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }

  throwError(state, 'unexpected end of the stream within a flow collection');
}

function readBlockScalar(state, nodeIndent) {
  var captureStart,
      folding,
      chomping       = CHOMPING_CLIP,
      didReadContent = false,
      detectedIndent = false,
      textIndent     = nodeIndent,
      emptyLines     = 0,
      atMoreIndented = false,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x7C/* | */) {
    folding = false;
  } else if (ch === 0x3E/* > */) {
    folding = true;
  } else {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';

  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);

    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {
      if (CHOMPING_CLIP === chomping) {
        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, 'repeat of a chomping mode identifier');
      }

    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, 'repeat of an indentation width identifier');
      }

    } else {
      break;
    }
  }

  if (is_WHITE_SPACE(ch)) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (is_WHITE_SPACE(ch));

    if (ch === 0x23/* # */) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (!is_EOL(ch) && (ch !== 0));
    }
  }

  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;

    ch = state.input.charCodeAt(state.position);

    while ((!detectedIndent || state.lineIndent < textIndent) &&
           (ch === 0x20/* Space */)) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }

    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }

    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }

    // End of the scalar.
    if (state.lineIndent < textIndent) {

      // Perform the chomping.
      if (chomping === CHOMPING_KEEP) {
        state.result += common$1.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) { // i.e. only if the scalar is not empty.
          state.result += '\n';
        }
      }

      // Break this `while` cycle and go to the funciton's epilogue.
      break;
    }

    // Folded style: use fancy rules to handle line breaks.
    if (folding) {

      // Lines starting with white space characters (more-indented lines) are not folded.
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        // except for the first content line (cf. Example 8.1)
        state.result += common$1.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);

      // End of more-indented block.
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common$1.repeat('\n', emptyLines + 1);

      // Just one line break - perceive as the same line.
      } else if (emptyLines === 0) {
        if (didReadContent) { // i.e. only if we have already read some scalar content.
          state.result += ' ';
        }

      // Several line breaks - perceive as different lines.
      } else {
        state.result += common$1.repeat('\n', emptyLines);
      }

    // Literal style: just add exact number of line breaks between content lines.
    } else {
      // Keep all line breaks except the header line break.
      state.result += common$1.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
    }

    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;

    while (!is_EOL(ch) && (ch !== 0)) {
      ch = state.input.charCodeAt(++state.position);
    }

    captureSegment(state, captureStart, state.position, false);
  }

  return true;
}

function readBlockSequence(state, nodeIndent) {
  var _line,
      _tag      = state.tag,
      _anchor   = state.anchor,
      _result   = [],
      following,
      detected  = false,
      ch;

  // there is a leading tab before this token, so it can't be a block sequence/mapping;
  // it can still be flow sequence/mapping or a scalar
  if (state.firstTabInLine !== -1) return false;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, 'tab characters must not be used in indentation');
    }

    if (ch !== 0x2D/* - */) {
      break;
    }

    following = state.input.charCodeAt(state.position + 1);

    if (!is_WS_OR_EOL(following)) {
      break;
    }

    detected = true;
    state.position++;

    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {
      throwError(state, 'bad indentation of a sequence entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'sequence';
    state.result = _result;
    return true;
  }
  return false;
}

function readBlockMapping(state, nodeIndent, flowIndent) {
  var following,
      allowCompact,
      _line,
      _keyLine,
      _keyLineStart,
      _keyPos,
      _tag          = state.tag,
      _anchor       = state.anchor,
      _result       = {},
      overridableKeys = Object.create(null),
      keyTag        = null,
      keyNode       = null,
      valueNode     = null,
      atExplicitKey = false,
      detected      = false,
      ch;

  // there is a leading tab before this token, so it can't be a block sequence/mapping;
  // it can still be flow sequence/mapping or a scalar
  if (state.firstTabInLine !== -1) return false;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, 'tab characters must not be used in indentation');
    }

    following = state.input.charCodeAt(state.position + 1);
    _line = state.line; // Save the current line.

    //
    // Explicit notation case. There are two separate blocks:
    // first for the key (denoted by "?") and second for the value (denoted by ":")
    //
    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {

      if (ch === 0x3F/* ? */) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }

        detected = true;
        atExplicitKey = true;
        allowCompact = true;

      } else if (atExplicitKey) {
        // i.e. 0x3A/* : */ === character after the explicit key.
        atExplicitKey = false;
        allowCompact = true;

      } else {
        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
      }

      state.position += 1;
      ch = following;

    //
    // Implicit notation case. Flow-style node as the key first, then ":", and the value.
    //
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;

      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        // Neither implicit nor explicit notation.
        // Reading is done. Go to the epilogue.
        break;
      }

      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);

        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (ch === 0x3A/* : */) {
          ch = state.input.charCodeAt(++state.position);

          if (!is_WS_OR_EOL(ch)) {
            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
          }

          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;

        } else if (detected) {
          throwError(state, 'can not read an implicit mapping pair; a colon is missed');

        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }

      } else if (detected) {
        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');

      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true; // Keep the result of `composeNode`.
      }
    }

    //
    // Common reading code for both explicit and implicit notations.
    //
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }

      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }

      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }

      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }

    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {
      throwError(state, 'bad indentation of a mapping entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  //
  // Epilogue.
  //

  // Special case: last mapping's node contains only the key in explicit notation.
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }

  // Expose the resulting mapping.
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'mapping';
    state.result = _result;
  }

  return detected;
}

function readTagProperty(state) {
  var _position,
      isVerbatim = false,
      isNamed    = false,
      tagHandle,
      tagName,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x21/* ! */) return false;

  if (state.tag !== null) {
    throwError(state, 'duplication of a tag property');
  }

  ch = state.input.charCodeAt(++state.position);

  if (ch === 0x3C/* < */) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);

  } else if (ch === 0x21/* ! */) {
    isNamed = true;
    tagHandle = '!!';
    ch = state.input.charCodeAt(++state.position);

  } else {
    tagHandle = '!';
  }

  _position = state.position;

  if (isVerbatim) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (ch !== 0 && ch !== 0x3E/* > */);

    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, 'unexpected end of the stream within a verbatim tag');
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {

      if (ch === 0x21/* ! */) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);

          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, 'named tag handle cannot contain such characters');
          }

          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, 'tag suffix cannot contain exclamation marks');
        }
      }

      ch = state.input.charCodeAt(++state.position);
    }

    tagName = state.input.slice(_position, state.position);

    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, 'tag suffix cannot contain flow indicator characters');
    }
  }

  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, 'tag name cannot contain such characters: ' + tagName);
  }

  try {
    tagName = decodeURIComponent(tagName);
  } catch (err) {
    throwError(state, 'tag name is malformed: ' + tagName);
  }

  if (isVerbatim) {
    state.tag = tagName;

  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;

  } else if (tagHandle === '!') {
    state.tag = '!' + tagName;

  } else if (tagHandle === '!!') {
    state.tag = 'tag:yaml.org,2002:' + tagName;

  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }

  return true;
}

function readAnchorProperty(state) {
  var _position,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x26/* & */) return false;

  if (state.anchor !== null) {
    throwError(state, 'duplication of an anchor property');
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an anchor node must contain at least one character');
  }

  state.anchor = state.input.slice(_position, state.position);
  return true;
}

function readAlias(state) {
  var _position, alias,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x2A/* * */) return false;

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an alias node must contain at least one character');
  }

  alias = state.input.slice(_position, state.position);

  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }

  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}

function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles,
      allowBlockScalars,
      allowBlockCollections,
      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
      atNewLine  = false,
      hasContent = false,
      typeIndex,
      typeQuantity,
      typeList,
      type,
      flowIndent,
      blockIndent;

  if (state.listener !== null) {
    state.listener('open', state);
  }

  state.tag    = null;
  state.anchor = null;
  state.kind   = null;
  state.result = null;

  allowBlockStyles = allowBlockScalars = allowBlockCollections =
    CONTEXT_BLOCK_OUT === nodeContext ||
    CONTEXT_BLOCK_IN  === nodeContext;

  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;

      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }

  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;

        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }

  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }

  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }

    blockIndent = state.position - state.lineStart;

    if (indentStatus === 1) {
      if (allowBlockCollections &&
          (readBlockSequence(state, blockIndent) ||
           readBlockMapping(state, blockIndent, flowIndent)) ||
          readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||
            readSingleQuotedScalar(state, flowIndent) ||
            readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;

        } else if (readAlias(state)) {
          hasContent = true;

          if (state.tag !== null || state.anchor !== null) {
            throwError(state, 'alias node should not have any properties');
          }

        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;

          if (state.tag === null) {
            state.tag = '?';
          }
        }

        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      // Special case: block sequences are allowed to have same indentation level as the parent.
      // http://www.yaml.org/spec/1.2/spec.html#id2799784
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }

  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }

  } else if (state.tag === '?') {
    // Implicit resolving is not allowed for non-scalar types, and '?'
    // non-specific tag is only automatically assigned to plain scalars.
    //
    // We only need to check kind conformity in case user explicitly assigns '?'
    // tag, for example like this: "!<?> [0]"
    //
    if (state.result !== null && state.kind !== 'scalar') {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }

    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type = state.implicitTypes[typeIndex];

      if (type.resolve(state.result)) { // `state.result` updated in resolver if matched
        state.result = type.construct(state.result);
        state.tag = type.tag;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (state.tag !== '!') {
    if (_hasOwnProperty$1.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
      type = state.typeMap[state.kind || 'fallback'][state.tag];
    } else {
      // looking for multi type
      type = null;
      typeList = state.typeMap.multi[state.kind || 'fallback'];

      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type = typeList[typeIndex];
          break;
        }
      }
    }

    if (!type) {
      throwError(state, 'unknown tag !<' + state.tag + '>');
    }

    if (state.result !== null && type.kind !== state.kind) {
      throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
    }

    if (!type.resolve(state.result, state.tag)) { // `state.result` updated in resolver if matched
      throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
    } else {
      state.result = type.construct(state.result, state.tag);
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }

  if (state.listener !== null) {
    state.listener('close', state);
  }
  return state.tag !== null ||  state.anchor !== null || hasContent;
}

function readDocument(state) {
  var documentStart = state.position,
      _position,
      directiveName,
      directiveArgs,
      hasDirectives = false,
      ch;

  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = Object.create(null);
  state.anchorMap = Object.create(null);

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if (state.lineIndent > 0 || ch !== 0x25/* % */) {
      break;
    }

    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];

    if (directiveName.length < 1) {
      throwError(state, 'directive name must not be less than one character in length');
    }

    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      if (ch === 0x23/* # */) {
        do { ch = state.input.charCodeAt(++state.position); }
        while (ch !== 0 && !is_EOL(ch));
        break;
      }

      if (is_EOL(ch)) break;

      _position = state.position;

      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveArgs.push(state.input.slice(_position, state.position));
    }

    if (ch !== 0) readLineBreak(state);

    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }

  skipSeparationSpace(state, true, -1);

  if (state.lineIndent === 0 &&
      state.input.charCodeAt(state.position)     === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);

  } else if (hasDirectives) {
    throwError(state, 'directives end mark is expected');
  }

  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);

  if (state.checkLineBreaks &&
      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, 'non-ASCII line breaks are interpreted as content');
  }

  state.documents.push(state.result);

  if (state.position === state.lineStart && testDocumentSeparator(state)) {

    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }

  if (state.position < (state.length - 1)) {
    throwError(state, 'end of the stream or a document separator is expected');
  } else {
    return;
  }
}


function loadDocuments(input, options) {
  input = String(input);
  options = options || {};

  if (input.length !== 0) {

    // Add tailing `\n` if not exists
    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&
        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {
      input += '\n';
    }

    // Strip BOM
    if (input.charCodeAt(0) === 0xFEFF) {
      input = input.slice(1);
    }
  }

  var state = new State$1(input, options);

  var nullpos = input.indexOf('\0');

  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, 'null byte is not allowed in input');
  }

  // Use 0 as string terminator. That significantly simplifies bounds check.
  state.input += '\0';

  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {
    state.lineIndent += 1;
    state.position += 1;
  }

  while (state.position < (state.length - 1)) {
    readDocument(state);
  }

  return state.documents;
}


function loadAll(input, iterator, options) {
  if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {
    options = iterator;
    iterator = null;
  }

  var documents = loadDocuments(input, options);

  if (typeof iterator !== 'function') {
    return documents;
  }

  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}


function load$1(input, options) {
  var documents = loadDocuments(input, options);

  if (documents.length === 0) {
    /*eslint-disable no-undefined*/
    return undefined;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new YAMLException$1('expected a single document in the stream, but found more');
}


loader$1.loadAll = loadAll;
loader$1.load    = load$1;

var dumper$1 = {};

/*eslint-disable no-use-before-define*/

var common              = common$5;
var YAMLException       = exception;
var DEFAULT_SCHEMA      = _default;

var _toString       = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;

var CHAR_BOM                  = 0xFEFF;
var CHAR_TAB                  = 0x09; /* Tab */
var CHAR_LINE_FEED            = 0x0A; /* LF */
var CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */
var CHAR_SPACE                = 0x20; /* Space */
var CHAR_EXCLAMATION          = 0x21; /* ! */
var CHAR_DOUBLE_QUOTE         = 0x22; /* " */
var CHAR_SHARP                = 0x23; /* # */
var CHAR_PERCENT              = 0x25; /* % */
var CHAR_AMPERSAND            = 0x26; /* & */
var CHAR_SINGLE_QUOTE         = 0x27; /* ' */
var CHAR_ASTERISK             = 0x2A; /* * */
var CHAR_COMMA                = 0x2C; /* , */
var CHAR_MINUS                = 0x2D; /* - */
var CHAR_COLON                = 0x3A; /* : */
var CHAR_EQUALS               = 0x3D; /* = */
var CHAR_GREATER_THAN         = 0x3E; /* > */
var CHAR_QUESTION             = 0x3F; /* ? */
var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
var CHAR_GRAVE_ACCENT         = 0x60; /* ` */
var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
var CHAR_VERTICAL_LINE        = 0x7C; /* | */
var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */

var ESCAPE_SEQUENCES = {};

ESCAPE_SEQUENCES[0x00]   = '\\0';
ESCAPE_SEQUENCES[0x07]   = '\\a';
ESCAPE_SEQUENCES[0x08]   = '\\b';
ESCAPE_SEQUENCES[0x09]   = '\\t';
ESCAPE_SEQUENCES[0x0A]   = '\\n';
ESCAPE_SEQUENCES[0x0B]   = '\\v';
ESCAPE_SEQUENCES[0x0C]   = '\\f';
ESCAPE_SEQUENCES[0x0D]   = '\\r';
ESCAPE_SEQUENCES[0x1B]   = '\\e';
ESCAPE_SEQUENCES[0x22]   = '\\"';
ESCAPE_SEQUENCES[0x5C]   = '\\\\';
ESCAPE_SEQUENCES[0x85]   = '\\N';
ESCAPE_SEQUENCES[0xA0]   = '\\_';
ESCAPE_SEQUENCES[0x2028] = '\\L';
ESCAPE_SEQUENCES[0x2029] = '\\P';

var DEPRECATED_BOOLEANS_SYNTAX = [
  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',
  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'
];

var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;

function compileStyleMap(schema, map) {
  var result, keys, index, length, tag, style, type;

  if (map === null) return {};

  result = {};
  keys = Object.keys(map);

  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map[tag]);

    if (tag.slice(0, 2) === '!!') {
      tag = 'tag:yaml.org,2002:' + tag.slice(2);
    }
    type = schema.compiledTypeMap['fallback'][tag];

    if (type && _hasOwnProperty.call(type.styleAliases, style)) {
      style = type.styleAliases[style];
    }

    result[tag] = style;
  }

  return result;
}

function encodeHex(character) {
  var string, handle, length;

  string = character.toString(16).toUpperCase();

  if (character <= 0xFF) {
    handle = 'x';
    length = 2;
  } else if (character <= 0xFFFF) {
    handle = 'u';
    length = 4;
  } else if (character <= 0xFFFFFFFF) {
    handle = 'U';
    length = 8;
  } else {
    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
  }

  return '\\' + handle + common.repeat('0', length - string.length) + string;
}


var QUOTING_TYPE_SINGLE = 1,
    QUOTING_TYPE_DOUBLE = 2;

function State(options) {
  this.schema        = options['schema'] || DEFAULT_SCHEMA;
  this.indent        = Math.max(1, (options['indent'] || 2));
  this.noArrayIndent = options['noArrayIndent'] || false;
  this.skipInvalid   = options['skipInvalid'] || false;
  this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
  this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);
  this.sortKeys      = options['sortKeys'] || false;
  this.lineWidth     = options['lineWidth'] || 80;
  this.noRefs        = options['noRefs'] || false;
  this.noCompatMode  = options['noCompatMode'] || false;
  this.condenseFlow  = options['condenseFlow'] || false;
  this.quotingType   = options['quotingType'] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes   = options['forceQuotes'] || false;
  this.replacer      = typeof options['replacer'] === 'function' ? options['replacer'] : null;

  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;

  this.tag = null;
  this.result = '';

  this.duplicates = [];
  this.usedDuplicates = null;
}

// Indents every line in a string. Empty lines (\n only) are not indented.
function indentString(string, spaces) {
  var ind = common.repeat(' ', spaces),
      position = 0,
      next = -1,
      result = '',
      line,
      length = string.length;

  while (position < length) {
    next = string.indexOf('\n', position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }

    if (line.length && line !== '\n') result += ind;

    result += line;
  }

  return result;
}

function generateNextLine(state, level) {
  return '\n' + common.repeat(' ', state.indent * level);
}

function testImplicitResolving(state, str) {
  var index, length, type;

  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type = state.implicitTypes[index];

    if (type.resolve(str)) {
      return true;
    }
  }

  return false;
}

// [33] s-white ::= s-space | s-tab
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}

// Returns true if the character can be printed without escaping.
// From YAML 1.2: "any allowed characters known to be non-printable
// should also be escaped. [However,] This isn’t mandatory"
// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
function isPrintable(c) {
  return  (0x00020 <= c && c <= 0x00007E)
      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)
      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== CHAR_BOM)
      ||  (0x10000 <= c && c <= 0x10FFFF);
}

// [34] ns-char ::= nb-char - s-white
// [27] nb-char ::= c-printable - b-char - c-byte-order-mark
// [26] b-char  ::= b-line-feed | b-carriage-return
// Including s-white (for some reason, examples doesn't match specs in this aspect)
// ns-char ::= c-printable - b-line-feed - b-carriage-return - c-byte-order-mark
function isNsCharOrWhitespace(c) {
  return isPrintable(c)
    && c !== CHAR_BOM
    // - b-char
    && c !== CHAR_CARRIAGE_RETURN
    && c !== CHAR_LINE_FEED;
}

// [127]  ns-plain-safe(c) ::= c = flow-out  ⇒ ns-plain-safe-out
//                             c = flow-in   ⇒ ns-plain-safe-in
//                             c = block-key ⇒ ns-plain-safe-out
//                             c = flow-key  ⇒ ns-plain-safe-in
// [128] ns-plain-safe-out ::= ns-char
// [129]  ns-plain-safe-in ::= ns-char - c-flow-indicator
// [130]  ns-plain-char(c) ::=  ( ns-plain-safe(c) - “:” - “#” )
//                            | ( /* An ns-char preceding */ “#” )
//                            | ( “:” /* Followed by an ns-plain-safe(c) */ )
function isPlainSafe(c, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
  return (
    // ns-plain-safe
    inblock ? // c = flow-in
      cIsNsCharOrWhitespace
      : cIsNsCharOrWhitespace
        // - c-flow-indicator
        && c !== CHAR_COMMA
        && c !== CHAR_LEFT_SQUARE_BRACKET
        && c !== CHAR_RIGHT_SQUARE_BRACKET
        && c !== CHAR_LEFT_CURLY_BRACKET
        && c !== CHAR_RIGHT_CURLY_BRACKET
  )
    // ns-plain-char
    && c !== CHAR_SHARP // false on '#'
    && !(prev === CHAR_COLON && !cIsNsChar) // false on ': '
    || (isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP) // change to true on '[^ ]#'
    || (prev === CHAR_COLON && cIsNsChar); // change to true on ':[^ ]'
}

// Simplified test for values allowed as the first character in plain style.
function isPlainSafeFirst(c) {
  // Uses a subset of ns-char - c-indicator
  // where ns-char = nb-char - s-white.
  // No support of ( ( “?” | “:” | “-” ) /* Followed by an ns-plain-safe(c)) */ ) part
  return isPrintable(c) && c !== CHAR_BOM
    && !isWhitespace(c) // - s-white
    // - (c-indicator ::=
    // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”
    && c !== CHAR_MINUS
    && c !== CHAR_QUESTION
    && c !== CHAR_COLON
    && c !== CHAR_COMMA
    && c !== CHAR_LEFT_SQUARE_BRACKET
    && c !== CHAR_RIGHT_SQUARE_BRACKET
    && c !== CHAR_LEFT_CURLY_BRACKET
    && c !== CHAR_RIGHT_CURLY_BRACKET
    // | “#” | “&” | “*” | “!” | “|” | “=” | “>” | “'” | “"”
    && c !== CHAR_SHARP
    && c !== CHAR_AMPERSAND
    && c !== CHAR_ASTERISK
    && c !== CHAR_EXCLAMATION
    && c !== CHAR_VERTICAL_LINE
    && c !== CHAR_EQUALS
    && c !== CHAR_GREATER_THAN
    && c !== CHAR_SINGLE_QUOTE
    && c !== CHAR_DOUBLE_QUOTE
    // | “%” | “@” | “`”)
    && c !== CHAR_PERCENT
    && c !== CHAR_COMMERCIAL_AT
    && c !== CHAR_GRAVE_ACCENT;
}

// Simplified test for values allowed as the last character in plain style.
function isPlainSafeLast(c) {
  // just not whitespace or colon, it will be checked to be plain character later
  return !isWhitespace(c) && c !== CHAR_COLON;
}

// Same as 'string'.codePointAt(pos), but works in older browsers.
function codePointAt(string, pos) {
  var first = string.charCodeAt(pos), second;
  if (first >= 0xD800 && first <= 0xDBFF && pos + 1 < string.length) {
    second = string.charCodeAt(pos + 1);
    if (second >= 0xDC00 && second <= 0xDFFF) {
      // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
      return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
    }
  }
  return first;
}

// Determines whether block indentation indicator is required.
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}

var STYLE_PLAIN   = 1,
    STYLE_SINGLE  = 2,
    STYLE_LITERAL = 3,
    STYLE_FOLDED  = 4,
    STYLE_DOUBLE  = 5;

// Determines which scalar styles are possible and returns the preferred style.
// lineWidth = -1 => no limit.
// Pre-conditions: str.length > 0.
// Post-conditions:
//    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth,
  testAmbiguousType, quotingType, forceQuotes, inblock) {

  var i;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false; // only checked if shouldTrackWidth
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1; // count the first line correctly
  var plain = isPlainSafeFirst(codePointAt(string, 0))
          && isPlainSafeLast(codePointAt(string, string.length - 1));

  if (singleLineOnly || forceQuotes) {
    // Case: no block styles.
    // Check for disallowed characters to rule out plain and single.
    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    // Case: block styles permitted.
    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        // Check if any line can be folded.
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine ||
            // Foldable line = too long, and not more-indented.
            (i - previousLineBreak - 1 > lineWidth &&
             string[previousLineBreak + 1] !== ' ');
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    // in case the end is missing a \n
    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&
      (i - previousLineBreak - 1 > lineWidth &&
       string[previousLineBreak + 1] !== ' '));
  }
  // Although every style can represent \n without escaping, prefer block styles
  // for multiline, since they're more readable and they don't add empty lines.
  // Also prefer folding a super-long line.
  if (!hasLineBreak && !hasFoldableLine) {
    // Strings interpretable as another type have to be quoted;
    // e.g. the string 'true' vs. the boolean true.
    if (plain && !forceQuotes && !testAmbiguousType(string)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  // Edge case: block indentation indicator can only have one digit.
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  // At this point we know block styles are valid.
  // Prefer literal style unless we want to fold.
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}

// Note: line breaking/folding is implemented for only the folded style.
// NB. We drop the last trailing newline (if any) of a returned block scalar
//  since the dumper adds its own newline. This always works:
//    • No ending newline => unaffected; already using strip "-" chomping.
//    • Ending newline    => removed then restored.
//  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
function writeScalar(state, string, level, iskey, inblock) {
  state.dump = (function () {
    if (string.length === 0) {
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? ('"' + string + '"') : ("'" + string + "'");
      }
    }

    var indent = state.indent * Math.max(1, level); // no 0-indent scalars
    // As indentation gets deeper, let the width decrease monotonically
    // to the lower bound min(state.lineWidth, 40).
    // Note that this implies
    //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.
    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
    // This behaves better than a constant minimum width which disallows narrower options,
    // or an indent threshold which causes the width to suddenly increase.
    var lineWidth = state.lineWidth === -1
      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);

    // Without knowing if keys are implicit/explicit, assume implicit for safety.
    var singleLineOnly = iskey
      // No block styles in flow mode.
      || (state.flowLevel > -1 && level >= state.flowLevel);
    function testAmbiguity(string) {
      return testImplicitResolving(state, string);
    }

    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth,
      testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {

      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return '|' + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return '>' + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string) + '"';
      default:
        throw new YAMLException('impossible error: invalid scalar style');
    }
  }());
}

// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';

  // note the special case: the string '\n' counts as a "trailing" empty line.
  var clip =          string[string.length - 1] === '\n';
  var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
  var chomp = keep ? '+' : (clip ? '' : '-');

  return indentIndicator + chomp + '\n';
}

// (See the note for writeScalar.)
function dropEndingNewline(string) {
  return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
}

// Note: a long line without a suitable break point will exceed the width limit.
// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
function foldString(string, width) {
  // In folded style, $k$ consecutive newlines output as $k+1$ newlines—
  // unless they're before or after a more-indented line, or at the very
  // beginning or end, in which case $k$ maps to $k$.
  // Therefore, parse each chunk as newline(s) followed by a content line.
  var lineRe = /(\n+)([^\n]*)/g;

  // first line (possibly an empty line)
  var result = (function () {
    var nextLF = string.indexOf('\n');
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }());
  // If we haven't reached the first content line yet, don't add an extra \n.
  var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
  var moreIndented;

  // rest of the lines
  var match;
  while ((match = lineRe.exec(string))) {
    var prefix = match[1], line = match[2];
    moreIndented = (line[0] === ' ');
    result += prefix
      + (!prevMoreIndented && !moreIndented && line !== ''
        ? '\n' : '')
      + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }

  return result;
}

// Greedy line breaking.
// Picks the longest line under the limit each time,
// otherwise settles for the shortest line over the limit.
// NB. More-indented lines *cannot* be folded, as that would add an extra \n.
function foldLine(line, width) {
  if (line === '' || line[0] === ' ') return line;

  // Since a more-indented line adds a \n, breaks can't be followed by a space.
  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
  var match;
  // start is an inclusive index. end, curr, and next are exclusive.
  var start = 0, end, curr = 0, next = 0;
  var result = '';

  // Invariants: 0 <= start <= length-1.
  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
  // Inside the loop:
  //   A match implies length >= 2, so curr and next are <= length-2.
  while ((match = breakRe.exec(line))) {
    next = match.index;
    // maintain invariant: curr - start <= width
    if (next - start > width) {
      end = (curr > start) ? curr : next; // derive end <= length-2
      result += '\n' + line.slice(start, end);
      // skip the space that was output as \n
      start = end + 1;                    // derive start <= length-1
    }
    curr = next;
  }

  // By the invariants, start <= length-1, so there is something left over.
  // It is either the whole string or a part starting from non-whitespace.
  result += '\n';
  // Insert a break if the remainder is too long and there is a break available.
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }

  return result.slice(1); // drop extra \n joiner
}

// Escapes a double-quoted string.
function escapeString(string) {
  var result = '';
  var char = 0;
  var escapeSeq;

  for (var i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {
    char = codePointAt(string, i);
    escapeSeq = ESCAPE_SEQUENCES[char];

    if (!escapeSeq && isPrintable(char)) {
      result += string[i];
      if (char >= 0x10000) result += string[i + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }

  return result;
}

function writeFlowSequence(state, level, object) {
  var _result = '',
      _tag    = state.tag,
      index,
      length,
      value;

  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];

    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }

    // Write only valid elements, put null instead of invalid elements.
    if (writeNode(state, level, value, false, false) ||
        (typeof value === 'undefined' &&
         writeNode(state, level, null, false, false))) {

      if (_result !== '') _result += ',' + (!state.condenseFlow ? ' ' : '');
      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = '[' + _result + ']';
}

function writeBlockSequence(state, level, object, compact) {
  var _result = '',
      _tag    = state.tag,
      index,
      length,
      value;

  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];

    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }

    // Write only valid elements, put null instead of invalid elements.
    if (writeNode(state, level + 1, value, true, true, false, true) ||
        (typeof value === 'undefined' &&
         writeNode(state, level + 1, null, true, true, false, true))) {

      if (!compact || _result !== '') {
        _result += generateNextLine(state, level);
      }

      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += '-';
      } else {
        _result += '- ';
      }

      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = _result || '[]'; // Empty sequence if no valid values.
}

function writeFlowMapping(state, level, object) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {

    pairBuffer = '';
    if (_result !== '') pairBuffer += ', ';

    if (state.condenseFlow) pairBuffer += '"';

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }

    if (!writeNode(state, level, objectKey, false, false)) {
      continue; // Skip this pair because of invalid key;
    }

    if (state.dump.length > 1024) pairBuffer += '? ';

    pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');

    if (!writeNode(state, level, objectValue, false, false)) {
      continue; // Skip this pair because of invalid value.
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = '{' + _result + '}';
}

function writeBlockMapping(state, level, object, compact) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      explicitPair,
      pairBuffer;

  // Allow sorting keys so that the output file is deterministic
  if (state.sortKeys === true) {
    // Default sorting
    objectKeyList.sort();
  } else if (typeof state.sortKeys === 'function') {
    // Custom sort function
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    // Something is wrong
    throw new YAMLException('sortKeys must be a boolean or a function');
  }

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (!compact || _result !== '') {
      pairBuffer += generateNextLine(state, level);
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }

    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue; // Skip this pair because of invalid key.
    }

    explicitPair = (state.tag !== null && state.tag !== '?') ||
                   (state.dump && state.dump.length > 1024);

    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += '?';
      } else {
        pairBuffer += '? ';
      }
    }

    pairBuffer += state.dump;

    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }

    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue; // Skip this pair because of invalid value.
    }

    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ':';
    } else {
      pairBuffer += ': ';
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = _result || '{}'; // Empty mapping if no valid pairs.
}

function detectType(state, object, explicit) {
  var _result, typeList, index, length, type, style;

  typeList = explicit ? state.explicitTypes : state.implicitTypes;

  for (index = 0, length = typeList.length; index < length; index += 1) {
    type = typeList[index];

    if ((type.instanceOf  || type.predicate) &&
        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&
        (!type.predicate  || type.predicate(object))) {

      if (explicit) {
        if (type.multi && type.representName) {
          state.tag = type.representName(object);
        } else {
          state.tag = type.tag;
        }
      } else {
        state.tag = '?';
      }

      if (type.represent) {
        style = state.styleMap[type.tag] || type.defaultStyle;

        if (_toString.call(type.represent) === '[object Function]') {
          _result = type.represent(object, style);
        } else if (_hasOwnProperty.call(type.represent, style)) {
          _result = type.represent[style](object, style);
        } else {
          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
        }

        state.dump = _result;
      }

      return true;
    }
  }

  return false;
}

// Serializes `object` and writes it to global `result`.
// Returns true on success, or false on invalid object.
//
function writeNode(state, level, object, block, compact, iskey, isblockseq) {
  state.tag = null;
  state.dump = object;

  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }

  var type = _toString.call(state.dump);
  var inblock = block;
  var tagStr;

  if (block) {
    block = (state.flowLevel < 0 || state.flowLevel > level);
  }

  var objectOrArray = type === '[object Object]' || type === '[object Array]',
      duplicateIndex,
      duplicate;

  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }

  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {
    compact = false;
  }

  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = '*ref_' + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type === '[object Object]') {
      if (block && (Object.keys(state.dump).length !== 0)) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object Array]') {
      if (block && (state.dump.length !== 0)) {
        if (state.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state, level - 1, state.dump, compact);
        } else {
          writeBlockSequence(state, level, state.dump, compact);
        }
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object String]') {
      if (state.tag !== '?') {
        writeScalar(state, state.dump, level, iskey, inblock);
      }
    } else if (type === '[object Undefined]') {
      return false;
    } else {
      if (state.skipInvalid) return false;
      throw new YAMLException('unacceptable kind of an object to dump ' + type);
    }

    if (state.tag !== null && state.tag !== '?') {
      // Need to encode all characters except those allowed by the spec:
      //
      // [35] ns-dec-digit    ::=  [#x30-#x39] /* 0-9 */
      // [36] ns-hex-digit    ::=  ns-dec-digit
      //                         | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */
      // [37] ns-ascii-letter ::=  [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */
      // [38] ns-word-char    ::=  ns-dec-digit | ns-ascii-letter | “-”
      // [39] ns-uri-char     ::=  “%” ns-hex-digit ns-hex-digit | ns-word-char | “#”
      //                         | “;” | “/” | “?” | “:” | “@” | “&” | “=” | “+” | “$” | “,”
      //                         | “_” | “.” | “!” | “~” | “*” | “'” | “(” | “)” | “[” | “]”
      //
      // Also need to encode '!' because it has special meaning (end of tag prefix).
      //
      tagStr = encodeURI(
        state.tag[0] === '!' ? state.tag.slice(1) : state.tag
      ).replace(/!/g, '%21');

      if (state.tag[0] === '!') {
        tagStr = '!' + tagStr;
      } else if (tagStr.slice(0, 18) === 'tag:yaml.org,2002:') {
        tagStr = '!!' + tagStr.slice(18);
      } else {
        tagStr = '!<' + tagStr + '>';
      }

      state.dump = tagStr + ' ' + state.dump;
    }
  }

  return true;
}

function getDuplicateReferences(object, state) {
  var objects = [],
      duplicatesIndexes = [],
      index,
      length;

  inspectNode(object, objects, duplicatesIndexes);

  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}

function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList,
      index,
      length;

  if (object !== null && typeof object === 'object') {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);

      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);

        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}

function dump$1(input, options) {
  options = options || {};

  var state = new State(options);

  if (!state.noRefs) getDuplicateReferences(input, state);

  var value = input;

  if (state.replacer) {
    value = state.replacer.call({ '': value }, '', value);
  }

  if (writeNode(state, 0, value, true, true)) return state.dump + '\n';

  return '';
}

dumper$1.dump = dump$1;

var loader = loader$1;
var dumper = dumper$1;
var load = loader.load;
var dump = dumper.dump;

class GUISupportError extends Error {
    constructor(message, warnings, errors) {
        super(message);
        this.name = "GUISupportError";
        this.warnings = warnings;
        this.errors = errors;
    }
}

class MushroomElementEditor extends s$1 {
    constructor() {
        super(...arguments);
        this._guiMode = true;
        this._loading = false;
    }
    get yaml() {
        if (!this._yaml) {
            this._yaml = dump(this._config);
        }
        return this._yaml || "";
    }
    set yaml(_yaml) {
        this._yaml = _yaml;
        try {
            this._config = load(this.yaml);
            this._errors = undefined;
        }
        catch (err) {
            this._errors = [err.message];
        }
        this._setConfig();
    }
    get value() {
        return this._config;
    }
    set value(config) {
        if (this._config && deepEqual(config, this._config)) {
            return;
        }
        this._config = config;
        this._yaml = undefined;
        this._errors = undefined;
        this._setConfig();
    }
    _setConfig() {
        var _a;
        if (!this._errors) {
            try {
                this._updateConfigElement();
            }
            catch (err) {
                this._errors = [err.message];
            }
        }
        fireEvent(this, "config-changed", {
            config: this.value,
            // @ts-ignore
            error: (_a = this._errors) === null || _a === void 0 ? void 0 : _a.join(", "),
            guiModeAvailable: !(this.hasWarning || this.hasError || this._guiSupported === false),
        });
    }
    get hasWarning() {
        return this._warnings !== undefined && this._warnings.length > 0;
    }
    get hasError() {
        return this._errors !== undefined && this._errors.length > 0;
    }
    get GUImode() {
        return this._guiMode;
    }
    set GUImode(guiMode) {
        this._guiMode = guiMode;
        fireEvent(this, "GUImode-changed", {
            guiMode,
            guiModeAvailable: !(this.hasWarning || this.hasError || this._guiSupported === false),
        });
    }
    toggleMode() {
        this.GUImode = !this.GUImode;
    }
    focusYamlEditor() {
        var _a, _b;
        if ((_a = this._configElement) === null || _a === void 0 ? void 0 : _a.focusYamlEditor) {
            this._configElement.focusYamlEditor();
        }
        if (!((_b = this._yamlEditor) === null || _b === void 0 ? void 0 : _b.codemirror)) {
            return;
        }
        this._yamlEditor.codemirror.focus();
    }
    async getConfigElement() {
        return undefined;
    }
    get configElementType() {
        return this.value ? this.value.type : undefined;
    }
    render() {
        return $ `
            <div class="wrapper">
                ${this.GUImode
            ? $ `
                          <div class="gui-editor">
                              ${this._loading
                ? $ `
                                        <ha-circular-progress
                                            active
                                            alt="Loading"
                                            class="center margin-bot"
                                        ></ha-circular-progress>
                                    `
                : this._configElement}
                          </div>
                      `
            : $ `
                          <div class="yaml-editor">
                              <ha-code-editor
                                  mode="yaml"
                                  autofocus
                                  .value=${this.yaml}
                                  .error=${Boolean(this._errors)}
                                  .rtl=${computeRTL(this.hass)}
                                  @value-changed=${this._handleYAMLChanged}
                                  @keydown=${this._ignoreKeydown}
                              ></ha-code-editor>
                          </div>
                      `}
                ${this._guiSupported === false && this.configElementType
            ? $ `
                          <div class="info">
                              ${this.hass.localize("ui.errors.config.editor_not_available", "type", this.configElementType)}
                          </div>
                      `
            : ""}
                ${this.hasError
            ? $ `
                          <div class="error">
                              ${this.hass.localize("ui.errors.config.error_detected")}:
                              <br />
                              <ul>
                                  ${this._errors.map((error) => $ `<li>${error}</li>`)}
                              </ul>
                          </div>
                      `
            : ""}
                ${this.hasWarning
            ? $ `
                          <ha-alert
                              alert-type="warning"
                              .title="${this.hass.localize("ui.errors.config.editor_not_supported")}:"
                          >
                              ${this._warnings.length > 0 && this._warnings[0] !== undefined
                ? $ `
                                        <ul>
                                            ${this._warnings.map((warning) => $ `<li>${warning}</li>`)}
                                        </ul>
                                    `
                : undefined}
                              ${this.hass.localize("ui.errors.config.edit_in_yaml_supported")}
                          </ha-alert>
                      `
            : ""}
            </div>
        `;
    }
    updated(changedProperties) {
        super.updated(changedProperties);
        if (this._configElement && changedProperties.has("hass")) {
            this._configElement.hass = this.hass;
        }
        if (this._configElement &&
            "lovelace" in this._configElement &&
            changedProperties.has("lovelace")) {
            this._configElement.lovelace = this.lovelace;
        }
    }
    _handleUIConfigChanged(ev) {
        ev.stopPropagation();
        const config = ev.detail.config;
        this.value = config;
    }
    _handleYAMLChanged(ev) {
        ev.stopPropagation();
        const newYaml = ev.detail.value;
        if (newYaml !== this.yaml) {
            this.yaml = newYaml;
        }
    }
    async _updateConfigElement() {
        var _a;
        if (!this.value) {
            return;
        }
        let configElement;
        try {
            this._errors = undefined;
            this._warnings = undefined;
            if (this._configElementType !== this.configElementType) {
                // If the type has changed, we need to load a new GUI editor
                this._guiSupported = undefined;
                this._configElement = undefined;
                if (!this.configElementType) {
                    throw new Error(this.hass.localize("ui.errors.config.no_type_provided"));
                }
                this._configElementType = this.configElementType;
                this._loading = true;
                configElement = await this.getConfigElement();
                if (configElement) {
                    configElement.hass = this.hass;
                    if ("lovelace" in configElement) {
                        configElement.lovelace = this.lovelace;
                    }
                    configElement.addEventListener("config-changed", (ev) => this._handleUIConfigChanged(ev));
                    this._configElement = configElement;
                    this._guiSupported = true;
                }
            }
            if (this._configElement) {
                // Setup GUI editor and check that it can handle the current config
                try {
                    this._configElement.setConfig(this.value);
                }
                catch (err) {
                    const msgs = handleStructError(this.hass, err);
                    throw new GUISupportError("Config is not supported", msgs.warnings, msgs.errors);
                }
            }
            else {
                this.GUImode = false;
            }
        }
        catch (err) {
            if (err instanceof GUISupportError) {
                this._warnings = (_a = err.warnings) !== null && _a !== void 0 ? _a : [err.message];
                this._errors = err.errors || undefined;
            }
            else {
                this._errors = [err.message];
            }
            this.GUImode = false;
        }
        finally {
            this._loading = false;
        }
    }
    _ignoreKeydown(ev) {
        ev.stopPropagation();
    }
    static get styles() {
        return r$3 `
            :host {
                display: flex;
            }
            .wrapper {
                width: 100%;
            }
            .gui-editor,
            .yaml-editor {
                padding: 8px 0px;
            }
            ha-code-editor {
                --code-mirror-max-height: calc(100vh - 245px);
            }
            .error,
            .warning,
            .info {
                word-break: break-word;
                margin-top: 8px;
            }
            .error {
                color: var(--error-color);
            }
            .warning {
                color: var(--warning-color);
            }
            .warning ul,
            .error ul {
                margin: 4px 0;
            }
            .warning li,
            .error li {
                white-space: pre-wrap;
            }
            ha-circular-progress {
                display: block;
                margin: auto;
            }
        `;
    }
}
__decorate([
    e$3({ attribute: false })
], MushroomElementEditor.prototype, "hass", void 0);
__decorate([
    e$3({ attribute: false })
], MushroomElementEditor.prototype, "lovelace", void 0);
__decorate([
    t$1()
], MushroomElementEditor.prototype, "_yaml", void 0);
__decorate([
    t$1()
], MushroomElementEditor.prototype, "_config", void 0);
__decorate([
    t$1()
], MushroomElementEditor.prototype, "_configElement", void 0);
__decorate([
    t$1()
], MushroomElementEditor.prototype, "_configElementType", void 0);
__decorate([
    t$1()
], MushroomElementEditor.prototype, "_guiMode", void 0);
__decorate([
    t$1()
], MushroomElementEditor.prototype, "_errors", void 0);
__decorate([
    t$1()
], MushroomElementEditor.prototype, "_warnings", void 0);
__decorate([
    t$1()
], MushroomElementEditor.prototype, "_guiSupported", void 0);
__decorate([
    t$1()
], MushroomElementEditor.prototype, "_loading", void 0);
__decorate([
    i$4("ha-code-editor")
], MushroomElementEditor.prototype, "_yamlEditor", void 0);

let MushroomChipElementEditor = class MushroomChipElementEditor extends MushroomElementEditor {
    get configElementType() {
        var _a;
        return (_a = this.value) === null || _a === void 0 ? void 0 : _a.type;
    }
    async getConfigElement() {
        const elClass = (await getChipElementClass(this.configElementType));
        // Check if a GUI editor exists
        if (elClass && elClass.getConfigElement) {
            return elClass.getConfigElement();
        }
        return undefined;
    }
};
MushroomChipElementEditor = __decorate([
    n$1("mushroom-chip-element-editor")
], MushroomChipElementEditor);
const getChipElementClass = (type) => customElements.get(computeChipComponentName(type));

const CHIP_LIST = [
    "action",
    "alarm-control-panel",
    "back",
    "conditional",
    "entity",
    "light",
    "menu",
    "template",
    "weather",
];

let ConditionalChipEditor = class ConditionalChipEditor extends s$1 {
    constructor() {
        super(...arguments);
        this._GUImode = true;
        this._guiModeAvailable = true;
        this._cardTab = false;
    }
    setConfig(config) {
        this._config = config;
    }
    focusYamlEditor() {
        var _a;
        (_a = this._cardEditorEl) === null || _a === void 0 ? void 0 : _a.focusYamlEditor();
    }
    render() {
        var _a;
        if (!this.hass || !this._config) {
            return $ ``;
        }
        const customLocalize = setupCustomlocalize(this.hass);
        const rtl = computeRTL(this.hass);
        return $ `
            <mwc-tab-bar
                .activeIndex=${this._cardTab ? 1 : 0}
                @MDCTabBar:activated=${this._selectTab}
            >
                <mwc-tab
                    .label=${this.hass.localize("ui.panel.lovelace.editor.card.conditional.conditions")}
                ></mwc-tab>
                <mwc-tab .label=${customLocalize("editor.chip.conditional.chip")}></mwc-tab>
            </mwc-tab-bar>
            ${this._cardTab
            ? $ `
                      <div class="card">
                          ${((_a = this._config.chip) === null || _a === void 0 ? void 0 : _a.type) !== undefined
                ? $ `
                                    <div class="card-options">
                                        <mwc-button
                                            @click=${this._toggleMode}
                                            .disabled=${!this._guiModeAvailable}
                                            class="gui-mode-button"
                                        >
                                            ${this.hass.localize(!this._cardEditorEl || this._GUImode
                    ? "ui.panel.lovelace.editor.edit_card.show_code_editor"
                    : "ui.panel.lovelace.editor.edit_card.show_visual_editor")}
                                        </mwc-button>
                                        <mwc-button @click=${this._handleReplaceChip}
                                            >${this.hass.localize("ui.panel.lovelace.editor.card.conditional.change_type")}</mwc-button
                                        >
                                    </div>
                                    <mushroom-chip-element-editor
                                        class="editor"
                                        .hass=${this.hass}
                                        .value=${this._config.chip}
                                        @config-changed=${this._handleChipChanged}
                                        @GUImode-changed=${this._handleGUIModeChanged}
                                    ></mushroom-chip-element-editor>
                                `
                : $ `
                                    <mushroom-select
                                        .label=${customLocalize("editor.chip.chip-picker.select")}
                                        @selected=${this._handleChipPicked}
                                        @closed=${(e) => e.stopPropagation()}
                                        fixedMenuPosition
                                        naturalMenuWidth
                                    >
                                        ${CHIP_LIST.map((chip) => $ `
                                                    <mwc-list-item .value=${chip}>
                                                        ${customLocalize(`editor.chip.chip-picker.types.${chip}`)}
                                                    </mwc-list-item>
                                                `)}
                                    </mushroom-select>
                                `}
                      </div>
                  `
            : $ `
                      <div class="conditions">
                          ${this.hass.localize("ui.panel.lovelace.editor.card.conditional.condition_explanation")}
                          ${this._config.conditions.map((cond, idx) => {
                var _a;
                return $ `
                                  <div class="condition" ?rtl=${rtl}>
                                      <div class="entity">
                                          <ha-entity-picker
                                              .hass=${this.hass}
                                              .value=${cond.entity}
                                              .idx=${idx}
                                              .configValue=${"entity"}
                                              @change=${this._changeCondition}
                                              allow-custom-entity
                                          ></ha-entity-picker>
                                      </div>
                                      <div class="state">
                                          <mushroom-select
                                              .value=${cond.state_not !== undefined
                    ? "true"
                    : "false"}
                                              .idx=${idx}
                                              .configValue=${"invert"}
                                              @selected=${this._changeCondition}
                                              @closed=${(e) => e.stopPropagation()}
                                              naturalMenuWidth
                                              fixedMenuPosition
                                          >
                                              <mwc-list-item value="false">
                                                  ${this.hass.localize("ui.panel.lovelace.editor.card.conditional.state_equal")}
                                              </mwc-list-item>
                                              <mwc-list-item value="true">
                                                  ${this.hass.localize("ui.panel.lovelace.editor.card.conditional.state_not_equal")}
                                              </mwc-list-item>
                                          </mushroom-select>
                                          <mushroom-textfield
                                              .label="${this.hass.localize("ui.panel.lovelace.editor.card.generic.state")} (${this.hass.localize("ui.panel.lovelace.editor.card.conditional.current_state")}: ${(_a = this.hass) === null || _a === void 0 ? void 0 : _a.states[cond.entity].state})"
                                              .value=${cond.state_not !== undefined
                    ? cond.state_not
                    : cond.state}
                                              .idx=${idx}
                                              .configValue=${"state"}
                                              @input=${this._changeCondition}
                                          >
                                          </mushroom-textfield>
                                      </div>
                                  </div>
                              `;
            })}
                          <div class="condition">
                              <ha-entity-picker
                                  .hass=${this.hass}
                                  @change=${this._addCondition}
                              ></ha-entity-picker>
                          </div>
                      </div>
                  `}
        `;
    }
    _selectTab(ev) {
        this._cardTab = ev.detail.index === 1;
    }
    _toggleMode() {
        var _a;
        (_a = this._cardEditorEl) === null || _a === void 0 ? void 0 : _a.toggleMode();
    }
    _setMode(value) {
        this._GUImode = value;
        if (this._cardEditorEl) {
            this._cardEditorEl.GUImode = value;
        }
    }
    _handleGUIModeChanged(ev) {
        ev.stopPropagation();
        this._GUImode = ev.detail.guiMode;
        this._guiModeAvailable = ev.detail.guiModeAvailable;
    }
    async _handleChipPicked(ev) {
        const value = ev.target.value;
        if (value === "") {
            return;
        }
        let newChip;
        const elClass = getChipElementClass(value);
        if (elClass && elClass.getStubConfig) {
            newChip = (await elClass.getStubConfig(this.hass));
        }
        else {
            newChip = { type: value };
        }
        ev.target.value = "";
        ev.stopPropagation();
        if (!this._config) {
            return;
        }
        this._setMode(true);
        this._guiModeAvailable = true;
        this._config = Object.assign(Object.assign({}, this._config), { chip: newChip });
        fireEvent(this, "config-changed", { config: this._config });
    }
    _handleChipChanged(ev) {
        ev.stopPropagation();
        if (!this._config) {
            return;
        }
        this._config = Object.assign(Object.assign({}, this._config), { chip: ev.detail.config });
        this._guiModeAvailable = ev.detail.guiModeAvailable;
        fireEvent(this, "config-changed", { config: this._config });
    }
    _handleReplaceChip() {
        if (!this._config) {
            return;
        }
        // @ts-ignore
        this._config = Object.assign(Object.assign({}, this._config), { chip: undefined });
        // @ts-ignore
        fireEvent(this, "config-changed", { config: this._config });
    }
    _addCondition(ev) {
        const target = ev.target;
        if (target.value === "" || !this._config) {
            return;
        }
        const conditions = [...this._config.conditions];
        conditions.push({
            entity: target.value,
            state: "",
        });
        this._config = Object.assign(Object.assign({}, this._config), { conditions });
        target.value = "";
        fireEvent(this, "config-changed", { config: this._config });
    }
    _changeCondition(ev) {
        const target = ev.target;
        if (!this._config || !target) {
            return;
        }
        const conditions = [...this._config.conditions];
        if (target.configValue === "entity" && !target.value) {
            conditions.splice(target.idx, 1);
        }
        else {
            const condition = Object.assign({}, conditions[target.idx]);
            if (target.configValue === "entity") {
                condition.entity = target.value;
            }
            else if (target.configValue === "state") {
                if (condition.state_not !== undefined) {
                    condition.state_not = target.value;
                }
                else {
                    condition.state = target.value;
                }
            }
            else if (target.configValue === "invert") {
                if (target.value === "true") {
                    if (condition.state) {
                        condition.state_not = condition.state;
                        delete condition.state;
                    }
                }
                else if (condition.state_not) {
                    condition.state = condition.state_not;
                    delete condition.state_not;
                }
            }
            conditions[target.idx] = condition;
        }
        this._config = Object.assign(Object.assign({}, this._config), { conditions });
        fireEvent(this, "config-changed", { config: this._config });
    }
    static get styles() {
        return r$3 `
            mwc-tab-bar {
                border-bottom: 1px solid var(--divider-color);
            }
            .conditions {
                margin-top: 8px;
            }
            .condition {
                margin-top: 8px;
                border: 1px solid var(--divider-color);
                padding: 12px;
            }
            .condition .state {
                display: flex;
                align-items: flex-end;
            }
            .condition .state mushroom-select {
                margin-right: 16px;
            }
            .condition[rtl] .state mushroom-select {
                margin-right: initial;
                margin-left: 16px;
            }
            .card {
                margin-top: 8px;
                border: 1px solid var(--divider-color);
                padding: 12px;
            }
            .card mushroom-select {
                width: 100%;
                margin-top: 0px;
            }
            @media (max-width: 450px) {
                .card,
                .condition {
                    margin: 8px -12px 0;
                }
            }
            .card .card-options {
                display: flex;
                justify-content: flex-end;
                width: 100%;
            }
            .gui-mode-button {
                margin-right: auto;
            }
        `;
    }
};
__decorate([
    e$3({ attribute: false })
], ConditionalChipEditor.prototype, "hass", void 0);
__decorate([
    e$3({ attribute: false })
], ConditionalChipEditor.prototype, "lovelace", void 0);
__decorate([
    t$1()
], ConditionalChipEditor.prototype, "_config", void 0);
__decorate([
    t$1()
], ConditionalChipEditor.prototype, "_GUImode", void 0);
__decorate([
    t$1()
], ConditionalChipEditor.prototype, "_guiModeAvailable", void 0);
__decorate([
    t$1()
], ConditionalChipEditor.prototype, "_cardTab", void 0);
__decorate([
    i$4("mushroom-chip-element-editor")
], ConditionalChipEditor.prototype, "_cardEditorEl", void 0);
ConditionalChipEditor = __decorate([
    n$1(computeChipEditorComponentName("conditional"))
], ConditionalChipEditor);

var conditionalChipEditor = /*#__PURE__*/Object.freeze({
  __proto__: null,
  get ConditionalChipEditor () { return ConditionalChipEditor; }
});

const lightCardConfigStruct = assign(lovelaceCardConfigStruct, assign(entitySharedConfigStruct, appearanceSharedConfigStruct, actionsSharedConfigStruct), object({
    icon_color: optional(string()),
    show_brightness_control: optional(boolean()),
    show_color_temp_control: optional(boolean()),
    show_color_control: optional(boolean()),
    collapsible_controls: optional(boolean()),
    use_light_color: optional(boolean()),
}));

const LIGHT_LABELS = [
    "show_brightness_control",
    "use_light_color",
    "show_color_temp_control",
    "show_color_control",
];
const computeSchema$d = memoizeOne((icon) => [
    { name: "entity", selector: { entity: { domain: LIGHT_ENTITY_DOMAINS } } },
    { name: "name", selector: { text: {} } },
    {
        type: "grid",
        name: "",
        schema: [
            { name: "icon", selector: { icon: { placeholder: icon } } },
            { name: "icon_color", selector: { "mush-color": {} } },
        ],
    },
    ...APPEARANCE_FORM_SCHEMA,
    {
        type: "grid",
        name: "",
        schema: [
            { name: "use_light_color", selector: { boolean: {} } },
            { name: "show_brightness_control", selector: { boolean: {} } },
            { name: "show_color_temp_control", selector: { boolean: {} } },
            { name: "show_color_control", selector: { boolean: {} } },
            { name: "collapsible_controls", selector: { boolean: {} } },
        ],
    },
    ...computeActionsFormSchema(),
]);
let LightCardEditor = class LightCardEditor extends MushroomBaseElement {
    constructor() {
        super(...arguments);
        this._computeLabel = (schema) => {
            const customLocalize = setupCustomlocalize(this.hass);
            if (GENERIC_LABELS.includes(schema.name)) {
                return customLocalize(`editor.card.generic.${schema.name}`);
            }
            if (LIGHT_LABELS.includes(schema.name)) {
                return customLocalize(`editor.card.light.${schema.name}`);
            }
            return this.hass.localize(`ui.panel.lovelace.editor.card.generic.${schema.name}`);
        };
    }
    connectedCallback() {
        super.connectedCallback();
        void loadHaComponents();
    }
    setConfig(config) {
        assert(config, lightCardConfigStruct);
        this._config = config;
    }
    render() {
        if (!this.hass || !this._config) {
            return $ ``;
        }
        const entityState = this._config.entity ? this.hass.states[this._config.entity] : undefined;
        const entityIcon = entityState ? stateIcon(entityState) : undefined;
        const icon = this._config.icon || entityIcon;
        const schema = computeSchema$d(icon);
        return $ `
            <ha-form
                .hass=${this.hass}
                .data=${this._config}
                .schema=${schema}
                .computeLabel=${this._computeLabel}
                @value-changed=${this._valueChanged}
            ></ha-form>
        `;
    }
    _valueChanged(ev) {
        fireEvent(this, "config-changed", { config: ev.detail.value });
    }
};
__decorate([
    t$1()
], LightCardEditor.prototype, "_config", void 0);
LightCardEditor = __decorate([
    n$1(LIGHT_CARD_EDITOR_NAME)
], LightCardEditor);

var lightCardEditor = /*#__PURE__*/Object.freeze({
  __proto__: null,
  LIGHT_LABELS: LIGHT_LABELS,
  get LightCardEditor () { return LightCardEditor; }
});

const computeSchema$c = memoizeOne((icon) => [
    { name: "entity", selector: { entity: { domain: LIGHT_ENTITY_DOMAINS } } },
    {
        type: "grid",
        name: "",
        schema: [
            { name: "name", selector: { text: {} } },
            { name: "content_info", selector: { "mush-info": {} } },
        ],
    },
    {
        type: "grid",
        name: "",
        schema: [
            { name: "icon", selector: { icon: { placeholder: icon } } },
            { name: "use_light_color", selector: { boolean: {} } },
        ],
    },
    ...computeActionsFormSchema(),
]);
let LightChipEditor = class LightChipEditor extends s$1 {
    constructor() {
        super(...arguments);
        this._computeLabel = (schema) => {
            const customLocalize = setupCustomlocalize(this.hass);
            if (GENERIC_LABELS.includes(schema.name)) {
                return customLocalize(`editor.card.generic.${schema.name}`);
            }
            if (LIGHT_LABELS.includes(schema.name)) {
                return customLocalize(`editor.card.light.${schema.name}`);
            }
            return this.hass.localize(`ui.panel.lovelace.editor.card.generic.${schema.name}`);
        };
    }
    setConfig(config) {
        this._config = config;
    }
    render() {
        if (!this.hass || !this._config) {
            return $ ``;
        }
        const entityState = this._config.entity ? this.hass.states[this._config.entity] : undefined;
        const entityIcon = entityState ? stateIcon(entityState) : undefined;
        const icon = this._config.icon || entityIcon;
        const schema = computeSchema$c(icon);
        return $ `
            <ha-form
                .hass=${this.hass}
                .data=${this._config}
                .schema=${schema}
                .computeLabel=${this._computeLabel}
                @value-changed=${this._valueChanged}
            ></ha-form>
        `;
    }
    _valueChanged(ev) {
        fireEvent(this, "config-changed", { config: ev.detail.value });
    }
};
__decorate([
    e$3({ attribute: false })
], LightChipEditor.prototype, "hass", void 0);
__decorate([
    t$1()
], LightChipEditor.prototype, "_config", void 0);
LightChipEditor = __decorate([
    n$1(computeChipEditorComponentName("light"))
], LightChipEditor);

var lightChipEditor = /*#__PURE__*/Object.freeze({
  __proto__: null,
  get LightChipEditor () { return LightChipEditor; }
});

const actions$2 = ["more-info", "navigate", "url", "call-service", "none"];
const computeSchema$b = memoizeOne((icon) => [
    { name: "entity", selector: { entity: { domain: ALARM_CONTROl_PANEL_ENTITY_DOMAINS } } },
    {
        type: "grid",
        name: "",
        schema: [
            { name: "name", selector: { text: {} } },
            { name: "content_info", selector: { "mush-info": {} } },
        ],
    },
    { name: "icon", selector: { icon: { placeholder: icon } } },
    ...computeActionsFormSchema(actions$2),
]);
let AlarmControlPanelChipEditor = class AlarmControlPanelChipEditor extends s$1 {
    constructor() {
        super(...arguments);
        this._computeLabel = (schema) => {
            const customLocalize = setupCustomlocalize(this.hass);
            if (GENERIC_LABELS.includes(schema.name)) {
                return customLocalize(`editor.card.generic.${schema.name}`);
            }
            return this.hass.localize(`ui.panel.lovelace.editor.card.generic.${schema.name}`);
        };
    }
    setConfig(config) {
        this._config = config;
    }
    render() {
        if (!this.hass || !this._config) {
            return $ ``;
        }
        const entityState = this._config.entity ? this.hass.states[this._config.entity] : undefined;
        const entityIcon = entityState ? stateIcon(entityState) : undefined;
        const icon = this._config.icon || entityIcon;
        const schema = computeSchema$b(icon);
        return $ `
            <ha-form
                .hass=${this.hass}
                .data=${this._config}
                .schema=${schema}
                .computeLabel=${this._computeLabel}
                @value-changed=${this._valueChanged}
            ></ha-form>
        `;
    }
    _valueChanged(ev) {
        fireEvent(this, "config-changed", { config: ev.detail.value });
    }
};
__decorate([
    e$3({ attribute: false })
], AlarmControlPanelChipEditor.prototype, "hass", void 0);
__decorate([
    t$1()
], AlarmControlPanelChipEditor.prototype, "_config", void 0);
AlarmControlPanelChipEditor = __decorate([
    n$1(computeChipEditorComponentName("alarm-control-panel"))
], AlarmControlPanelChipEditor);

var alarmControlPanelChipEditor = /*#__PURE__*/Object.freeze({
  __proto__: null,
  get AlarmControlPanelChipEditor () { return AlarmControlPanelChipEditor; }
});

let MushroomSubElementEditor = class MushroomSubElementEditor extends s$1 {
    constructor() {
        super(...arguments);
        this._guiModeAvailable = true;
        this._guiMode = true;
    }
    render() {
        const customLocalize = setupCustomlocalize(this.hass);
        return $ `
            <div class="header">
                <div class="back-title">
                    <ha-icon-button
                        .label=${this.hass.localize("ui.common.back")}
                        @click=${this._goBack}
                    >
                        <ha-icon icon="mdi:arrow-left"></ha-icon>
                    </ha-icon-button>
                    <span slot="title"
                        >${customLocalize(`editor.chip.sub_element_editor.title`)}</span
                    >
                </div>
                <mwc-button
                    slot="secondaryAction"
                    .disabled=${!this._guiModeAvailable}
                    @click=${this._toggleMode}
                >
                    ${this.hass.localize(this._guiMode
            ? "ui.panel.lovelace.editor.edit_card.show_code_editor"
            : "ui.panel.lovelace.editor.edit_card.show_visual_editor")}
                </mwc-button>
            </div>
            ${this.config.type === "chip"
            ? $ `
                      <mushroom-chip-element-editor
                          class="editor"
                          .hass=${this.hass}
                          .value=${this.config.elementConfig}
                          @config-changed=${this._handleConfigChanged}
                          @GUImode-changed=${this._handleGUIModeChanged}
                      ></mushroom-chip-element-editor>
                  `
            : ""}
        `;
    }
    _goBack() {
        fireEvent(this, "go-back");
    }
    _toggleMode() {
        var _a;
        (_a = this._editorElement) === null || _a === void 0 ? void 0 : _a.toggleMode();
    }
    _handleGUIModeChanged(ev) {
        ev.stopPropagation();
        this._guiMode = ev.detail.guiMode;
        this._guiModeAvailable = ev.detail.guiModeAvailable;
    }
    _handleConfigChanged(ev) {
        this._guiModeAvailable = ev.detail.guiModeAvailable;
    }
    static get styles() {
        return r$3 `
            .header {
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
            .back-title {
                display: flex;
                align-items: center;
                font-size: 18px;
            }
            ha-icon {
                display: flex;
                align-items: center;
                justify-content: center;
            }
        `;
    }
};
__decorate([
    e$3({ attribute: false })
], MushroomSubElementEditor.prototype, "config", void 0);
__decorate([
    t$1()
], MushroomSubElementEditor.prototype, "_guiModeAvailable", void 0);
__decorate([
    t$1()
], MushroomSubElementEditor.prototype, "_guiMode", void 0);
__decorate([
    i$4(".editor")
], MushroomSubElementEditor.prototype, "_editorElement", void 0);
MushroomSubElementEditor = __decorate([
    n$1("mushroom-sub-element-editor")
], MushroomSubElementEditor);

/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const e={},i=e$1(class extends i$3{constructor(){super(...arguments),this.nt=e;}render(r,t){return t()}update(t,[s,e]){if(Array.isArray(s)){if(Array.isArray(this.nt)&&this.nt.length===s.length&&s.every(((r,t)=>r===this.nt[t])))return b}else if(this.nt===s)return b;return this.nt=Array.isArray(s)?Array.from(s):s,this.render(s,e)}});

let Sortable$1;
let ChipsCardEditorChips = class ChipsCardEditorChips extends MushroomBaseElement {
    constructor() {
        super(...arguments);
        this._attached = false;
        this._renderEmptySortable = false;
    }
    connectedCallback() {
        super.connectedCallback();
        this._attached = true;
    }
    disconnectedCallback() {
        super.disconnectedCallback();
        this._attached = false;
    }
    render() {
        if (!this.chips || !this.hass) {
            return $ ``;
        }
        const customLocalize = setupCustomlocalize(this.hass);
        return $ `
            <h3>
                ${this.label ||
            `${customLocalize("editor.chip.chip-picker.chips")} (${this.hass.localize("ui.panel.lovelace.editor.card.config.required")})`}
            </h3>
            <div class="chips">
                ${i([this.chips, this._renderEmptySortable], () => this._renderEmptySortable
            ? ""
            : this.chips.map((chipConf, index) => $ `
                                  <div class="chip">
                                      <div class="handle">
                                          <ha-icon icon="mdi:drag"></ha-icon>
                                      </div>
                                      ${$ `
                                          <div class="special-row">
                                              <div>
                                                  <span> ${this._renderChipLabel(chipConf)}</span>
                                                  <span class="secondary"
                                                      >${this._renderChipSecondary(chipConf)}</span
                                                  >
                                              </div>
                                          </div>
                                      `}
                                      <ha-icon-button
                                          .label=${customLocalize("editor.chip.chip-picker.clear")}
                                          class="remove-icon"
                                          .index=${index}
                                          @click=${this._removeChip}
                                      >
                                          <ha-icon icon="mdi:close"></ha-icon
                                      ></ha-icon-button>
                                      <ha-icon-button
                                          .label=${customLocalize("editor.chip.chip-picker.edit")}
                                          class="edit-icon"
                                          .index=${index}
                                          @click=${this._editChip}
                                      >
                                          <ha-icon icon="mdi:pencil"></ha-icon>
                                      </ha-icon-button>
                                  </div>
                              `))}
            </div>
            <mushroom-select
                .label=${customLocalize("editor.chip.chip-picker.add")}
                @selected=${this._addChips}
                @closed=${(e) => e.stopPropagation()}
                fixedMenuPosition
                naturalMenuWidth
            >
                ${CHIP_LIST.map((chip) => $ `
                            <mwc-list-item .value=${chip}>
                                ${customLocalize(`editor.chip.chip-picker.types.${chip}`)}
                            </mwc-list-item>
                        `)}
            </mushroom-select>
        `;
    }
    updated(changedProps) {
        var _a;
        super.updated(changedProps);
        const attachedChanged = changedProps.has("_attached");
        const chipsChanged = changedProps.has("chips");
        if (!chipsChanged && !attachedChanged) {
            return;
        }
        if (attachedChanged && !this._attached) {
            // Tear down sortable, if available
            (_a = this._sortable) === null || _a === void 0 ? void 0 : _a.destroy();
            this._sortable = undefined;
            return;
        }
        if (!this._sortable && this.chips) {
            this._createSortable();
            return;
        }
        if (chipsChanged) {
            this._handleChipsChanged();
        }
    }
    async _handleChipsChanged() {
        this._renderEmptySortable = true;
        await this.updateComplete;
        const container = this.shadowRoot.querySelector(".chips");
        while (container.lastElementChild) {
            container.removeChild(container.lastElementChild);
        }
        this._renderEmptySortable = false;
    }
    async _createSortable() {
        if (!Sortable$1) {
            const sortableImport = await Promise.resolve().then(function () { return sortable_core_esm; });
            Sortable$1 = sortableImport.Sortable;
            Sortable$1.mount(sortableImport.OnSpill);
            Sortable$1.mount(sortableImport.AutoScroll());
        }
        this._sortable = new Sortable$1(this.shadowRoot.querySelector(".chips"), {
            animation: 150,
            fallbackClass: "sortable-fallback",
            handle: ".handle",
            onEnd: async (evt) => this._chipMoved(evt),
        });
    }
    async _addChips(ev) {
        const target = ev.target;
        const value = target.value;
        if (value === "") {
            return;
        }
        let newChip;
        // Check if a stub config exists
        const elClass = getChipElementClass(value);
        if (elClass && elClass.getStubConfig) {
            newChip = (await elClass.getStubConfig(this.hass));
        }
        else {
            newChip = { type: value };
        }
        const newConfigChips = this.chips.concat(newChip);
        target.value = "";
        fireEvent(this, "chips-changed", {
            chips: newConfigChips,
        });
    }
    _chipMoved(ev) {
        if (ev.oldIndex === ev.newIndex) {
            return;
        }
        const newChips = this.chips.concat();
        newChips.splice(ev.newIndex, 0, newChips.splice(ev.oldIndex, 1)[0]);
        fireEvent(this, "chips-changed", { chips: newChips });
    }
    _removeChip(ev) {
        const index = ev.currentTarget.index;
        const newConfigChips = this.chips.concat();
        newConfigChips.splice(index, 1);
        fireEvent(this, "chips-changed", {
            chips: newConfigChips,
        });
    }
    _editChip(ev) {
        const index = ev.currentTarget.index;
        fireEvent(this, "edit-detail-element", {
            subElementConfig: {
                index,
                type: "chip",
                elementConfig: this.chips[index],
            },
        });
    }
    _renderChipLabel(chipConf) {
        var _a;
        const customLocalize = setupCustomlocalize(this.hass);
        let label = customLocalize(`editor.chip.chip-picker.types.${chipConf.type}`);
        if (chipConf.type === "conditional" && chipConf.conditions.length > 0) {
            const condition = chipConf.conditions[0];
            const entity = (_a = this.getEntityName(condition.entity)) !== null && _a !== void 0 ? _a : condition.entity;
            label += ` - ${entity} ${condition.state
                ? `= ${condition.state}`
                : condition.state_not
                    ? `≠ ${condition.state_not}`
                    : null}`;
        }
        return label;
    }
    _renderChipSecondary(chipConf) {
        var _a;
        const customLocalize = setupCustomlocalize(this.hass);
        if ("entity" in chipConf && chipConf.entity) {
            return `${(_a = this.getEntityName(chipConf.entity)) !== null && _a !== void 0 ? _a : chipConf.entity}`;
        }
        if ("chip" in chipConf && chipConf.chip) {
            const label = customLocalize(`editor.chip.chip-picker.types.${chipConf.chip.type}`);
            return `${this._renderChipSecondary(chipConf.chip)} (via ${label})`;
        }
        return undefined;
    }
    getEntityName(entity_id) {
        if (!this.hass)
            return undefined;
        const entity = this.hass.states[entity_id];
        if (!entity)
            return undefined;
        return entity.attributes.friendly_name;
    }
    static get styles() {
        return [
            super.styles,
            sortableStyles,
            r$3 `
                .chip {
                    display: flex;
                    align-items: center;
                }

                ha-icon {
                    display: flex;
                }

                mushroom-select {
                    width: 100%;
                }

                .chip .handle {
                    padding-right: 8px;
                    cursor: move;
                }

                .chip .handle > * {
                    pointer-events: none;
                }

                .special-row {
                    height: 60px;
                    font-size: 16px;
                    display: flex;
                    align-items: center;
                    justify-content: space-between;
                    flex-grow: 1;
                }

                .special-row div {
                    display: flex;
                    flex-direction: column;
                }

                .remove-icon,
                .edit-icon {
                    --mdc-icon-button-size: 36px;
                    color: var(--secondary-text-color);
                }

                .secondary {
                    font-size: 12px;
                    color: var(--secondary-text-color);
                }
            `,
        ];
    }
};
__decorate([
    e$3({ attribute: false })
], ChipsCardEditorChips.prototype, "chips", void 0);
__decorate([
    e$3()
], ChipsCardEditorChips.prototype, "label", void 0);
__decorate([
    t$1()
], ChipsCardEditorChips.prototype, "_attached", void 0);
__decorate([
    t$1()
], ChipsCardEditorChips.prototype, "_renderEmptySortable", void 0);
ChipsCardEditorChips = __decorate([
    n$1("mushroom-chips-card-chips-editor")
], ChipsCardEditorChips);

const actionChipConfigStruct = object({
    type: literal("action"),
    icon: optional(string()),
    icon_color: optional(string()),
    tap_action: optional(actionConfigStruct),
    hold_action: optional(actionConfigStruct),
    double_tap_action: optional(actionConfigStruct),
});
const backChipConfigStruct = object({
    type: literal("back"),
    icon: optional(string()),
    icon_color: optional(string()),
});
const entityChipConfigStruct = object({
    type: literal("entity"),
    entity: optional(string()),
    name: optional(string()),
    content_info: optional(string()),
    icon: optional(string()),
    icon_color: optional(string()),
    use_entity_picture: optional(boolean()),
    tap_action: optional(actionConfigStruct),
    hold_action: optional(actionConfigStruct),
    double_tap_action: optional(actionConfigStruct),
});
const menuChipConfigStruct = object({
    type: literal("menu"),
    icon: optional(string()),
    icon_color: optional(string()),
});
const weatherChipConfigStruct = object({
    type: literal("weather"),
    entity: optional(string()),
    tap_action: optional(actionConfigStruct),
    hold_action: optional(actionConfigStruct),
    double_tap_action: optional(actionConfigStruct),
    show_temperature: optional(boolean()),
    show_conditions: optional(boolean()),
});
const conditionStruct = object({
    entity: string(),
    state: optional(string()),
    state_not: optional(string()),
});
const conditionChipConfigStruct = object({
    type: literal("conditional"),
    chip: optional(any()),
    conditions: optional(array(conditionStruct)),
});
const lightChipConfigStruct = object({
    type: literal("light"),
    entity: optional(string()),
    name: optional(string()),
    content_info: optional(string()),
    icon: optional(string()),
    use_light_color: optional(boolean()),
    tap_action: optional(actionConfigStruct),
    hold_action: optional(actionConfigStruct),
    double_tap_action: optional(actionConfigStruct),
});
const templateChipConfigStruct = object({
    type: literal("template"),
    entity: optional(string()),
    tap_action: optional(actionConfigStruct),
    hold_action: optional(actionConfigStruct),
    double_tap_action: optional(actionConfigStruct),
    content: optional(string()),
    icon: optional(string()),
    icon_color: optional(string()),
    picture: optional(string()),
    entity_id: optional(union([string(), array(string())])),
});
const chipsConfigStruct = dynamic((value) => {
    if (value && typeof value === "object" && "type" in value) {
        switch (value.type) {
            case "action":
                return actionChipConfigStruct;
            case "back":
                return backChipConfigStruct;
            case "entity":
                return entityChipConfigStruct;
            case "menu":
                return menuChipConfigStruct;
            case "weather":
                return weatherChipConfigStruct;
            case "conditional":
                return conditionChipConfigStruct;
            case "light":
                return lightChipConfigStruct;
            case "template":
                return templateChipConfigStruct;
        }
    }
    return object();
});
const cardConfigStruct = assign(lovelaceCardConfigStruct, object({
    chips: array(chipsConfigStruct),
    alignment: optional(string()),
}));
let ChipsCardEditor = class ChipsCardEditor extends MushroomBaseElement {
    connectedCallback() {
        super.connectedCallback();
        void loadHaComponents();
    }
    setConfig(config) {
        assert(config, cardConfigStruct);
        this._config = config;
    }
    get _title() {
        return this._config.title || "";
    }
    get _theme() {
        return this._config.theme || "";
    }
    render() {
        if (!this.hass || !this._config) {
            return $ ``;
        }
        if (this._subElementEditorConfig) {
            return $ `
                <mushroom-sub-element-editor
                    .hass=${this.hass}
                    .config=${this._subElementEditorConfig}
                    @go-back=${this._goBack}
                    @config-changed=${this._handleSubElementChanged}
                >
                </mushroom-sub-element-editor>
            `;
        }
        const customLocalize = setupCustomlocalize(this.hass);
        return $ `
            <div class="card-config">
                <mushroom-alignment-picker
                    .label="${customLocalize("editor.card.chips.alignment")} (${this.hass.localize("ui.panel.lovelace.editor.card.config.optional")})"
                    .hass=${this.hass}
                    .value=${this._config.alignment}
                    .configValue=${"alignment"}
                    @value-changed=${this._valueChanged}
                >
                </mushroom-alignment-picker>
            </div>
            <mushroom-chips-card-chips-editor
                .hass=${this.hass}
                .chips=${this._config.chips}
                @chips-changed=${this._valueChanged}
                @edit-detail-element=${this._editDetailElement}
            ></mushroom-chips-card-chips-editor>
        `;
    }
    _valueChanged(ev) {
        var _a, _b, _c;
        if (!this._config || !this.hass) {
            return;
        }
        const target = ev.target;
        const configValue = target.configValue || ((_a = this._subElementEditorConfig) === null || _a === void 0 ? void 0 : _a.type);
        const value = (_c = (_b = target.checked) !== null && _b !== void 0 ? _b : ev.detail.value) !== null && _c !== void 0 ? _c : target.value;
        if (configValue === "chip" || (ev.detail && ev.detail.chips)) {
            const newConfigChips = ev.detail.chips || this._config.chips.concat();
            if (configValue === "chip") {
                if (!value) {
                    newConfigChips.splice(this._subElementEditorConfig.index, 1);
                    this._goBack();
                }
                else {
                    newConfigChips[this._subElementEditorConfig.index] = value;
                }
                this._subElementEditorConfig.elementConfig = value;
            }
            this._config = Object.assign(Object.assign({}, this._config), { chips: newConfigChips });
        }
        else if (configValue) {
            if (!value) {
                this._config = Object.assign({}, this._config);
                delete this._config[configValue];
            }
            else {
                this._config = Object.assign(Object.assign({}, this._config), { [configValue]: value });
            }
        }
        fireEvent(this, "config-changed", { config: this._config });
    }
    _handleSubElementChanged(ev) {
        var _a;
        ev.stopPropagation();
        if (!this._config || !this.hass) {
            return;
        }
        const configValue = (_a = this._subElementEditorConfig) === null || _a === void 0 ? void 0 : _a.type;
        const value = ev.detail.config;
        if (configValue === "chip") {
            const newConfigChips = this._config.chips.concat();
            if (!value) {
                newConfigChips.splice(this._subElementEditorConfig.index, 1);
                this._goBack();
            }
            else {
                newConfigChips[this._subElementEditorConfig.index] = value;
            }
            this._config = Object.assign(Object.assign({}, this._config), { chips: newConfigChips });
        }
        else if (configValue) {
            if (value === "") {
                this._config = Object.assign({}, this._config);
                delete this._config[configValue];
            }
            else {
                this._config = Object.assign(Object.assign({}, this._config), { [configValue]: value });
            }
        }
        this._subElementEditorConfig = Object.assign(Object.assign({}, this._subElementEditorConfig), { elementConfig: value });
        fireEvent(this, "config-changed", { config: this._config });
    }
    _editDetailElement(ev) {
        this._subElementEditorConfig = ev.detail.subElementConfig;
    }
    _goBack() {
        this._subElementEditorConfig = undefined;
    }
};
__decorate([
    t$1()
], ChipsCardEditor.prototype, "_config", void 0);
__decorate([
    t$1()
], ChipsCardEditor.prototype, "_subElementEditorConfig", void 0);
ChipsCardEditor = __decorate([
    n$1(CHIPS_CARD_EDITOR_NAME)
], ChipsCardEditor);

var chipsCardEditor = /*#__PURE__*/Object.freeze({
  __proto__: null,
  get ChipsCardEditor () { return ChipsCardEditor; }
});

const HVAC_MODES = [
    "auto",
    "heat_cool",
    "heat",
    "cool",
    "dry",
    "fan_only",
    "off",
];
const climateCardConfigStruct = assign(lovelaceCardConfigStruct, assign(entitySharedConfigStruct, appearanceSharedConfigStruct, actionsSharedConfigStruct), object({
    show_temperature_control: optional(boolean()),
    hvac_modes: optional(array(string())),
    collapsible_controls: optional(boolean()),
}));

const CLIMATE_LABELS = ["hvac_modes", "show_temperature_control"];
const computeSchema$a = memoizeOne((localize, icon) => [
    { name: "entity", selector: { entity: { domain: CLIMATE_ENTITY_DOMAINS } } },
    { name: "name", selector: { text: {} } },
    { name: "icon", selector: { icon: { placeholder: icon } } },
    ...APPEARANCE_FORM_SCHEMA,
    {
        type: "grid",
        name: "",
        schema: [
            {
                name: "hvac_modes",
                selector: {
                    select: {
                        options: HVAC_MODES.map((mode) => ({
                            value: mode,
                            label: localize(`component.climate.state._.${mode}`),
                        })),
                        mode: "dropdown",
                        multiple: true,
                    },
                },
            },
            { name: "show_temperature_control", selector: { boolean: {} } },
            { name: "collapsible_controls", selector: { boolean: {} } },
        ],
    },
    ...computeActionsFormSchema(),
]);
let ClimateCardEditor = class ClimateCardEditor extends MushroomBaseElement {
    constructor() {
        super(...arguments);
        this._computeLabel = (schema) => {
            const customLocalize = setupCustomlocalize(this.hass);
            if (GENERIC_LABELS.includes(schema.name)) {
                return customLocalize(`editor.card.generic.${schema.name}`);
            }
            if (CLIMATE_LABELS.includes(schema.name)) {
                return customLocalize(`editor.card.climate.${schema.name}`);
            }
            return this.hass.localize(`ui.panel.lovelace.editor.card.generic.${schema.name}`);
        };
    }
    connectedCallback() {
        super.connectedCallback();
        void loadHaComponents();
    }
    setConfig(config) {
        assert(config, climateCardConfigStruct);
        this._config = config;
    }
    render() {
        if (!this.hass || !this._config) {
            return $ ``;
        }
        const entityState = this._config.entity ? this.hass.states[this._config.entity] : undefined;
        const entityIcon = entityState ? stateIcon(entityState) : undefined;
        const icon = this._config.icon || entityIcon;
        const schema = computeSchema$a(this.hass.localize, icon);
        return $ `
            <ha-form
                .hass=${this.hass}
                .data=${this._config}
                .schema=${schema}
                .computeLabel=${this._computeLabel}
                @value-changed=${this._valueChanged}
            ></ha-form>
        `;
    }
    _valueChanged(ev) {
        fireEvent(this, "config-changed", { config: ev.detail.value });
    }
};
__decorate([
    t$1()
], ClimateCardEditor.prototype, "_config", void 0);
ClimateCardEditor = __decorate([
    n$1(CLIMATE_CARD_EDITOR_NAME)
], ClimateCardEditor);

var climateCardEditor = /*#__PURE__*/Object.freeze({
  __proto__: null,
  get ClimateCardEditor () { return ClimateCardEditor; }
});

const coverCardConfigStruct = assign(lovelaceCardConfigStruct, assign(entitySharedConfigStruct, appearanceSharedConfigStruct, actionsSharedConfigStruct), object({
    show_buttons_control: optional(boolean()),
    show_position_control: optional(boolean()),
    show_tilt_position_control: optional(boolean()),
}));

const COVER_LABELS = [
    "show_buttons_control",
    "show_position_control",
    "show_tilt_position_control",
];
const computeSchema$9 = memoizeOne((icon) => [
    { name: "entity", selector: { entity: { domain: COVER_ENTITY_DOMAINS } } },
    { name: "name", selector: { text: {} } },
    { name: "icon", selector: { icon: { placeholder: icon } } },
    ...APPEARANCE_FORM_SCHEMA,
    {
        type: "grid",
        name: "",
        schema: [
            { name: "show_position_control", selector: { boolean: {} } },
            { name: "show_tilt_position_control", selector: { boolean: {} } },
            { name: "show_buttons_control", selector: { boolean: {} } },
        ],
    },
    ...computeActionsFormSchema(),
]);
let CoverCardEditor = class CoverCardEditor extends MushroomBaseElement {
    constructor() {
        super(...arguments);
        this._computeLabel = (schema) => {
            const customLocalize = setupCustomlocalize(this.hass);
            if (GENERIC_LABELS.includes(schema.name)) {
                return customLocalize(`editor.card.generic.${schema.name}`);
            }
            if (COVER_LABELS.includes(schema.name)) {
                return customLocalize(`editor.card.cover.${schema.name}`);
            }
            return this.hass.localize(`ui.panel.lovelace.editor.card.generic.${schema.name}`);
        };
    }
    connectedCallback() {
        super.connectedCallback();
        void loadHaComponents();
    }
    setConfig(config) {
        assert(config, coverCardConfigStruct);
        this._config = config;
    }
    render() {
        if (!this.hass || !this._config) {
            return $ ``;
        }
        const entityState = this._config.entity ? this.hass.states[this._config.entity] : undefined;
        const entityIcon = entityState ? stateIcon(entityState) : undefined;
        const icon = this._config.icon || entityIcon;
        const schema = computeSchema$9(icon);
        return $ `
            <ha-form
                .hass=${this.hass}
                .data=${this._config}
                .schema=${schema}
                .computeLabel=${this._computeLabel}
                @value-changed=${this._valueChanged}
            ></ha-form>
        `;
    }
    _valueChanged(ev) {
        fireEvent(this, "config-changed", { config: ev.detail.value });
    }
};
__decorate([
    t$1()
], CoverCardEditor.prototype, "_config", void 0);
CoverCardEditor = __decorate([
    n$1(COVER_CARD_EDITOR_NAME)
], CoverCardEditor);

var coverCardEditor = /*#__PURE__*/Object.freeze({
  __proto__: null,
  get CoverCardEditor () { return CoverCardEditor; }
});

const entityCardConfigStruct = assign(lovelaceCardConfigStruct, assign(entitySharedConfigStruct, appearanceSharedConfigStruct, actionsSharedConfigStruct), object({
    icon_color: optional(string()),
}));

const computeSchema$8 = memoizeOne((icon) => [
    { name: "entity", selector: { entity: {} } },
    { name: "name", selector: { text: {} } },
    {
        type: "grid",
        name: "",
        schema: [
            { name: "icon", selector: { icon: { placeholder: icon } } },
            { name: "icon_color", selector: { "mush-color": {} } },
        ],
    },
    ...APPEARANCE_FORM_SCHEMA,
    ...computeActionsFormSchema(),
]);
let EntityCardEditor = class EntityCardEditor extends MushroomBaseElement {
    constructor() {
        super(...arguments);
        this._computeLabel = (schema) => {
            const customLocalize = setupCustomlocalize(this.hass);
            if (GENERIC_LABELS.includes(schema.name)) {
                return customLocalize(`editor.card.generic.${schema.name}`);
            }
            return this.hass.localize(`ui.panel.lovelace.editor.card.generic.${schema.name}`);
        };
    }
    connectedCallback() {
        super.connectedCallback();
        void loadHaComponents();
    }
    setConfig(config) {
        assert(config, entityCardConfigStruct);
        this._config = config;
    }
    render() {
        if (!this.hass || !this._config) {
            return $ ``;
        }
        const entityState = this._config.entity ? this.hass.states[this._config.entity] : undefined;
        const entityIcon = entityState ? stateIcon(entityState) : undefined;
        const icon = this._config.icon || entityIcon;
        const schema = computeSchema$8(icon);
        return $ `
            <ha-form
                .hass=${this.hass}
                .data=${this._config}
                .schema=${schema}
                .computeLabel=${this._computeLabel}
                @value-changed=${this._valueChanged}
            ></ha-form>
        `;
    }
    _valueChanged(ev) {
        fireEvent(this, "config-changed", { config: ev.detail.value });
    }
};
__decorate([
    t$1()
], EntityCardEditor.prototype, "_config", void 0);
EntityCardEditor = __decorate([
    n$1(ENTITY_CARD_EDITOR_NAME)
], EntityCardEditor);

var entityCardEditor = /*#__PURE__*/Object.freeze({
  __proto__: null,
  get EntityCardEditor () { return EntityCardEditor; }
});

const fanCardConfigStruct = assign(lovelaceCardConfigStruct, assign(entitySharedConfigStruct, appearanceSharedConfigStruct, actionsSharedConfigStruct), object({
    icon_animation: optional(boolean()),
    show_percentage_control: optional(boolean()),
    show_oscillate_control: optional(boolean()),
    collapsible_controls: optional(boolean()),
}));

const FAN_LABELS = ["icon_animation", "show_percentage_control", "show_oscillate_control"];
const computeSchema$7 = memoizeOne((icon) => [
    { name: "entity", selector: { entity: { domain: FAN_ENTITY_DOMAINS } } },
    { name: "name", selector: { text: {} } },
    {
        type: "grid",
        name: "",
        schema: [
            { name: "icon", selector: { icon: { placeholder: icon } } },
            { name: "icon_animation", selector: { boolean: {} } },
        ],
    },
    ...APPEARANCE_FORM_SCHEMA,
    {
        type: "grid",
        name: "",
        schema: [
            { name: "show_percentage_control", selector: { boolean: {} } },
            { name: "show_oscillate_control", selector: { boolean: {} } },
            { name: "collapsible_controls", selector: { boolean: {} } },
        ],
    },
    ...computeActionsFormSchema(),
]);
let FanCardEditor = class FanCardEditor extends MushroomBaseElement {
    constructor() {
        super(...arguments);
        this._computeLabel = (schema) => {
            const customLocalize = setupCustomlocalize(this.hass);
            if (GENERIC_LABELS.includes(schema.name)) {
                return customLocalize(`editor.card.generic.${schema.name}`);
            }
            if (FAN_LABELS.includes(schema.name)) {
                return customLocalize(`editor.card.fan.${schema.name}`);
            }
            return this.hass.localize(`ui.panel.lovelace.editor.card.generic.${schema.name}`);
        };
    }
    connectedCallback() {
        super.connectedCallback();
        void loadHaComponents();
    }
    setConfig(config) {
        assert(config, fanCardConfigStruct);
        this._config = config;
    }
    render() {
        if (!this.hass || !this._config) {
            return $ ``;
        }
        const entityState = this._config.entity ? this.hass.states[this._config.entity] : undefined;
        const entityIcon = entityState ? stateIcon(entityState) : undefined;
        const icon = this._config.icon || entityIcon;
        const schema = computeSchema$7(icon);
        return $ `
            <ha-form
                .hass=${this.hass}
                .data=${this._config}
                .schema=${schema}
                .computeLabel=${this._computeLabel}
                @value-changed=${this._valueChanged}
            ></ha-form>
        `;
    }
    _valueChanged(ev) {
        fireEvent(this, "config-changed", { config: ev.detail.value });
    }
};
__decorate([
    t$1()
], FanCardEditor.prototype, "_config", void 0);
FanCardEditor = __decorate([
    n$1(FAN_CARD_EDITOR_NAME)
], FanCardEditor);

var fanCardEditor = /*#__PURE__*/Object.freeze({
  __proto__: null,
  get FanCardEditor () { return FanCardEditor; }
});

const humidifierCardConfigStruct = assign(lovelaceCardConfigStruct, assign(entitySharedConfigStruct, appearanceSharedConfigStruct, actionsSharedConfigStruct), object({
    show_target_humidity_control: optional(boolean()),
    collapsible_controls: optional(boolean()),
}));

const HUMIDIFIER_FIELDS = ["show_target_humidity_control"];
const computeSchema$6 = memoizeOne((icon) => [
    { name: "entity", selector: { entity: { domain: HUMIDIFIER_ENTITY_DOMAINS } } },
    { name: "name", selector: { text: {} } },
    { name: "icon", selector: { icon: { placeholder: icon } } },
    ...APPEARANCE_FORM_SCHEMA,
    {
        type: "grid",
        name: "",
        schema: [
            { name: "show_target_humidity_control", selector: { boolean: {} } },
            { name: "collapsible_controls", selector: { boolean: {} } },
        ],
    },
    ...computeActionsFormSchema(),
]);
let HumidifierCardEditor = class HumidifierCardEditor extends MushroomBaseElement {
    constructor() {
        super(...arguments);
        this._computeLabel = (schema) => {
            const customLocalize = setupCustomlocalize(this.hass);
            if (GENERIC_LABELS.includes(schema.name)) {
                return customLocalize(`editor.card.generic.${schema.name}`);
            }
            if (HUMIDIFIER_FIELDS.includes(schema.name)) {
                return customLocalize(`editor.card.humidifier.${schema.name}`);
            }
            return this.hass.localize(`ui.panel.lovelace.editor.card.generic.${schema.name}`);
        };
    }
    connectedCallback() {
        super.connectedCallback();
        void loadHaComponents();
    }
    setConfig(config) {
        assert(config, humidifierCardConfigStruct);
        this._config = config;
    }
    render() {
        if (!this.hass || !this._config) {
            return $ ``;
        }
        const entityState = this._config.entity ? this.hass.states[this._config.entity] : undefined;
        const entityIcon = entityState ? stateIcon(entityState) : undefined;
        const icon = this._config.icon || entityIcon;
        const schema = computeSchema$6(icon);
        return $ `
            <ha-form
                .hass=${this.hass}
                .data=${this._config}
                .schema=${schema}
                .computeLabel=${this._computeLabel}
                @value-changed=${this._valueChanged}
            ></ha-form>
        `;
    }
    _valueChanged(ev) {
        fireEvent(this, "config-changed", { config: ev.detail.value });
    }
};
__decorate([
    t$1()
], HumidifierCardEditor.prototype, "_config", void 0);
HumidifierCardEditor = __decorate([
    n$1(HUMIDIFIER_CARD_EDITOR_NAME)
], HumidifierCardEditor);

var humidifierCardEditor = /*#__PURE__*/Object.freeze({
  __proto__: null,
  get HumidifierCardEditor () { return HumidifierCardEditor; }
});

const lockCardConfigStruct = assign(lovelaceCardConfigStruct, assign(entitySharedConfigStruct, appearanceSharedConfigStruct, actionsSharedConfigStruct));

const computeSchema$5 = memoizeOne((icon) => [
    { name: "entity", selector: { entity: { domain: LOCK_ENTITY_DOMAINS } } },
    { name: "name", selector: { text: {} } },
    { name: "icon", selector: { icon: { placeholder: icon } } },
    ...APPEARANCE_FORM_SCHEMA,
    ...computeActionsFormSchema(),
]);
let LockCardEditor = class LockCardEditor extends MushroomBaseElement {
    constructor() {
        super(...arguments);
        this._computeLabel = (schema) => {
            const customLocalize = setupCustomlocalize(this.hass);
            if (GENERIC_LABELS.includes(schema.name)) {
                return customLocalize(`editor.card.generic.${schema.name}`);
            }
            return this.hass.localize(`ui.panel.lovelace.editor.card.generic.${schema.name}`);
        };
    }
    connectedCallback() {
        super.connectedCallback();
        void loadHaComponents();
    }
    setConfig(config) {
        assert(config, lockCardConfigStruct);
        this._config = config;
    }
    render() {
        if (!this.hass || !this._config) {
            return $ ``;
        }
        const entityState = this._config.entity ? this.hass.states[this._config.entity] : undefined;
        const entityIcon = entityState ? stateIcon(entityState) : undefined;
        const icon = this._config.icon || entityIcon;
        const schema = computeSchema$5(icon);
        return $ `
            <ha-form
                .hass=${this.hass}
                .data=${this._config}
                .schema=${schema}
                .computeLabel=${this._computeLabel}
                @value-changed=${this._valueChanged}
            ></ha-form>
        `;
    }
    _valueChanged(ev) {
        fireEvent(this, "config-changed", { config: ev.detail.value });
    }
};
__decorate([
    t$1()
], LockCardEditor.prototype, "_config", void 0);
LockCardEditor = __decorate([
    n$1(LOCK_CARD_EDITOR_NAME)
], LockCardEditor);

var lockCardEditor = /*#__PURE__*/Object.freeze({
  __proto__: null,
  get LockCardEditor () { return LockCardEditor; }
});

const MEDIA_LAYER_MEDIA_CONTROLS = [
    "on_off",
    "shuffle",
    "previous",
    "play_pause_stop",
    "next",
    "repeat",
];
const MEDIA_PLAYER_VOLUME_CONTROLS = [
    "volume_mute",
    "volume_set",
    "volume_buttons",
];
const mediaPlayerCardConfigStruct = assign(lovelaceCardConfigStruct, assign(entitySharedConfigStruct, appearanceSharedConfigStruct, actionsSharedConfigStruct), object({
    use_media_info: optional(boolean()),
    show_volume_level: optional(boolean()),
    volume_controls: optional(array(enums(MEDIA_PLAYER_VOLUME_CONTROLS))),
    media_controls: optional(array(enums(MEDIA_LAYER_MEDIA_CONTROLS))),
    collapsible_controls: optional(boolean()),
}));

const MEDIA_LABELS = [
    "use_media_info",
    "use_media_artwork",
    "show_volume_level",
    "media_controls",
    "volume_controls",
];
const computeSchema$4 = memoizeOne((localize, icon) => [
    { name: "entity", selector: { entity: { domain: MEDIA_PLAYER_ENTITY_DOMAINS } } },
    { name: "name", selector: { text: {} } },
    { name: "icon", selector: { icon: { placeholder: icon } } },
    ...APPEARANCE_FORM_SCHEMA,
    {
        type: "grid",
        name: "",
        schema: [
            { name: "use_media_info", selector: { boolean: {} } },
            { name: "show_volume_level", selector: { boolean: {} } },
        ],
    },
    {
        type: "grid",
        name: "",
        schema: [
            {
                name: "volume_controls",
                selector: {
                    select: {
                        options: MEDIA_PLAYER_VOLUME_CONTROLS.map((control) => ({
                            value: control,
                            label: localize(`editor.card.media-player.volume_controls_list.${control}`),
                        })),
                        mode: "list",
                        multiple: true,
                    },
                },
            },
            {
                name: "media_controls",
                selector: {
                    select: {
                        options: MEDIA_LAYER_MEDIA_CONTROLS.map((control) => ({
                            value: control,
                            label: localize(`editor.card.media-player.media_controls_list.${control}`),
                        })),
                        mode: "list",
                        multiple: true,
                    },
                },
            },
            { name: "collapsible_controls", selector: { boolean: {} } },
        ],
    },
    ...computeActionsFormSchema(),
]);
let MediaCardEditor = class MediaCardEditor extends MushroomBaseElement {
    constructor() {
        super(...arguments);
        this._computeLabel = (schema) => {
            const customLocalize = setupCustomlocalize(this.hass);
            if (GENERIC_LABELS.includes(schema.name)) {
                return customLocalize(`editor.card.generic.${schema.name}`);
            }
            if (MEDIA_LABELS.includes(schema.name)) {
                return customLocalize(`editor.card.media-player.${schema.name}`);
            }
            return this.hass.localize(`ui.panel.lovelace.editor.card.generic.${schema.name}`);
        };
    }
    connectedCallback() {
        super.connectedCallback();
        void loadHaComponents();
    }
    setConfig(config) {
        assert(config, mediaPlayerCardConfigStruct);
        this._config = config;
    }
    render() {
        if (!this.hass || !this._config) {
            return $ ``;
        }
        const entityState = this._config.entity ? this.hass.states[this._config.entity] : undefined;
        const entityIcon = entityState ? stateIcon(entityState) : undefined;
        const icon = this._config.icon || entityIcon;
        const customLocalize = setupCustomlocalize(this.hass);
        const schema = computeSchema$4(customLocalize, icon);
        return $ `
            <ha-form
                .hass=${this.hass}
                .data=${this._config}
                .schema=${schema}
                .computeLabel=${this._computeLabel}
                @value-changed=${this._valueChanged}
            ></ha-form>
        `;
    }
    _valueChanged(ev) {
        fireEvent(this, "config-changed", { config: ev.detail.value });
    }
};
__decorate([
    t$1()
], MediaCardEditor.prototype, "_config", void 0);
MediaCardEditor = __decorate([
    n$1(MEDIA_PLAYER_CARD_EDITOR_NAME)
], MediaCardEditor);

var mediaPlayerCardEditor = /*#__PURE__*/Object.freeze({
  __proto__: null,
  MEDIA_LABELS: MEDIA_LABELS,
  get MediaCardEditor () { return MediaCardEditor; }
});

const personCardConfigStruct = assign(lovelaceCardConfigStruct, assign(entitySharedConfigStruct, appearanceSharedConfigStruct, actionsSharedConfigStruct));

const actions$1 = ["more-info", "navigate", "url", "call-service", "none"];
const computeSchema$3 = memoizeOne((icon) => [
    { name: "entity", selector: { entity: { domain: PERSON_ENTITY_DOMAINS } } },
    { name: "name", selector: { text: {} } },
    { name: "icon", selector: { icon: { placeholder: icon } } },
    ...APPEARANCE_FORM_SCHEMA,
    ...computeActionsFormSchema(actions$1),
]);
let SwitchCardEditor = class SwitchCardEditor extends MushroomBaseElement {
    constructor() {
        super(...arguments);
        this._computeLabel = (schema) => {
            const customLocalize = setupCustomlocalize(this.hass);
            if (GENERIC_LABELS.includes(schema.name)) {
                return customLocalize(`editor.card.generic.${schema.name}`);
            }
            return this.hass.localize(`ui.panel.lovelace.editor.card.generic.${schema.name}`);
        };
    }
    connectedCallback() {
        super.connectedCallback();
        void loadHaComponents();
    }
    setConfig(config) {
        assert(config, personCardConfigStruct);
        this._config = config;
    }
    render() {
        if (!this.hass || !this._config) {
            return $ ``;
        }
        const entityState = this._config.entity ? this.hass.states[this._config.entity] : undefined;
        const entityIcon = entityState ? stateIcon(entityState) : undefined;
        const icon = this._config.icon || entityIcon;
        const schema = computeSchema$3(icon);
        return $ `
            <ha-form
                .hass=${this.hass}
                .data=${this._config}
                .schema=${schema}
                .computeLabel=${this._computeLabel}
                @value-changed=${this._valueChanged}
            ></ha-form>
        `;
    }
    _valueChanged(ev) {
        fireEvent(this, "config-changed", { config: ev.detail.value });
    }
};
__decorate([
    t$1()
], SwitchCardEditor.prototype, "_config", void 0);
SwitchCardEditor = __decorate([
    n$1(PERSON_CARD_EDITOR_NAME)
], SwitchCardEditor);

var personCardEditor = /*#__PURE__*/Object.freeze({
  __proto__: null,
  get SwitchCardEditor () { return SwitchCardEditor; }
});

const titleCardConfigStruct = assign(lovelaceCardConfigStruct, object({
    title: optional(string()),
    subtitle: optional(string()),
    alignment: optional(string()),
}));

const TITLE_LABELS = ["title", "subtitle"];
const computeSchema$2 = memoizeOne(() => [
    {
        name: "title",
        selector: { template: {} },
    },
    {
        name: "subtitle",
        selector: { template: {} },
    },
    { name: "alignment", selector: { "mush-alignment": {} } },
]);
let TitleCardEditor = class TitleCardEditor extends MushroomBaseElement {
    constructor() {
        super(...arguments);
        this._computeLabel = (schema) => {
            const customLocalize = setupCustomlocalize(this.hass);
            if (TITLE_LABELS.includes(schema.name)) {
                return customLocalize(`editor.card.title.${schema.name}`);
            }
            return this.hass.localize(`ui.panel.lovelace.editor.card.generic.${schema.name}`);
        };
    }
    connectedCallback() {
        super.connectedCallback();
        void loadHaComponents();
    }
    setConfig(config) {
        assert(config, titleCardConfigStruct);
        this._config = config;
    }
    render() {
        if (!this.hass || !this._config) {
            return $ ``;
        }
        const schema = computeSchema$2();
        return $ `
            <ha-form
                .hass=${this.hass}
                .data=${this._config}
                .schema=${schema}
                .computeLabel=${this._computeLabel}
                @value-changed=${this._valueChanged}
            ></ha-form>
        `;
    }
    _valueChanged(ev) {
        fireEvent(this, "config-changed", { config: ev.detail.value });
    }
};
__decorate([
    t$1()
], TitleCardEditor.prototype, "_config", void 0);
TitleCardEditor = __decorate([
    n$1(TITLE_CARD_EDITOR_NAME)
], TitleCardEditor);

var titleCardEditor = /*#__PURE__*/Object.freeze({
  __proto__: null,
  get TitleCardEditor () { return TitleCardEditor; }
});

const updateCardConfigStruct = assign(lovelaceCardConfigStruct, assign(entitySharedConfigStruct, appearanceSharedConfigStruct, actionsSharedConfigStruct), object({
    show_buttons_control: optional(boolean()),
    collapsible_controls: optional(boolean()),
}));

const UPDATE_LABELS = ["show_buttons_control"];
const actions = ["more-info", "navigate", "url", "call-service", "none"];
const computeSchema$1 = memoizeOne((icon) => [
    { name: "entity", selector: { entity: { domain: UPDATE_ENTITY_DOMAINS } } },
    { name: "name", selector: { text: {} } },
    { name: "icon", selector: { icon: { placeholder: icon } } },
    ...APPEARANCE_FORM_SCHEMA,
    {
        type: "grid",
        name: "",
        schema: [
            { name: "show_buttons_control", selector: { boolean: {} } },
            { name: "collapsible_controls", selector: { boolean: {} } },
        ],
    },
    ...computeActionsFormSchema(actions),
]);
let UpdateCardEditor = class UpdateCardEditor extends MushroomBaseElement {
    constructor() {
        super(...arguments);
        this._computeLabel = (schema) => {
            const customLocalize = setupCustomlocalize(this.hass);
            if (GENERIC_LABELS.includes(schema.name)) {
                return customLocalize(`editor.card.generic.${schema.name}`);
            }
            if (UPDATE_LABELS.includes(schema.name)) {
                return customLocalize(`editor.card.update.${schema.name}`);
            }
            return this.hass.localize(`ui.panel.lovelace.editor.card.generic.${schema.name}`);
        };
    }
    connectedCallback() {
        super.connectedCallback();
        void loadHaComponents();
    }
    setConfig(config) {
        assert(config, updateCardConfigStruct);
        this._config = config;
    }
    render() {
        if (!this.hass || !this._config) {
            return $ ``;
        }
        const entityState = this._config.entity ? this.hass.states[this._config.entity] : undefined;
        const entityIcon = entityState ? stateIcon(entityState) : undefined;
        const icon = this._config.icon || entityIcon;
        const schema = computeSchema$1(icon);
        return $ `
            <ha-form
                .hass=${this.hass}
                .data=${this._config}
                .schema=${schema}
                .computeLabel=${this._computeLabel}
                @value-changed=${this._valueChanged}
            ></ha-form>
        `;
    }
    _valueChanged(ev) {
        fireEvent(this, "config-changed", { config: ev.detail.value });
    }
};
__decorate([
    t$1()
], UpdateCardEditor.prototype, "_config", void 0);
UpdateCardEditor = __decorate([
    n$1(UPDATE_CARD_EDITOR_NAME)
], UpdateCardEditor);

var updateCardEditor = /*#__PURE__*/Object.freeze({
  __proto__: null,
  get UpdateCardEditor () { return UpdateCardEditor; }
});

const VACUUM_COMMANDS = [
    "on_off",
    "start_pause",
    "stop",
    "locate",
    "clean_spot",
    "return_home",
];
const vacuumCardConfigStruct = assign(lovelaceCardConfigStruct, assign(entitySharedConfigStruct, appearanceSharedConfigStruct, actionsSharedConfigStruct), object({
    icon_animation: optional(boolean()),
    commands: optional(array(string())),
}));

const VACUUM_LABELS = ["commands"];
const computeSchema = memoizeOne((localize, customLocalize, icon) => [
    { name: "entity", selector: { entity: { domain: VACUUM_ENTITY_DOMAINS } } },
    { name: "name", selector: { text: {} } },
    {
        type: "grid",
        name: "",
        schema: [
            { name: "icon", selector: { icon: { placeholder: icon } } },
            { name: "icon_animation", selector: { boolean: {} } },
        ],
    },
    ...APPEARANCE_FORM_SCHEMA,
    {
        name: "commands",
        selector: {
            select: {
                mode: "list",
                multiple: true,
                options: VACUUM_COMMANDS.map((command) => ({
                    value: command,
                    label: command === "on_off"
                        ? customLocalize(`editor.card.vacuum.commands_list.${command}`)
                        : localize(`ui.dialogs.more_info_control.vacuum.${command}`),
                })),
            },
        },
    },
    ...computeActionsFormSchema(),
]);
let VacuumCardEditor = class VacuumCardEditor extends MushroomBaseElement {
    constructor() {
        super(...arguments);
        this._computeLabel = (schema) => {
            const customLocalize = setupCustomlocalize(this.hass);
            if (GENERIC_LABELS.includes(schema.name)) {
                return customLocalize(`editor.card.generic.${schema.name}`);
            }
            if (VACUUM_LABELS.includes(schema.name)) {
                return customLocalize(`editor.card.vacuum.${schema.name}`);
            }
            return this.hass.localize(`ui.panel.lovelace.editor.card.generic.${schema.name}`);
        };
    }
    connectedCallback() {
        super.connectedCallback();
        void loadHaComponents();
    }
    setConfig(config) {
        assert(config, vacuumCardConfigStruct);
        this._config = config;
    }
    render() {
        if (!this.hass || !this._config) {
            return $ ``;
        }
        const entityState = this._config.entity ? this.hass.states[this._config.entity] : undefined;
        const entityIcon = entityState ? stateIcon(entityState) : undefined;
        const icon = this._config.icon || entityIcon;
        const customLocalize = setupCustomlocalize(this.hass);
        const schema = computeSchema(this.hass.localize, customLocalize, icon);
        return $ `
            <ha-form
                .hass=${this.hass}
                .data=${this._config}
                .schema=${schema}
                .computeLabel=${this._computeLabel}
                @value-changed=${this._valueChanged}
            ></ha-form>
        `;
    }
    _valueChanged(ev) {
        fireEvent(this, "config-changed", { config: ev.detail.value });
    }
};
__decorate([
    t$1()
], VacuumCardEditor.prototype, "_config", void 0);
VacuumCardEditor = __decorate([
    n$1(VACUUM_CARD_EDITOR_NAME)
], VacuumCardEditor);

var vacuumCardEditor = /*#__PURE__*/Object.freeze({
  __proto__: null,
  get VacuumCardEditor () { return VacuumCardEditor; }
});

/**!
 * Sortable 1.15.0
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);

    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }

    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var version = "1.15.0";

function userAgent(pattern) {
  if (typeof window !== 'undefined' && window.navigator) {
    return !! /*@__PURE__*/navigator.userAgent.match(pattern);
  }
}

var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);

var captureMode = {
  capture: false,
  passive: false
};

function on(el, event, fn) {
  el.addEventListener(event, fn, !IE11OrLess && captureMode);
}

function off(el, event, fn) {
  el.removeEventListener(event, fn, !IE11OrLess && captureMode);
}

function matches(
/**HTMLElement*/
el,
/**String*/
selector) {
  if (!selector) return;
  selector[0] === '>' && (selector = selector.substring(1));

  if (el) {
    try {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      }
    } catch (_) {
      return false;
    }
  }

  return false;
}

function getParentOrHost(el) {
  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}

function closest(
/**HTMLElement*/
el,
/**String*/
selector,
/**HTMLElement*/
ctx, includeCTX) {
  if (el) {
    ctx = ctx || document;

    do {
      if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
        return el;
      }

      if (el === ctx) break;
      /* jshint boss:true */
    } while (el = getParentOrHost(el));
  }

  return null;
}

var R_SPACE = /\s+/g;

function toggleClass(el, name, state) {
  if (el && name) {
    if (el.classList) {
      el.classList[state ? 'add' : 'remove'](name);
    } else {
      var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');
      el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');
    }
  }
}

function css(el, prop, val) {
  var style = el && el.style;

  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, '');
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }

      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf('webkit') === -1) {
        prop = '-webkit-' + prop;
      }

      style[prop] = val + (typeof val === 'string' ? '' : 'px');
    }
  }
}

function matrix(el, selfOnly) {
  var appliedTransforms = '';

  if (typeof el === 'string') {
    appliedTransforms = el;
  } else {
    do {
      var transform = css(el, 'transform');

      if (transform && transform !== 'none') {
        appliedTransforms = transform + ' ' + appliedTransforms;
      }
      /* jshint boss:true */

    } while (!selfOnly && (el = el.parentNode));
  }

  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  /*jshint -W056 */

  return matrixFn && new matrixFn(appliedTransforms);
}

function find(ctx, tagName, iterator) {
  if (ctx) {
    var list = ctx.getElementsByTagName(tagName),
        i = 0,
        n = list.length;

    if (iterator) {
      for (; i < n; i++) {
        iterator(list[i], i);
      }
    }

    return list;
  }

  return [];
}

function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;

  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}
/**
 * Returns the "bounding client rect" of given element
 * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted
 * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container
 * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr
 * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone
 * @param  {[HTMLElement]} container              The parent the element will be placed in
 * @return {Object}                               The boundingClientRect of el, with specified adjustments
 */


function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el.getBoundingClientRect && el !== window) return;
  var elRect, top, left, bottom, right, height, width;

  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
    elRect = el.getBoundingClientRect();
    top = elRect.top;
    left = elRect.left;
    bottom = elRect.bottom;
    right = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top = 0;
    left = 0;
    bottom = window.innerHeight;
    right = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }

  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
    // Adjust for translate()
    container = container || el.parentNode; // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)
    // Not needed on <= IE11

    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, 'transform') !== 'none' || relativeToNonStaticParent && css(container, 'position') !== 'static')) {
          var containerRect = container.getBoundingClientRect(); // Set relative to edges of padding box of container

          top -= containerRect.top + parseInt(css(container, 'border-top-width'));
          left -= containerRect.left + parseInt(css(container, 'border-left-width'));
          bottom = top + elRect.height;
          right = left + elRect.width;
          break;
        }
        /* jshint boss:true */

      } while (container = container.parentNode);
    }
  }

  if (undoScale && el !== window) {
    // Adjust for scale()
    var elMatrix = matrix(container || el),
        scaleX = elMatrix && elMatrix.a,
        scaleY = elMatrix && elMatrix.d;

    if (elMatrix) {
      top /= scaleY;
      left /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom = top + height;
      right = left + width;
    }
  }

  return {
    top: top,
    left: left,
    bottom: bottom,
    right: right,
    width: width,
    height: height
  };
}
/**
 * Checks if a side of an element is scrolled past a side of its parents
 * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question
 * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')
 * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')
 * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element
 */


function isScrolledPast(el, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el, true),
      elSideVal = getRect(el)[elSide];
  /* jshint boss:true */

  while (parent) {
    var parentSideVal = getRect(parent)[parentSide],
        visible = void 0;

    if (parentSide === 'top' || parentSide === 'left') {
      visible = elSideVal >= parentSideVal;
    } else {
      visible = elSideVal <= parentSideVal;
    }

    if (!visible) return parent;
    if (parent === getWindowScrollingElement()) break;
    parent = getParentAutoScrollElement(parent, false);
  }

  return false;
}
/**
 * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)
 * and non-draggable elements
 * @param  {HTMLElement} el       The parent element
 * @param  {Number} childNum      The index of the child
 * @param  {Object} options       Parent Sortable's options
 * @return {HTMLElement}          The child at index childNum, or null if not found
 */


function getChild(el, childNum, options, includeDragEl) {
  var currentChild = 0,
      i = 0,
      children = el.children;

  while (i < children.length) {
    if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {
      if (currentChild === childNum) {
        return children[i];
      }

      currentChild++;
    }

    i++;
  }

  return null;
}
/**
 * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)
 * @param  {HTMLElement} el       Parent element
 * @param  {selector} selector    Any other elements that should be ignored
 * @return {HTMLElement}          The last child, ignoring ghostEl
 */


function lastChild(el, selector) {
  var last = el.lastElementChild;

  while (last && (last === Sortable.ghost || css(last, 'display') === 'none' || selector && !matches(last, selector))) {
    last = last.previousElementSibling;
  }

  return last || null;
}
/**
 * Returns the index of an element within its parent for a selected set of
 * elements
 * @param  {HTMLElement} el
 * @param  {selector} selector
 * @return {number}
 */


function index(el, selector) {
  var index = 0;

  if (!el || !el.parentNode) {
    return -1;
  }
  /* jshint boss:true */


  while (el = el.previousElementSibling) {
    if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable.clone && (!selector || matches(el, selector))) {
      index++;
    }
  }

  return index;
}
/**
 * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.
 * The value is returned in real pixels.
 * @param  {HTMLElement} el
 * @return {Array}             Offsets in the format of [left, top]
 */


function getRelativeScrollOffset(el) {
  var offsetLeft = 0,
      offsetTop = 0,
      winScroller = getWindowScrollingElement();

  if (el) {
    do {
      var elMatrix = matrix(el),
          scaleX = elMatrix.a,
          scaleY = elMatrix.d;
      offsetLeft += el.scrollLeft * scaleX;
      offsetTop += el.scrollTop * scaleY;
    } while (el !== winScroller && (el = el.parentNode));
  }

  return [offsetLeft, offsetTop];
}
/**
 * Returns the index of the object within the given array
 * @param  {Array} arr   Array that may or may not hold the object
 * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find
 * @return {Number}      The index of the object in the array, or -1
 */


function indexOfObject(arr, obj) {
  for (var i in arr) {
    if (!arr.hasOwnProperty(i)) continue;

    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);
    }
  }

  return -1;
}

function getParentAutoScrollElement(el, includeSelf) {
  // skip to window
  if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();
  var elem = el;
  var gotSelf = false;

  do {
    // we don't need to get elem css if it isn't even overflowing in the first place (performance)
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);

      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {
        if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();
        if (gotSelf || includeSelf) return elem;
        gotSelf = true;
      }
    }
    /* jshint boss:true */

  } while (elem = elem.parentNode);

  return getWindowScrollingElement();
}

function extend(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }

  return dst;
}

function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}

var _throttleTimeout;

function throttle(callback, ms) {
  return function () {
    if (!_throttleTimeout) {
      var args = arguments,
          _this = this;

      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }

      _throttleTimeout = setTimeout(function () {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}

function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}

function scrollBy(el, x, y) {
  el.scrollLeft += x;
  el.scrollTop += y;
}

function clone(el) {
  var Polymer = window.Polymer;
  var $ = window.jQuery || window.Zepto;

  if (Polymer && Polymer.dom) {
    return Polymer.dom(el).cloneNode(true);
  } else if ($) {
    return $(el).clone(true)[0];
  } else {
    return el.cloneNode(true);
  }
}

function setRect(el, rect) {
  css(el, 'position', 'absolute');
  css(el, 'top', rect.top);
  css(el, 'left', rect.left);
  css(el, 'width', rect.width);
  css(el, 'height', rect.height);
}

function unsetRect(el) {
  css(el, 'position', '');
  css(el, 'top', '');
  css(el, 'left', '');
  css(el, 'width', '');
  css(el, 'height', '');
}

var expando = 'Sortable' + new Date().getTime();

function AnimationStateManager() {
  var animationStates = [],
      animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation) return;
      var children = [].slice.call(this.el.children);
      children.forEach(function (child) {
        if (css(child, 'display') === 'none' || child === Sortable.ghost) return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });

        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect); // If animating: compensate for current animation


        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);

          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }

        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state) {
      animationStates.push(state);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target: target
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;

      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === 'function') callback();
        return;
      }

      var animating = false,
          animationTime = 0;
      animationStates.forEach(function (state) {
        var time = 0,
            target = state.target,
            fromRect = target.fromRect,
            toRect = getRect(target),
            prevFromRect = target.prevFromRect,
            prevToRect = target.prevToRect,
            animatingRect = state.rect,
            targetMatrix = matrix(target, true);

        if (targetMatrix) {
          // Compensate for current animation
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }

        target.toRect = toRect;

        if (target.thisAnimationDuration) {
          // Could also check if animatingRect is between fromRect and toRect
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect
          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            // If returning to same place as started from animation and on same axis
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        } // if fromRect != toRect: animate


        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;

          if (!time) {
            time = _this.options.animation;
          }

          _this.animate(target, animatingRect, toRect, time);
        }

        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function () {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time);
          target.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);

      if (!animating) {
        if (typeof callback === 'function') callback();
      } else {
        animationCallbackId = setTimeout(function () {
          if (typeof callback === 'function') callback();
        }, animationTime);
      }

      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration) {
      if (duration) {
        css(target, 'transition', '');
        css(target, 'transform', '');
        var elMatrix = matrix(this.el),
            scaleX = elMatrix && elMatrix.a,
            scaleY = elMatrix && elMatrix.d,
            translateX = (currentRect.left - toRect.left) / (scaleX || 1),
            translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');
        this.forRepaintDummy = repaint(target); // repaint

        css(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));
        css(target, 'transform', 'translate3d(0,0,0)');
        typeof target.animated === 'number' && clearTimeout(target.animated);
        target.animated = setTimeout(function () {
          css(target, 'transition', '');
          css(target, 'transform', '');
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration);
      }
    }
  };
}

function repaint(target) {
  return target.offsetWidth;
}

function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}

var plugins = [];
var defaults = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin) {
    // Set default static properties
    for (var option in defaults) {
      if (defaults.hasOwnProperty(option) && !(option in plugin)) {
        plugin[option] = defaults[option];
      }
    }

    plugins.forEach(function (p) {
      if (p.pluginName === plugin.pluginName) {
        throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
      }
    });
    plugins.push(plugin);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;

    this.eventCanceled = false;

    evt.cancel = function () {
      _this.eventCanceled = true;
    };

    var eventNameGlobal = eventName + 'Global';
    plugins.forEach(function (plugin) {
      if (!sortable[plugin.pluginName]) return; // Fire global events if it exists in this sortable

      if (sortable[plugin.pluginName][eventNameGlobal]) {
        sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
          sortable: sortable
        }, evt));
      } // Only fire plugin event if plugin is enabled in this sortable,
      // and plugin has event defined


      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
        sortable[plugin.pluginName][eventName](_objectSpread2({
          sortable: sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el, defaults, options) {
    plugins.forEach(function (plugin) {
      var pluginName = plugin.pluginName;
      if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;
      var initialized = new plugin(sortable, el, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized; // Add default options from plugin

      _extends(defaults, initialized.defaults);
    });

    for (var option in sortable.options) {
      if (!sortable.options.hasOwnProperty(option)) continue;
      var modified = this.modifyOption(sortable, option, sortable.options[option]);

      if (typeof modified !== 'undefined') {
        sortable.options[option] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name, sortable) {
    var eventProperties = {};
    plugins.forEach(function (plugin) {
      if (typeof plugin.eventProperties !== 'function') return;

      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name, value) {
    var modifiedValue;
    plugins.forEach(function (plugin) {
      // Plugin must exist on the Sortable
      if (!sortable[plugin.pluginName]) return; // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin

      if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {
        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
      }
    });
    return modifiedValue;
  }
};

function dispatchEvent(_ref) {
  var sortable = _ref.sortable,
      rootEl = _ref.rootEl,
      name = _ref.name,
      targetEl = _ref.targetEl,
      cloneEl = _ref.cloneEl,
      toEl = _ref.toEl,
      fromEl = _ref.fromEl,
      oldIndex = _ref.oldIndex,
      newIndex = _ref.newIndex,
      oldDraggableIndex = _ref.oldDraggableIndex,
      newDraggableIndex = _ref.newDraggableIndex,
      originalEvent = _ref.originalEvent,
      putSortable = _ref.putSortable,
      extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl && rootEl[expando];
  if (!sortable) return;
  var evt,
      options = sortable.options,
      onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1); // Support for new CustomEvent feature

  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent(name, true, true);
  }

  evt.to = toEl || rootEl;
  evt.from = fromEl || rootEl;
  evt.item = targetEl || rootEl;
  evt.clone = cloneEl;
  evt.oldIndex = oldIndex;
  evt.newIndex = newIndex;
  evt.oldDraggableIndex = oldDraggableIndex;
  evt.newDraggableIndex = newDraggableIndex;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;

  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));

  for (var option in allEventProperties) {
    evt[option] = allEventProperties[option];
  }

  if (rootEl) {
    rootEl.dispatchEvent(evt);
  }

  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}

var _excluded = ["evt"];

var pluginEvent = function pluginEvent(eventName, sortable) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      originalEvent = _ref.evt,
      data = _objectWithoutProperties(_ref, _excluded);

  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
    dragEl: dragEl,
    parentEl: parentEl,
    ghostEl: ghostEl,
    rootEl: rootEl,
    nextEl: nextEl,
    lastDownEl: lastDownEl,
    cloneEl: cloneEl,
    cloneHidden: cloneHidden,
    dragStarted: moved,
    putSortable: putSortable,
    activeSortable: Sortable.active,
    originalEvent: originalEvent,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name) {
      _dispatchEvent({
        sortable: sortable,
        name: name,
        originalEvent: originalEvent
      });
    }
  }, data));
};

function _dispatchEvent(info) {
  dispatchEvent(_objectSpread2({
    putSortable: putSortable,
    cloneEl: cloneEl,
    targetEl: dragEl,
    rootEl: rootEl,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex
  }, info));
}

var dragEl,
    parentEl,
    ghostEl,
    rootEl,
    nextEl,
    lastDownEl,
    cloneEl,
    cloneHidden,
    oldIndex,
    newIndex,
    oldDraggableIndex,
    newDraggableIndex,
    activeGroup,
    putSortable,
    awaitingDragStarted = false,
    ignoreNextClick = false,
    sortables = [],
    tapEvt,
    touchEvt,
    lastDx,
    lastDy,
    tapDistanceLeft,
    tapDistanceTop,
    moved,
    lastTarget,
    lastDirection,
    pastFirstInvertThresh = false,
    isCircumstantialInvert = false,
    targetMoveDistance,
    // For positioning ghost absolutely
ghostRelativeParent,
    ghostRelativeParentInitialScroll = [],
    // (left, top)
_silent = false,
    savedInputChecked = [];
/** @const */

var documentExists = typeof document !== 'undefined',
    PositionGhostAbsolutely = IOS,
    CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',
    // This will not pass for IE9, because IE9 DnD only works on anchors
supportDraggable = documentExists && !ChromeForAndroid && !IOS && 'draggable' in document.createElement('div'),
    supportCssPointerEvents = function () {
  if (!documentExists) return; // false when <= IE11

  if (IE11OrLess) {
    return false;
  }

  var el = document.createElement('x');
  el.style.cssText = 'pointer-events:auto';
  return el.style.pointerEvents === 'auto';
}(),
    _detectDirection = function _detectDirection(el, options) {
  var elCSS = css(el),
      elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),
      child1 = getChild(el, 0, options),
      child2 = getChild(el, 1, options),
      firstChildCSS = child1 && css(child1),
      secondChildCSS = child2 && css(child2),
      firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,
      secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;

  if (elCSS.display === 'flex') {
    return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';
  }

  if (elCSS.display === 'grid') {
    return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';
  }

  if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== 'none') {
    var touchingSideChild2 = firstChildCSS["float"] === 'left' ? 'left' : 'right';
    return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';
  }

  return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';
},
    _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {
  var dragElS1Opp = vertical ? dragRect.left : dragRect.top,
      dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,
      dragElOppLength = vertical ? dragRect.width : dragRect.height,
      targetS1Opp = vertical ? targetRect.left : targetRect.top,
      targetS2Opp = vertical ? targetRect.right : targetRect.bottom,
      targetOppLength = vertical ? targetRect.width : targetRect.height;
  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
},

/**
 * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.
 * @param  {Number} x      X position
 * @param  {Number} y      Y position
 * @return {HTMLElement}   Element of the first found nearest Sortable
 */
_detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {
  var ret;
  sortables.some(function (sortable) {
    var threshold = sortable[expando].options.emptyInsertThreshold;
    if (!threshold || lastChild(sortable)) return;
    var rect = getRect(sortable),
        insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,
        insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;

    if (insideHorizontally && insideVertically) {
      return ret = sortable;
    }
  });
  return ret;
},
    _prepareGroup = function _prepareGroup(options) {
  function toFn(value, pull) {
    return function (to, from, dragEl, evt) {
      var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;

      if (value == null && (pull || sameGroup)) {
        // Default pull value
        // Default pull and put value if same group
        return true;
      } else if (value == null || value === false) {
        return false;
      } else if (pull && value === 'clone') {
        return value;
      } else if (typeof value === 'function') {
        return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);
      } else {
        var otherGroup = (pull ? to : from).options.group.name;
        return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
      }
    };
  }

  var group = {};
  var originalGroup = options.group;

  if (!originalGroup || _typeof(originalGroup) != 'object') {
    originalGroup = {
      name: originalGroup
    };
  }

  group.name = originalGroup.name;
  group.checkPull = toFn(originalGroup.pull, true);
  group.checkPut = toFn(originalGroup.put);
  group.revertClone = originalGroup.revertClone;
  options.group = group;
},
    _hideGhostForTarget = function _hideGhostForTarget() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, 'display', 'none');
  }
},
    _unhideGhostForTarget = function _unhideGhostForTarget() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, 'display', '');
  }
}; // #1184 fix - Prevent click event on fallback if dragged but item not changed position


if (documentExists && !ChromeForAndroid) {
  document.addEventListener('click', function (evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}

var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;

    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);

    if (nearest) {
      // Create imitation event
      var event = {};

      for (var i in evt) {
        if (evt.hasOwnProperty(i)) {
          event[i] = evt[i];
        }
      }

      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;

      nearest[expando]._onDragOver(event);
    }
  }
};

var _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};
/**
 * @class  Sortable
 * @param  {HTMLElement}  el
 * @param  {Object}       [options]
 */


function Sortable(el, options) {
  if (!(el && el.nodeType && el.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
  }

  this.el = el; // root element

  this.options = options = _extends({}, options); // Export instance

  el[expando] = this;
  var defaults = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: false,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el, this.options);
    },
    ghostClass: 'sortable-ghost',
    chosenClass: 'sortable-chosen',
    dragClass: 'sortable-drag',
    ignore: 'a, img',
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl) {
      dataTransfer.setData('Text', dragEl.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: 'data-id',
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: 'sortable-fallback',
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: Sortable.supportPointer !== false && 'PointerEvent' in window && !Safari,
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el, defaults); // Set default options

  for (var name in defaults) {
    !(name in options) && (options[name] = defaults[name]);
  }

  _prepareGroup(options); // Bind all private methods


  for (var fn in this) {
    if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
      this[fn] = this[fn].bind(this);
    }
  } // Setup drag mode


  this.nativeDraggable = options.forceFallback ? false : supportDraggable;

  if (this.nativeDraggable) {
    // Touch start threshold cannot be greater than the native dragstart threshold
    this.options.touchStartThreshold = 1;
  } // Bind events


  if (options.supportPointer) {
    on(el, 'pointerdown', this._onTapStart);
  } else {
    on(el, 'mousedown', this._onTapStart);
    on(el, 'touchstart', this._onTapStart);
  }

  if (this.nativeDraggable) {
    on(el, 'dragover', this);
    on(el, 'dragenter', this);
  }

  sortables.push(this.el); // Restore sorting

  options.store && options.store.get && this.sort(options.store.get(this) || []); // Add animation state manager

  _extends(this, AnimationStateManager());
}

Sortable.prototype =
/** @lends Sortable.prototype */
{
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart(
  /** Event|TouchEvent */
  evt) {
    if (!evt.cancelable) return;

    var _this = this,
        el = this.el,
        options = this.options,
        preventOnFilter = options.preventOnFilter,
        type = evt.type,
        touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,
        target = (touch || evt).target,
        originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,
        filter = options.filter;

    _saveInputCheckedState(el); // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.


    if (dragEl) {
      return;
    }

    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
      return; // only left button and enabled
    } // cancel dnd if original target is content editable


    if (originalTarget.isContentEditable) {
      return;
    } // Safari ignores further event handling after mousedown


    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === 'SELECT') {
      return;
    }

    target = closest(target, options.draggable, el, false);

    if (target && target.animated) {
      return;
    }

    if (lastDownEl === target) {
      // Ignoring duplicate `down`
      return;
    } // Get the index of the dragged element within its parent


    oldIndex = index(target);
    oldDraggableIndex = index(target, options.draggable); // Check filter

    if (typeof filter === 'function') {
      if (filter.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: 'filter',
          targetEl: target,
          toEl: el,
          fromEl: el
        });

        pluginEvent('filter', _this, {
          evt: evt
        });
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return; // cancel dnd
      }
    } else if (filter) {
      filter = filter.split(',').some(function (criteria) {
        criteria = closest(originalTarget, criteria.trim(), el, false);

        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: 'filter',
            targetEl: target,
            fromEl: el,
            toEl: el
          });

          pluginEvent('filter', _this, {
            evt: evt
          });
          return true;
        }
      });

      if (filter) {
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return; // cancel dnd
      }
    }

    if (options.handle && !closest(originalTarget, options.handle, el, false)) {
      return;
    } // Prepare `dragstart`


    this._prepareDragStart(evt, touch, target);
  },
  _prepareDragStart: function _prepareDragStart(
  /** Event */
  evt,
  /** Touch */
  touch,
  /** HTMLElement */
  target) {
    var _this = this,
        el = _this.el,
        options = _this.options,
        ownerDocument = el.ownerDocument,
        dragStartFn;

    if (target && !dragEl && target.parentNode === el) {
      var dragRect = getRect(target);
      rootEl = el;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style['will-change'] = 'all';

      dragStartFn = function dragStartFn() {
        pluginEvent('delayEnded', _this, {
          evt: evt
        });

        if (Sortable.eventCanceled) {
          _this._onDrop();

          return;
        } // Delayed drag has been triggered
        // we can re-enable the events: touchmove/mousemove


        _this._disableDelayedDragEvents();

        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        } // Bind the events: dragstart/dragend


        _this._triggerDragStart(evt, touch); // Drag start event


        _dispatchEvent({
          sortable: _this,
          name: 'choose',
          originalEvent: evt
        }); // Chosen item


        toggleClass(dragEl, options.chosenClass, true);
      }; // Disable "draggable"


      options.ignore.split(',').forEach(function (criteria) {
        find(dragEl, criteria.trim(), _disableDraggable);
      });
      on(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'mouseup', _this._onDrop);
      on(ownerDocument, 'touchend', _this._onDrop);
      on(ownerDocument, 'touchcancel', _this._onDrop); // Make dragEl draggable (must be before delay for FireFox)

      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }

      pluginEvent('delayStart', this, {
        evt: evt
      }); // Delay is impossible for native DnD in Edge or IE

      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();

          return;
        } // If the user moves the pointer or let go the click or touch
        // before the delay has been reached:
        // disable the delayed drag


        on(ownerDocument, 'mouseup', _this._disableDelayedDrag);
        on(ownerDocument, 'touchend', _this._disableDelayedDrag);
        on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
        on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);
        on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);
        options.supportPointer && on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(
  /** TouchEvent|PointerEvent **/
  e) {
    var touch = e.touches ? e.touches[0] : e;

    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);

    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._disableDelayedDrag);
    off(ownerDocument, 'touchend', this._disableDelayedDrag);
    off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
    off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart(
  /** Event */
  evt,
  /** Touch */
  touch) {
    touch = touch || evt.pointerType == 'touch' && evt;

    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on(document, 'pointermove', this._onTouchMove);
      } else if (touch) {
        on(document, 'touchmove', this._onTouchMove);
      } else {
        on(document, 'mousemove', this._onTouchMove);
      }
    } else {
      on(dragEl, 'dragend', this);
      on(rootEl, 'dragstart', this._onDragStart);
    }

    try {
      if (document.selection) {
        // Timeout neccessary for IE9
        _nextTick(function () {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {}
  },
  _dragStarted: function _dragStarted(fallback, evt) {

    awaitingDragStarted = false;

    if (rootEl && dragEl) {
      pluginEvent('dragStarted', this, {
        evt: evt
      });

      if (this.nativeDraggable) {
        on(document, 'dragover', _checkOutsideTargetEl);
      }

      var options = this.options; // Apply effect

      !fallback && toggleClass(dragEl, options.dragClass, false);
      toggleClass(dragEl, options.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost(); // Drag start event

      _dispatchEvent({
        sortable: this,
        name: 'start',
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;

      _hideGhostForTarget();

      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent = target;

      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target === parent) break;
        parent = target;
      }

      dragEl.parentNode[expando]._isOutsideThisEl(target);

      if (parent) {
        do {
          if (parent[expando]) {
            var inserted = void 0;
            inserted = parent[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target: target,
              rootEl: parent
            });

            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }

          target = parent; // store last element
        }
        /* jshint boss:true */
        while (parent = parent.parentNode);
      }

      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove(
  /**TouchEvent*/
  evt) {
    if (tapEvt) {
      var options = this.options,
          fallbackTolerance = options.fallbackTolerance,
          fallbackOffset = options.fallbackOffset,
          touch = evt.touches ? evt.touches[0] : evt,
          ghostMatrix = ghostEl && matrix(ghostEl, true),
          scaleX = ghostEl && ghostMatrix && ghostMatrix.a,
          scaleY = ghostEl && ghostMatrix && ghostMatrix.d,
          relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),
          dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),
          dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1); // only set the status to dragging, when we are actually dragging

      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }

        this._onDragStart(evt, true);
      }

      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }

        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, 'webkitTransform', cssMatrix);
        css(ghostEl, 'mozTransform', cssMatrix);
        css(ghostEl, 'msTransform', cssMatrix);
        css(ghostEl, 'transform', cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch;
      }

      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    // Bug if using scale(): https://stackoverflow.com/questions/2637058
    // Not being adjusted for
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl,
          rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),
          options = this.options; // Position absolutely

      if (PositionGhostAbsolutely) {
        // Get relatively positioned parent
        ghostRelativeParent = container;

        while (css(ghostRelativeParent, 'position') === 'static' && css(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }

        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }

        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }

      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options.ghostClass, false);
      toggleClass(ghostEl, options.fallbackClass, true);
      toggleClass(ghostEl, options.dragClass, true);
      css(ghostEl, 'transition', '');
      css(ghostEl, 'transform', '');
      css(ghostEl, 'box-sizing', 'border-box');
      css(ghostEl, 'margin', 0);
      css(ghostEl, 'top', rect.top);
      css(ghostEl, 'left', rect.left);
      css(ghostEl, 'width', rect.width);
      css(ghostEl, 'height', rect.height);
      css(ghostEl, 'opacity', '0.8');
      css(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');
      css(ghostEl, 'zIndex', '100000');
      css(ghostEl, 'pointerEvents', 'none');
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl); // Set transform-origin

      css(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');
    }
  },
  _onDragStart: function _onDragStart(
  /**Event*/
  evt,
  /**boolean*/
  fallback) {
    var _this = this;

    var dataTransfer = evt.dataTransfer;
    var options = _this.options;
    pluginEvent('dragStart', this, {
      evt: evt
    });

    if (Sortable.eventCanceled) {
      this._onDrop();

      return;
    }

    pluginEvent('setupClone', this);

    if (!Sortable.eventCanceled) {
      cloneEl = clone(dragEl);
      cloneEl.removeAttribute("id");
      cloneEl.draggable = false;
      cloneEl.style['will-change'] = '';

      this._hideClone();

      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    } // #1143: IFrame support workaround


    _this.cloneId = _nextTick(function () {
      pluginEvent('clone', _this);
      if (Sortable.eventCanceled) return;

      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }

      _this._hideClone();

      _dispatchEvent({
        sortable: _this,
        name: 'clone'
      });
    });
    !fallback && toggleClass(dragEl, options.dragClass, true); // Set proper drop events

    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      // Undo what was set in _prepareDragStart before drag started
      off(document, 'mouseup', _this._onDrop);
      off(document, 'touchend', _this._onDrop);
      off(document, 'touchcancel', _this._onDrop);

      if (dataTransfer) {
        dataTransfer.effectAllowed = 'move';
        options.setData && options.setData.call(_this, dataTransfer, dragEl);
      }

      on(document, 'drop', _this); // #1276 fix:

      css(dragEl, 'transform', 'translateZ(0)');
    }

    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on(document, 'selectstart', _this);
    moved = true;

    if (Safari) {
      css(document.body, 'user-select', 'none');
    }
  },
  // Returns true - if no further action is needed (either inserted or another condition)
  _onDragOver: function _onDragOver(
  /**Event*/
  evt) {
    var el = this.el,
        target = evt.target,
        dragRect,
        targetRect,
        revert,
        options = this.options,
        group = options.group,
        activeSortable = Sortable.active,
        isOwner = activeGroup === group,
        canSort = options.sort,
        fromSortable = putSortable || activeSortable,
        vertical,
        _this = this,
        completedFired = false;

    if (_silent) return;

    function dragOverEvent(name, extra) {
      pluginEvent(name, _this, _objectSpread2({
        evt: evt,
        isOwner: isOwner,
        axis: vertical ? 'vertical' : 'horizontal',
        revert: revert,
        dragRect: dragRect,
        targetRect: targetRect,
        canSort: canSort,
        fromSortable: fromSortable,
        target: target,
        completed: completed,
        onMove: function onMove(target, after) {
          return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);
        },
        changed: changed
      }, extra));
    } // Capture animation state


    function capture() {
      dragOverEvent('dragOverAnimationCapture');

      _this.captureAnimationState();

      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    } // Return invocation when dragEl is inserted (or completed)


    function completed(insertion) {
      dragOverEvent('dragOverCompleted', {
        insertion: insertion
      });

      if (insertion) {
        // Clones must be hidden before folding animation to capture dragRectAbsolute properly
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }

        if (_this !== fromSortable) {
          // Set ghost class to new sortable's ghost class
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options.ghostClass, true);
        }

        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        } // Animation


        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }

        _this.animateAll(function () {
          dragOverEvent('dragOverAnimationComplete');
          _this._ignoreWhileAnimating = null;
        });

        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      } // Null lastTarget if it is not inside a previously swapped element


      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
        lastTarget = null;
      } // no bubbling and not fallback


      if (!options.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target); // Do not detect for empty insert if already inserted


        !insertion && nearestEmptyInsertDetectEvent(evt);
      }

      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    } // Call when dragEl has been inserted


    function changed() {
      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);

      _dispatchEvent({
        sortable: _this,
        name: 'change',
        toEl: el,
        newIndex: newIndex,
        newDraggableIndex: newDraggableIndex,
        originalEvent: evt
      });
    }

    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }

    target = closest(target, options.draggable, el, true);
    dragOverEvent('dragOver');
    if (Sortable.eventCanceled) return completedFired;

    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed(false);
    }

    ignoreNextClick = false;

    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) // Reverting item into the original list
    : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === 'vertical';
      dragRect = getRect(dragEl);
      dragOverEvent('dragOverValid');
      if (Sortable.eventCanceled) return completedFired;

      if (revert) {
        parentEl = rootEl; // actualization

        capture();

        this._hideClone();

        dragOverEvent('revert');

        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }

        return completed(true);
      }

      var elLastChild = lastChild(el, options.draggable);

      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        // Insert to end of list
        // If already at end of list: Do not insert
        if (elLastChild === dragEl) {
          return completed(false);
        } // if there is a last element, it is the target


        if (elLastChild && el === evt.target) {
          target = elLastChild;
        }

        if (target) {
          targetRect = getRect(target);
        }

        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();

          if (elLastChild && elLastChild.nextSibling) {
            // the last draggable element is not the last node
            el.insertBefore(dragEl, elLastChild.nextSibling);
          } else {
            el.appendChild(dragEl);
          }

          parentEl = el; // actualization

          changed();
          return completed(true);
        }
      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
        // Insert to start of list
        var firstChild = getChild(el, 0, options, true);

        if (firstChild === dragEl) {
          return completed(false);
        }

        target = firstChild;
        targetRect = getRect(target);

        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
          capture();
          el.insertBefore(dragEl, firstChild);
          parentEl = el; // actualization

          changed();
          return completed(true);
        }
      } else if (target.parentNode === el) {
        targetRect = getRect(target);
        var direction = 0,
            targetBeforeFirstSwap,
            differentLevel = dragEl.parentNode !== el,
            differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),
            side1 = vertical ? 'top' : 'left',
            scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),
            scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;

        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
        }

        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;

        if (direction !== 0) {
          // Check if target is beside dragEl in respective direction (ignoring hidden elements)
          var dragIndex = index(dragEl);

          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, 'display') === 'none' || sibling === ghostEl));
        } // If dragEl is already beside target: Do not insert


        if (direction === 0 || sibling === target) {
          return completed(false);
        }

        lastTarget = target;
        lastDirection = direction;
        var nextSibling = target.nextElementSibling,
            after = false;
        after = direction === 1;

        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);

        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }

          _silent = true;
          setTimeout(_unsilent, 30);
          capture();

          if (after && !nextSibling) {
            el.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
          } // Undo chrome's scroll adjustment (has no effect on other browsers)


          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }

          parentEl = dragEl.parentNode; // actualization
          // must be done before animation

          if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
          }

          changed();
          return completed(true);
        }
      }

      if (el.contains(dragEl)) {
        return completed(false);
      }
    }

    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, 'mousemove', this._onTouchMove);
    off(document, 'touchmove', this._onTouchMove);
    off(document, 'pointermove', this._onTouchMove);
    off(document, 'dragover', nearestEmptyInsertDetectEvent);
    off(document, 'mousemove', nearestEmptyInsertDetectEvent);
    off(document, 'touchmove', nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._onDrop);
    off(ownerDocument, 'touchend', this._onDrop);
    off(ownerDocument, 'pointerup', this._onDrop);
    off(ownerDocument, 'touchcancel', this._onDrop);
    off(document, 'selectstart', this);
  },
  _onDrop: function _onDrop(
  /**Event*/
  evt) {
    var el = this.el,
        options = this.options; // Get the index of the dragged element within its parent

    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    pluginEvent('drop', this, {
      evt: evt
    });
    parentEl = dragEl && dragEl.parentNode; // Get again after plugin event

    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);

    if (Sortable.eventCanceled) {
      this._nulling();

      return;
    }

    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);

    _cancelNextTick(this.cloneId);

    _cancelNextTick(this._dragStartId); // Unbind events


    if (this.nativeDraggable) {
      off(document, 'drop', this);
      off(el, 'dragstart', this._onDragStart);
    }

    this._offMoveEvents();

    this._offUpEvents();

    if (Safari) {
      css(document.body, 'user-select', '');
    }

    css(dragEl, 'transform', '');

    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options.dropBubble && evt.stopPropagation();
      }

      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);

      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
        // Remove clone(s)
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }

      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, 'dragend', this);
        }

        _disableDraggable(dragEl);

        dragEl.style['will-change'] = ''; // Remove classes
        // ghostClass is added in dragStarted

        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }

        toggleClass(dragEl, this.options.chosenClass, false); // Drag stop event

        _dispatchEvent({
          sortable: this,
          name: 'unchoose',
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });

        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            // Add event
            _dispatchEvent({
              rootEl: parentEl,
              name: 'add',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            }); // Remove event


            _dispatchEvent({
              sortable: this,
              name: 'remove',
              toEl: parentEl,
              originalEvent: evt
            }); // drag from one list and drop into another


            _dispatchEvent({
              rootEl: parentEl,
              name: 'sort',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });

            _dispatchEvent({
              sortable: this,
              name: 'sort',
              toEl: parentEl,
              originalEvent: evt
            });
          }

          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              // drag & drop within the same list
              _dispatchEvent({
                sortable: this,
                name: 'update',
                toEl: parentEl,
                originalEvent: evt
              });

              _dispatchEvent({
                sortable: this,
                name: 'sort',
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }

        if (Sortable.active) {
          /* jshint eqnull:true */
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }

          _dispatchEvent({
            sortable: this,
            name: 'end',
            toEl: parentEl,
            originalEvent: evt
          }); // Save sorting


          this.save();
        }
      }
    }

    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent('nulling', this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function (el) {
      el.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent(
  /**Event*/
  evt) {
    switch (evt.type) {
      case 'drop':
      case 'dragend':
        this._onDrop(evt);

        break;

      case 'dragenter':
      case 'dragover':
        if (dragEl) {
          this._onDragOver(evt);

          _globalDragOver(evt);
        }

        break;

      case 'selectstart':
        evt.preventDefault();
        break;
    }
  },

  /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */
  toArray: function toArray() {
    var order = [],
        el,
        children = this.el.children,
        i = 0,
        n = children.length,
        options = this.options;

    for (; i < n; i++) {
      el = children[i];

      if (closest(el, options.draggable, this.el, false)) {
        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
      }
    }

    return order;
  },

  /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */
  sort: function sort(order, useAnimation) {
    var items = {},
        rootEl = this.el;
    this.toArray().forEach(function (id, i) {
      var el = rootEl.children[i];

      if (closest(el, this.options.draggable, rootEl, false)) {
        items[id] = el;
      }
    }, this);
    useAnimation && this.captureAnimationState();
    order.forEach(function (id) {
      if (items[id]) {
        rootEl.removeChild(items[id]);
        rootEl.appendChild(items[id]);
      }
    });
    useAnimation && this.animateAll();
  },

  /**
   * Save the current sorting
   */
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },

  /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */
  closest: function closest$1(el, selector) {
    return closest(el, selector || this.options.draggable, this.el, false);
  },

  /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */
  option: function option(name, value) {
    var options = this.options;

    if (value === void 0) {
      return options[name];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name, value);

      if (typeof modifiedValue !== 'undefined') {
        options[name] = modifiedValue;
      } else {
        options[name] = value;
      }

      if (name === 'group') {
        _prepareGroup(options);
      }
    }
  },

  /**
   * Destroy
   */
  destroy: function destroy() {
    pluginEvent('destroy', this);
    var el = this.el;
    el[expando] = null;
    off(el, 'mousedown', this._onTapStart);
    off(el, 'touchstart', this._onTapStart);
    off(el, 'pointerdown', this._onTapStart);

    if (this.nativeDraggable) {
      off(el, 'dragover', this);
      off(el, 'dragenter', this);
    } // Remove draggable attributes


    Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
      el.removeAttribute('draggable');
    });

    this._onDrop();

    this._disableDelayedDragEvents();

    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent('hideClone', this);
      if (Sortable.eventCanceled) return;
      css(cloneEl, 'display', 'none');

      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }

      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable) {
    if (putSortable.lastPutMode !== 'clone') {
      this._hideClone();

      return;
    }

    if (cloneHidden) {
      pluginEvent('showClone', this);
      if (Sortable.eventCanceled) return; // show clone at dragEl or original position

      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }

      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }

      css(cloneEl, 'display', '');
      cloneHidden = false;
    }
  }
};

function _globalDragOver(
/**Event*/
evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = 'move';
  }

  evt.cancelable && evt.preventDefault();
}

function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt,
      sortable = fromEl[expando],
      onMoveFn = sortable.options.onMove,
      retVal; // Support for new CustomEvent feature

  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent('move', {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent('move', true, true);
  }

  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);

  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }

  return retVal;
}

function _disableDraggable(el) {
  el.draggable = false;
}

function _unsilent() {
  _silent = false;
}

function _ghostIsFirst(evt, vertical, sortable) {
  var rect = getRect(getChild(sortable.el, 0, sortable.options, true));
  var spacer = 10;
  return vertical ? evt.clientX < rect.left - spacer || evt.clientY < rect.top && evt.clientX < rect.right : evt.clientY < rect.top - spacer || evt.clientY < rect.bottom && evt.clientX < rect.left;
}

function _ghostIsLast(evt, vertical, sortable) {
  var rect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var spacer = 10;
  return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;
}

function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX,
      targetLength = vertical ? targetRect.height : targetRect.width,
      targetS1 = vertical ? targetRect.top : targetRect.left,
      targetS2 = vertical ? targetRect.bottom : targetRect.right,
      invert = false;

  if (!invertSwap) {
    // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2
      // check if past first invert threshold on side opposite of lastDirection
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        // past first invert threshold, do not restrict inverted threshold to dragEl shadow
        pastFirstInvertThresh = true;
      }

      if (!pastFirstInvertThresh) {
        // dragEl shadow (target move distance shadow)
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow
        : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      // Regular
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }

  invert = invert || invertSwap;

  if (invert) {
    // Invert of regular
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }

  return 0;
}
/**
 * Gets the direction dragEl must be swapped relative to target in order to make it
 * seem that dragEl has been "inserted" into that element's position
 * @param  {HTMLElement} target       The target whose position dragEl is being inserted at
 * @return {Number}                   Direction dragEl must be swapped
 */


function _getInsertDirection(target) {
  if (index(dragEl) < index(target)) {
    return 1;
  } else {
    return -1;
  }
}
/**
 * Generate id
 * @param   {HTMLElement} el
 * @returns {String}
 * @private
 */


function _generateId(el) {
  var str = el.tagName + el.className + el.src + el.href + el.textContent,
      i = str.length,
      sum = 0;

  while (i--) {
    sum += str.charCodeAt(i);
  }

  return sum.toString(36);
}

function _saveInputCheckedState(root) {
  savedInputChecked.length = 0;
  var inputs = root.getElementsByTagName('input');
  var idx = inputs.length;

  while (idx--) {
    var el = inputs[idx];
    el.checked && savedInputChecked.push(el);
  }
}

function _nextTick(fn) {
  return setTimeout(fn, 0);
}

function _cancelNextTick(id) {
  return clearTimeout(id);
} // Fixed #973:


if (documentExists) {
  on(document, 'touchmove', function (evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
} // Export utils


Sortable.utils = {
  on: on,
  off: off,
  css: css,
  find: find,
  is: function is(el, selector) {
    return !!closest(el, selector, el, false);
  },
  extend: extend,
  throttle: throttle,
  closest: closest,
  toggleClass: toggleClass,
  clone: clone,
  index: index,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild: getChild
};
/**
 * Get the Sortable instance of an element
 * @param  {HTMLElement} element The element
 * @return {Sortable|undefined}         The instance of Sortable
 */

Sortable.get = function (element) {
  return element[expando];
};
/**
 * Mount a plugin to Sortable
 * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted
 */


Sortable.mount = function () {
  for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins[_key] = arguments[_key];
  }

  if (plugins[0].constructor === Array) plugins = plugins[0];
  plugins.forEach(function (plugin) {
    if (!plugin.prototype || !plugin.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
    }

    if (plugin.utils) Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
    PluginManager.mount(plugin);
  });
};
/**
 * Create sortable instance
 * @param {HTMLElement}  el
 * @param {Object}      [options]
 */


Sortable.create = function (el, options) {
  return new Sortable(el, options);
}; // Export


Sortable.version = version;

var autoScrolls = [],
    scrollEl,
    scrollRootEl,
    scrolling = false,
    lastAutoScrollX,
    lastAutoScrollY,
    touchEvt$1,
    pointerElemChangedInterval;

function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    }; // Bind all private methods

    for (var fn in this) {
      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
        this[fn] = this[fn].bind(this);
      }
    }
  }

  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref) {
      var originalEvent = _ref.originalEvent;

      if (this.sortable.nativeDraggable) {
        on(document, 'dragover', this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on(document, 'pointermove', this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on(document, 'touchmove', this._handleFallbackAutoScroll);
        } else {
          on(document, 'mousemove', this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;

      // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop() {
      if (this.sortable.nativeDraggable) {
        off(document, 'dragover', this._handleAutoScroll);
      } else {
        off(document, 'pointermove', this._handleFallbackAutoScroll);
        off(document, 'touchmove', this._handleFallbackAutoScroll);
        off(document, 'mousemove', this._handleFallbackAutoScroll);
      }

      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;

      var x = (evt.touches ? evt.touches[0] : evt).clientX,
          y = (evt.touches ? evt.touches[0] : evt).clientY,
          elem = document.elementFromPoint(x, y);
      touchEvt$1 = evt; // IE does not seem to have native autoscroll,
      // Edge's autoscroll seems too conditional,
      // MACOS Safari does not have autoscroll,
      // Firefox and Chrome are good

      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback); // Listener for pointer element change

        var ogElemScroller = getParentAutoScrollElement(elem, true);

        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval(); // Detect for pointer elem change, emulating native DnD behaviour

          pointerElemChangedInterval = setInterval(function () {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);

            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }

            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x;
          lastAutoScrollY = y;
        }
      } else {
        // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }

        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: 'scroll',
    initializeByDefault: true
  });
}

function clearAutoScrolls() {
  autoScrolls.forEach(function (autoScroll) {
    clearInterval(autoScroll.pid);
  });
  autoScrolls = [];
}

function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}

var autoScroll = throttle(function (evt, options, rootEl, isFallback) {
  // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
  if (!options.scroll) return;
  var x = (evt.touches ? evt.touches[0] : evt).clientX,
      y = (evt.touches ? evt.touches[0] : evt).clientY,
      sens = options.scrollSensitivity,
      speed = options.scrollSpeed,
      winScroller = getWindowScrollingElement();
  var scrollThisInstance = false,
      scrollCustomFn; // New scroll root, set scrollEl

  if (scrollRootEl !== rootEl) {
    scrollRootEl = rootEl;
    clearAutoScrolls();
    scrollEl = options.scroll;
    scrollCustomFn = options.scrollFn;

    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl, true);
    }
  }

  var layersOut = 0;
  var currentParent = scrollEl;

  do {
    var el = currentParent,
        rect = getRect(el),
        top = rect.top,
        bottom = rect.bottom,
        left = rect.left,
        right = rect.right,
        width = rect.width,
        height = rect.height,
        canScrollX = void 0,
        canScrollY = void 0,
        scrollWidth = el.scrollWidth,
        scrollHeight = el.scrollHeight,
        elCSS = css(el),
        scrollPosX = el.scrollLeft,
        scrollPosY = el.scrollTop;

    if (el === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');
    }

    var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);

    if (!autoScrolls[layersOut]) {
      for (var i = 0; i <= layersOut; i++) {
        if (!autoScrolls[i]) {
          autoScrolls[i] = {};
        }
      }
    }

    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
      autoScrolls[layersOut].el = el;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);

      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        /* jshint loopfunc:true */

        autoScrolls[layersOut].pid = setInterval(function () {
          // emulate drag over during autoscroll (fallback), emulating native DnD behaviour
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely

          }

          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;

          if (typeof scrollCustomFn === 'function') {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {
              return;
            }
          }

          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }.bind({
          layer: layersOut
        }), 24);
      }
    }

    layersOut++;
  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));

  scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not
}, 30);

var drop = function drop(_ref) {
  var originalEvent = _ref.originalEvent,
      putSortable = _ref.putSortable,
      dragEl = _ref.dragEl,
      activeSortable = _ref.activeSortable,
      dispatchSortableEvent = _ref.dispatchSortableEvent,
      hideGhostForTarget = _ref.hideGhostForTarget,
      unhideGhostForTarget = _ref.unhideGhostForTarget;
  if (!originalEvent) return;
  var toSortable = putSortable || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();

  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent('spill');
    this.onSpill({
      dragEl: dragEl,
      putSortable: putSortable
    });
  }
};

function Revert() {}

Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl = _ref3.dragEl,
        putSortable = _ref3.putSortable;
    this.sortable.captureAnimationState();

    if (putSortable) {
      putSortable.captureAnimationState();
    }

    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);

    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl);
    }

    this.sortable.animateAll();

    if (putSortable) {
      putSortable.animateAll();
    }
  },
  drop: drop
};

_extends(Revert, {
  pluginName: 'revertOnSpill'
});

function Remove() {}

Remove.prototype = {
  onSpill: function onSpill(_ref4) {
    var dragEl = _ref4.dragEl,
        putSortable = _ref4.putSortable;
    var parentSortable = putSortable || this.sortable;
    parentSortable.captureAnimationState();
    dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);
    parentSortable.animateAll();
  },
  drop: drop
};

_extends(Remove, {
  pluginName: 'removeOnSpill'
});

var OnSpill = [Remove, Revert];

var lastSwapEl;

function SwapPlugin() {
  function Swap() {
    this.defaults = {
      swapClass: 'sortable-swap-highlight'
    };
  }

  Swap.prototype = {
    dragStart: function dragStart(_ref) {
      var dragEl = _ref.dragEl;
      lastSwapEl = dragEl;
    },
    dragOverValid: function dragOverValid(_ref2) {
      var completed = _ref2.completed,
          target = _ref2.target,
          onMove = _ref2.onMove,
          activeSortable = _ref2.activeSortable,
          changed = _ref2.changed,
          cancel = _ref2.cancel;
      if (!activeSortable.options.swap) return;
      var el = this.sortable.el,
          options = this.options;

      if (target && target !== el) {
        var prevSwapEl = lastSwapEl;

        if (onMove(target) !== false) {
          toggleClass(target, options.swapClass, true);
          lastSwapEl = target;
        } else {
          lastSwapEl = null;
        }

        if (prevSwapEl && prevSwapEl !== lastSwapEl) {
          toggleClass(prevSwapEl, options.swapClass, false);
        }
      }

      changed();
      completed(true);
      cancel();
    },
    drop: function drop(_ref3) {
      var activeSortable = _ref3.activeSortable,
          putSortable = _ref3.putSortable,
          dragEl = _ref3.dragEl;
      var toSortable = putSortable || this.sortable;
      var options = this.options;
      lastSwapEl && toggleClass(lastSwapEl, options.swapClass, false);

      if (lastSwapEl && (options.swap || putSortable && putSortable.options.swap)) {
        if (dragEl !== lastSwapEl) {
          toSortable.captureAnimationState();
          if (toSortable !== activeSortable) activeSortable.captureAnimationState();
          swapNodes(dragEl, lastSwapEl);
          toSortable.animateAll();
          if (toSortable !== activeSortable) activeSortable.animateAll();
        }
      }
    },
    nulling: function nulling() {
      lastSwapEl = null;
    }
  };
  return _extends(Swap, {
    pluginName: 'swap',
    eventProperties: function eventProperties() {
      return {
        swapItem: lastSwapEl
      };
    }
  });
}

function swapNodes(n1, n2) {
  var p1 = n1.parentNode,
      p2 = n2.parentNode,
      i1,
      i2;
  if (!p1 || !p2 || p1.isEqualNode(n2) || p2.isEqualNode(n1)) return;
  i1 = index(n1);
  i2 = index(n2);

  if (p1.isEqualNode(p2) && i1 < i2) {
    i2++;
  }

  p1.insertBefore(n2, p1.children[i1]);
  p2.insertBefore(n1, p2.children[i2]);
}

var multiDragElements = [],
    multiDragClones = [],
    lastMultiDragSelect,
    // for selection with modifier key down (SHIFT)
multiDragSortable,
    initialFolding = false,
    // Initial multi-drag fold when drag started
folding = false,
    // Folding any other time
dragStarted = false,
    dragEl$1,
    clonesFromRect,
    clonesHidden;

function MultiDragPlugin() {
  function MultiDrag(sortable) {
    // Bind all private methods
    for (var fn in this) {
      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
        this[fn] = this[fn].bind(this);
      }
    }

    if (!sortable.options.avoidImplicitDeselect) {
      if (sortable.options.supportPointer) {
        on(document, 'pointerup', this._deselectMultiDrag);
      } else {
        on(document, 'mouseup', this._deselectMultiDrag);
        on(document, 'touchend', this._deselectMultiDrag);
      }
    }

    on(document, 'keydown', this._checkKeyDown);
    on(document, 'keyup', this._checkKeyUp);
    this.defaults = {
      selectedClass: 'sortable-selected',
      multiDragKey: null,
      avoidImplicitDeselect: false,
      setData: function setData(dataTransfer, dragEl) {
        var data = '';

        if (multiDragElements.length && multiDragSortable === sortable) {
          multiDragElements.forEach(function (multiDragElement, i) {
            data += (!i ? '' : ', ') + multiDragElement.textContent;
          });
        } else {
          data = dragEl.textContent;
        }

        dataTransfer.setData('Text', data);
      }
    };
  }

  MultiDrag.prototype = {
    multiDragKeyDown: false,
    isMultiDrag: false,
    delayStartGlobal: function delayStartGlobal(_ref) {
      var dragged = _ref.dragEl;
      dragEl$1 = dragged;
    },
    delayEnded: function delayEnded() {
      this.isMultiDrag = ~multiDragElements.indexOf(dragEl$1);
    },
    setupClone: function setupClone(_ref2) {
      var sortable = _ref2.sortable,
          cancel = _ref2.cancel;
      if (!this.isMultiDrag) return;

      for (var i = 0; i < multiDragElements.length; i++) {
        multiDragClones.push(clone(multiDragElements[i]));
        multiDragClones[i].sortableIndex = multiDragElements[i].sortableIndex;
        multiDragClones[i].draggable = false;
        multiDragClones[i].style['will-change'] = '';
        toggleClass(multiDragClones[i], this.options.selectedClass, false);
        multiDragElements[i] === dragEl$1 && toggleClass(multiDragClones[i], this.options.chosenClass, false);
      }

      sortable._hideClone();

      cancel();
    },
    clone: function clone(_ref3) {
      var sortable = _ref3.sortable,
          rootEl = _ref3.rootEl,
          dispatchSortableEvent = _ref3.dispatchSortableEvent,
          cancel = _ref3.cancel;
      if (!this.isMultiDrag) return;

      if (!this.options.removeCloneOnHide) {
        if (multiDragElements.length && multiDragSortable === sortable) {
          insertMultiDragClones(true, rootEl);
          dispatchSortableEvent('clone');
          cancel();
        }
      }
    },
    showClone: function showClone(_ref4) {
      var cloneNowShown = _ref4.cloneNowShown,
          rootEl = _ref4.rootEl,
          cancel = _ref4.cancel;
      if (!this.isMultiDrag) return;
      insertMultiDragClones(false, rootEl);
      multiDragClones.forEach(function (clone) {
        css(clone, 'display', '');
      });
      cloneNowShown();
      clonesHidden = false;
      cancel();
    },
    hideClone: function hideClone(_ref5) {
      var _this = this;

      _ref5.sortable;
          var cloneNowHidden = _ref5.cloneNowHidden,
          cancel = _ref5.cancel;
      if (!this.isMultiDrag) return;
      multiDragClones.forEach(function (clone) {
        css(clone, 'display', 'none');

        if (_this.options.removeCloneOnHide && clone.parentNode) {
          clone.parentNode.removeChild(clone);
        }
      });
      cloneNowHidden();
      clonesHidden = true;
      cancel();
    },
    dragStartGlobal: function dragStartGlobal(_ref6) {
      _ref6.sortable;

      if (!this.isMultiDrag && multiDragSortable) {
        multiDragSortable.multiDrag._deselectMultiDrag();
      }

      multiDragElements.forEach(function (multiDragElement) {
        multiDragElement.sortableIndex = index(multiDragElement);
      }); // Sort multi-drag elements

      multiDragElements = multiDragElements.sort(function (a, b) {
        return a.sortableIndex - b.sortableIndex;
      });
      dragStarted = true;
    },
    dragStarted: function dragStarted(_ref7) {
      var _this2 = this;

      var sortable = _ref7.sortable;
      if (!this.isMultiDrag) return;

      if (this.options.sort) {
        // Capture rects,
        // hide multi drag elements (by positioning them absolute),
        // set multi drag elements rects to dragRect,
        // show multi drag elements,
        // animate to rects,
        // unset rects & remove from DOM
        sortable.captureAnimationState();

        if (this.options.animation) {
          multiDragElements.forEach(function (multiDragElement) {
            if (multiDragElement === dragEl$1) return;
            css(multiDragElement, 'position', 'absolute');
          });
          var dragRect = getRect(dragEl$1, false, true, true);
          multiDragElements.forEach(function (multiDragElement) {
            if (multiDragElement === dragEl$1) return;
            setRect(multiDragElement, dragRect);
          });
          folding = true;
          initialFolding = true;
        }
      }

      sortable.animateAll(function () {
        folding = false;
        initialFolding = false;

        if (_this2.options.animation) {
          multiDragElements.forEach(function (multiDragElement) {
            unsetRect(multiDragElement);
          });
        } // Remove all auxiliary multidrag items from el, if sorting enabled


        if (_this2.options.sort) {
          removeMultiDragElements();
        }
      });
    },
    dragOver: function dragOver(_ref8) {
      var target = _ref8.target,
          completed = _ref8.completed,
          cancel = _ref8.cancel;

      if (folding && ~multiDragElements.indexOf(target)) {
        completed(false);
        cancel();
      }
    },
    revert: function revert(_ref9) {
      var fromSortable = _ref9.fromSortable,
          rootEl = _ref9.rootEl,
          sortable = _ref9.sortable,
          dragRect = _ref9.dragRect;

      if (multiDragElements.length > 1) {
        // Setup unfold animation
        multiDragElements.forEach(function (multiDragElement) {
          sortable.addAnimationState({
            target: multiDragElement,
            rect: folding ? getRect(multiDragElement) : dragRect
          });
          unsetRect(multiDragElement);
          multiDragElement.fromRect = dragRect;
          fromSortable.removeAnimationState(multiDragElement);
        });
        folding = false;
        insertMultiDragElements(!this.options.removeCloneOnHide, rootEl);
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref10) {
      var sortable = _ref10.sortable,
          isOwner = _ref10.isOwner,
          insertion = _ref10.insertion,
          activeSortable = _ref10.activeSortable,
          parentEl = _ref10.parentEl,
          putSortable = _ref10.putSortable;
      var options = this.options;

      if (insertion) {
        // Clones must be hidden before folding animation to capture dragRectAbsolute properly
        if (isOwner) {
          activeSortable._hideClone();
        }

        initialFolding = false; // If leaving sort:false root, or already folding - Fold to new location

        if (options.animation && multiDragElements.length > 1 && (folding || !isOwner && !activeSortable.options.sort && !putSortable)) {
          // Fold: Set all multi drag elements's rects to dragEl's rect when multi-drag elements are invisible
          var dragRectAbsolute = getRect(dragEl$1, false, true, true);
          multiDragElements.forEach(function (multiDragElement) {
            if (multiDragElement === dragEl$1) return;
            setRect(multiDragElement, dragRectAbsolute); // Move element(s) to end of parentEl so that it does not interfere with multi-drag clones insertion if they are inserted
            // while folding, and so that we can capture them again because old sortable will no longer be fromSortable

            parentEl.appendChild(multiDragElement);
          });
          folding = true;
        } // Clones must be shown (and check to remove multi drags) after folding when interfering multiDragElements are moved out


        if (!isOwner) {
          // Only remove if not folding (folding will remove them anyways)
          if (!folding) {
            removeMultiDragElements();
          }

          if (multiDragElements.length > 1) {
            var clonesHiddenBefore = clonesHidden;

            activeSortable._showClone(sortable); // Unfold animation for clones if showing from hidden


            if (activeSortable.options.animation && !clonesHidden && clonesHiddenBefore) {
              multiDragClones.forEach(function (clone) {
                activeSortable.addAnimationState({
                  target: clone,
                  rect: clonesFromRect
                });
                clone.fromRect = clonesFromRect;
                clone.thisAnimationDuration = null;
              });
            }
          } else {
            activeSortable._showClone(sortable);
          }
        }
      }
    },
    dragOverAnimationCapture: function dragOverAnimationCapture(_ref11) {
      var dragRect = _ref11.dragRect,
          isOwner = _ref11.isOwner,
          activeSortable = _ref11.activeSortable;
      multiDragElements.forEach(function (multiDragElement) {
        multiDragElement.thisAnimationDuration = null;
      });

      if (activeSortable.options.animation && !isOwner && activeSortable.multiDrag.isMultiDrag) {
        clonesFromRect = _extends({}, dragRect);
        var dragMatrix = matrix(dragEl$1, true);
        clonesFromRect.top -= dragMatrix.f;
        clonesFromRect.left -= dragMatrix.e;
      }
    },
    dragOverAnimationComplete: function dragOverAnimationComplete() {
      if (folding) {
        folding = false;
        removeMultiDragElements();
      }
    },
    drop: function drop(_ref12) {
      var evt = _ref12.originalEvent,
          rootEl = _ref12.rootEl,
          parentEl = _ref12.parentEl,
          sortable = _ref12.sortable,
          dispatchSortableEvent = _ref12.dispatchSortableEvent,
          oldIndex = _ref12.oldIndex,
          putSortable = _ref12.putSortable;
      var toSortable = putSortable || this.sortable;
      if (!evt) return;
      var options = this.options,
          children = parentEl.children; // Multi-drag selection

      if (!dragStarted) {
        if (options.multiDragKey && !this.multiDragKeyDown) {
          this._deselectMultiDrag();
        }

        toggleClass(dragEl$1, options.selectedClass, !~multiDragElements.indexOf(dragEl$1));

        if (!~multiDragElements.indexOf(dragEl$1)) {
          multiDragElements.push(dragEl$1);
          dispatchEvent({
            sortable: sortable,
            rootEl: rootEl,
            name: 'select',
            targetEl: dragEl$1,
            originalEvent: evt
          }); // Modifier activated, select from last to dragEl

          if (evt.shiftKey && lastMultiDragSelect && sortable.el.contains(lastMultiDragSelect)) {
            var lastIndex = index(lastMultiDragSelect),
                currentIndex = index(dragEl$1);

            if (~lastIndex && ~currentIndex && lastIndex !== currentIndex) {
              // Must include lastMultiDragSelect (select it), in case modified selection from no selection
              // (but previous selection existed)
              var n, i;

              if (currentIndex > lastIndex) {
                i = lastIndex;
                n = currentIndex;
              } else {
                i = currentIndex;
                n = lastIndex + 1;
              }

              for (; i < n; i++) {
                if (~multiDragElements.indexOf(children[i])) continue;
                toggleClass(children[i], options.selectedClass, true);
                multiDragElements.push(children[i]);
                dispatchEvent({
                  sortable: sortable,
                  rootEl: rootEl,
                  name: 'select',
                  targetEl: children[i],
                  originalEvent: evt
                });
              }
            }
          } else {
            lastMultiDragSelect = dragEl$1;
          }

          multiDragSortable = toSortable;
        } else {
          multiDragElements.splice(multiDragElements.indexOf(dragEl$1), 1);
          lastMultiDragSelect = null;
          dispatchEvent({
            sortable: sortable,
            rootEl: rootEl,
            name: 'deselect',
            targetEl: dragEl$1,
            originalEvent: evt
          });
        }
      } // Multi-drag drop


      if (dragStarted && this.isMultiDrag) {
        folding = false; // Do not "unfold" after around dragEl if reverted

        if ((parentEl[expando].options.sort || parentEl !== rootEl) && multiDragElements.length > 1) {
          var dragRect = getRect(dragEl$1),
              multiDragIndex = index(dragEl$1, ':not(.' + this.options.selectedClass + ')');
          if (!initialFolding && options.animation) dragEl$1.thisAnimationDuration = null;
          toSortable.captureAnimationState();

          if (!initialFolding) {
            if (options.animation) {
              dragEl$1.fromRect = dragRect;
              multiDragElements.forEach(function (multiDragElement) {
                multiDragElement.thisAnimationDuration = null;

                if (multiDragElement !== dragEl$1) {
                  var rect = folding ? getRect(multiDragElement) : dragRect;
                  multiDragElement.fromRect = rect; // Prepare unfold animation

                  toSortable.addAnimationState({
                    target: multiDragElement,
                    rect: rect
                  });
                }
              });
            } // Multi drag elements are not necessarily removed from the DOM on drop, so to reinsert
            // properly they must all be removed


            removeMultiDragElements();
            multiDragElements.forEach(function (multiDragElement) {
              if (children[multiDragIndex]) {
                parentEl.insertBefore(multiDragElement, children[multiDragIndex]);
              } else {
                parentEl.appendChild(multiDragElement);
              }

              multiDragIndex++;
            }); // If initial folding is done, the elements may have changed position because they are now
            // unfolding around dragEl, even though dragEl may not have his index changed, so update event
            // must be fired here as Sortable will not.

            if (oldIndex === index(dragEl$1)) {
              var update = false;
              multiDragElements.forEach(function (multiDragElement) {
                if (multiDragElement.sortableIndex !== index(multiDragElement)) {
                  update = true;
                  return;
                }
              });

              if (update) {
                dispatchSortableEvent('update');
              }
            }
          } // Must be done after capturing individual rects (scroll bar)


          multiDragElements.forEach(function (multiDragElement) {
            unsetRect(multiDragElement);
          });
          toSortable.animateAll();
        }

        multiDragSortable = toSortable;
      } // Remove clones if necessary


      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
        multiDragClones.forEach(function (clone) {
          clone.parentNode && clone.parentNode.removeChild(clone);
        });
      }
    },
    nullingGlobal: function nullingGlobal() {
      this.isMultiDrag = dragStarted = false;
      multiDragClones.length = 0;
    },
    destroyGlobal: function destroyGlobal() {
      this._deselectMultiDrag();

      off(document, 'pointerup', this._deselectMultiDrag);
      off(document, 'mouseup', this._deselectMultiDrag);
      off(document, 'touchend', this._deselectMultiDrag);
      off(document, 'keydown', this._checkKeyDown);
      off(document, 'keyup', this._checkKeyUp);
    },
    _deselectMultiDrag: function _deselectMultiDrag(evt) {
      if (typeof dragStarted !== "undefined" && dragStarted) return; // Only deselect if selection is in this sortable

      if (multiDragSortable !== this.sortable) return; // Only deselect if target is not item in this sortable

      if (evt && closest(evt.target, this.options.draggable, this.sortable.el, false)) return; // Only deselect if left click

      if (evt && evt.button !== 0) return;

      while (multiDragElements.length) {
        var el = multiDragElements[0];
        toggleClass(el, this.options.selectedClass, false);
        multiDragElements.shift();
        dispatchEvent({
          sortable: this.sortable,
          rootEl: this.sortable.el,
          name: 'deselect',
          targetEl: el,
          originalEvent: evt
        });
      }
    },
    _checkKeyDown: function _checkKeyDown(evt) {
      if (evt.key === this.options.multiDragKey) {
        this.multiDragKeyDown = true;
      }
    },
    _checkKeyUp: function _checkKeyUp(evt) {
      if (evt.key === this.options.multiDragKey) {
        this.multiDragKeyDown = false;
      }
    }
  };
  return _extends(MultiDrag, {
    // Static methods & properties
    pluginName: 'multiDrag',
    utils: {
      /**
       * Selects the provided multi-drag item
       * @param  {HTMLElement} el    The element to be selected
       */
      select: function select(el) {
        var sortable = el.parentNode[expando];
        if (!sortable || !sortable.options.multiDrag || ~multiDragElements.indexOf(el)) return;

        if (multiDragSortable && multiDragSortable !== sortable) {
          multiDragSortable.multiDrag._deselectMultiDrag();

          multiDragSortable = sortable;
        }

        toggleClass(el, sortable.options.selectedClass, true);
        multiDragElements.push(el);
      },

      /**
       * Deselects the provided multi-drag item
       * @param  {HTMLElement} el    The element to be deselected
       */
      deselect: function deselect(el) {
        var sortable = el.parentNode[expando],
            index = multiDragElements.indexOf(el);
        if (!sortable || !sortable.options.multiDrag || !~index) return;
        toggleClass(el, sortable.options.selectedClass, false);
        multiDragElements.splice(index, 1);
      }
    },
    eventProperties: function eventProperties() {
      var _this3 = this;

      var oldIndicies = [],
          newIndicies = [];
      multiDragElements.forEach(function (multiDragElement) {
        oldIndicies.push({
          multiDragElement: multiDragElement,
          index: multiDragElement.sortableIndex
        }); // multiDragElements will already be sorted if folding

        var newIndex;

        if (folding && multiDragElement !== dragEl$1) {
          newIndex = -1;
        } else if (folding) {
          newIndex = index(multiDragElement, ':not(.' + _this3.options.selectedClass + ')');
        } else {
          newIndex = index(multiDragElement);
        }

        newIndicies.push({
          multiDragElement: multiDragElement,
          index: newIndex
        });
      });
      return {
        items: _toConsumableArray(multiDragElements),
        clones: [].concat(multiDragClones),
        oldIndicies: oldIndicies,
        newIndicies: newIndicies
      };
    },
    optionListeners: {
      multiDragKey: function multiDragKey(key) {
        key = key.toLowerCase();

        if (key === 'ctrl') {
          key = 'Control';
        } else if (key.length > 1) {
          key = key.charAt(0).toUpperCase() + key.substr(1);
        }

        return key;
      }
    }
  });
}

function insertMultiDragElements(clonesInserted, rootEl) {
  multiDragElements.forEach(function (multiDragElement, i) {
    var target = rootEl.children[multiDragElement.sortableIndex + (clonesInserted ? Number(i) : 0)];

    if (target) {
      rootEl.insertBefore(multiDragElement, target);
    } else {
      rootEl.appendChild(multiDragElement);
    }
  });
}
/**
 * Insert multi-drag clones
 * @param  {[Boolean]} elementsInserted  Whether the multi-drag elements are inserted
 * @param  {HTMLElement} rootEl
 */


function insertMultiDragClones(elementsInserted, rootEl) {
  multiDragClones.forEach(function (clone, i) {
    var target = rootEl.children[clone.sortableIndex + (elementsInserted ? Number(i) : 0)];

    if (target) {
      rootEl.insertBefore(clone, target);
    } else {
      rootEl.appendChild(clone);
    }
  });
}

function removeMultiDragElements() {
  multiDragElements.forEach(function (multiDragElement) {
    if (multiDragElement === dragEl$1) return;
    multiDragElement.parentNode && multiDragElement.parentNode.removeChild(multiDragElement);
  });
}

var sortable_core_esm = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': Sortable,
  AutoScroll: AutoScrollPlugin,
  MultiDrag: MultiDragPlugin,
  OnSpill: OnSpill,
  Sortable: Sortable,
  Swap: SwapPlugin
});

export { AlarmControlPanelCard, ChipsCard, ClimateCard, CoverCard, EntityCard, FanCard, HumidifierCard, LightCard, LockCard, MediaPlayerCard, PersonCard, TemplateCard, TitleCard, UpdateCard, VacuumCard };
